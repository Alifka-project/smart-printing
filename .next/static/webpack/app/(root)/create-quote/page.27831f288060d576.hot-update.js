"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(root)/create-quote/page",{

/***/ "(app-pages-browser)/./lib/excel-calculation.ts":
/*!**********************************!*\
  !*** ./lib/excel-calculation.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXCEL_DIGITAL_CONSTANTS: () => (/* binding */ EXCEL_DIGITAL_CONSTANTS),\n/* harmony export */   EXCEL_OFFSET_CONSTANTS: () => (/* binding */ EXCEL_OFFSET_CONSTANTS),\n/* harmony export */   calculatePerClick: () => (/* binding */ calculatePerClick),\n/* harmony export */   excelDigitalCalculation: () => (/* binding */ excelDigitalCalculation),\n/* harmony export */   excelOffsetCalculation: () => (/* binding */ excelOffsetCalculation),\n/* harmony export */   validateCalculationAlignment: () => (/* binding */ validateCalculationAlignment),\n/* harmony export */   validateExcelFormulas: () => (/* binding */ validateExcelFormulas),\n/* harmony export */   validatePricingConstants: () => (/* binding */ validatePricingConstants)\n/* harmony export */ });\n// Define types locally since types module might not be available\n// === Excel Calculation Constants (from Excel analysis) ===\nconst EXCEL_DIGITAL_CONSTANTS = {\n    parentSheetCost: 1.00,\n    wasteParents: 3 // Fixed waste sheets (from Excel)\n};\n// === Dynamic Per-Click Calculation (Excel Formula) ===\n// Formula: =IF([@Sheets]*[@[Cut pcs]]>200,IF($L$2=4,1.25,0.5),IF($L$2=4,1.5,0.75)) * multiplier\n// Note: $L$2 refers to colors, not sides\n// Multiplier: 1 for cutPcs=4, 2 for cutPcs=3\n// Color categorization: 1-3 colors = 1 color, 4+ colors = 4 colors\nfunction calculatePerClick(sheets, cutPcs, colorsF) {\n    const totalSheets = sheets * cutPcs;\n    // Categorize colors: 1-3 colors = 1 color, 4+ colors = 4 colors\n    const categorizedColors = colorsF <= 3 ? 1 : 4;\n    // Base per-click rate\n    let basePerClick;\n    if (totalSheets > 200) {\n        // High volume: > 200 total sheets\n        basePerClick = categorizedColors === 4 ? 1.25 : 0.5;\n    } else {\n        // Low volume: â‰¤ 200 total sheets  \n        basePerClick = categorizedColors === 4 ? 1.5 : 0.75;\n    }\n    // Apply dynamic multiplier based on cut pieces (original formula)\n    // Multiplier = (4 - cutPcs + 1)\n    const multiplier = 4 - cutPcs + 1;\n    return basePerClick * multiplier;\n}\nconst EXCEL_OFFSET_CONSTANTS = {\n    parentCost: 8.00,\n    plateCost: 120.00,\n    makeReadySetup: 200.00,\n    makeReadySheets: 10,\n    runPer1000: 60.00,\n    cutOpRate: 8.00 // AED per cut operation (from Excel)\n};\n// === Excel Digital Calculation (Exact Excel Formulas) ===\nfunction excelDigitalCalculation(param) {\n    let { qty, piece, sides, colorsF, colorsB, parent = {\n        w: 100,\n        h: 70\n    }, allowRotate = true, paperCostPerSheet// Optional manual paper pricing override\n     } = param;\n    const colors = colorsF + (sides === 2 ? colorsB !== null && colorsB !== void 0 ? colorsB : 0 : 0);\n    // Excel Formula: ROUNDDOWN((Sheet Width) / (height + 1), 0) Ã— ROUNDDOWN((Sheet Height) / (width + 1), 0)\n    const calculateUpsOption1 = (sheetW, sheetH, pieceW, pieceH)=>{\n        const cols = Math.floor(sheetW / (pieceW + 1));\n        const rows = Math.floor(sheetH / (pieceH + 1));\n        return cols * rows;\n    };\n    // Excel Formula: ROUNDDOWN((Sheet Width) / (width + 1), 0) Ã— ROUNDDOWN((Sheet Height) / (height + 1), 0)\n    const calculateUpsOption2 = (sheetW, sheetH, pieceW, pieceH)=>{\n        const cols = Math.floor(sheetW / (pieceH + 1));\n        const rows = Math.floor(sheetH / (pieceW + 1));\n        return cols * rows;\n    };\n    // Excel Formula: IF(Option 1 > Option 2, Option 1, Option 2)\n    const getBestUps = (option1, option2)=>{\n        return Math.max(option1, option2);\n    };\n    // Excel Formula: ROUNDUP(Quantity / ups per sheet + Waste Sheets, 0)\n    const calculateSheets = (quantity, upsPerSheet)=>{\n        if (upsPerSheet === 0) return 0;\n        return Math.ceil(quantity / upsPerSheet + EXCEL_DIGITAL_CONSTANTS.wasteParents);\n    };\n    // Excel Formula: Sheets Ã— Cut pieces Ã— Per click Ã— Sides (price calculation)\n    const calculatePrice = (sheets, cutPieces, colorsF, sides)=>{\n        const perClickRate = calculatePerClick(sheets, cutPieces, colorsF);\n        return sheets * cutPieces * perClickRate * sides;\n    };\n    // Calculate for different sheet sizes (matching Excel options)\n    const sheetOptions = [\n        {\n            w: 48,\n            h: 33,\n            label: \"48Ã—33 cm\",\n            cutPcs: 4\n        },\n        {\n            w: 70,\n            h: 33,\n            label: \"70Ã—33 cm\",\n            cutPcs: 3\n        }\n    ];\n    return sheetOptions.map((option)=>{\n        // Calculate UPS for both orientations\n        const upsOption1 = calculateUpsOption1(option.w, option.h, piece.w, piece.h);\n        const upsOption2 = allowRotate ? calculateUpsOption2(option.w, option.h, piece.w, piece.h) : 0;\n        // Get best UPS per cut piece (Excel formula)\n        const upsPerCutPiece = getBestUps(upsOption1, upsOption2);\n        if (upsPerCutPiece === 0) return null;\n        // Calculate total ups per sheet = cut pieces Ã— ups per cut piece\n        const totalUpsPerSheet = option.cutPcs * upsPerCutPiece;\n        // Calculate sheets needed (Excel formula)\n        const sheets = calculateSheets(qty, totalUpsPerSheet);\n        // Calculate costs (no units calculation for digital)\n        // Use manual paper pricing if provided, otherwise use default constant\n        const effectivePaperCost = paperCostPerSheet || EXCEL_DIGITAL_CONSTANTS.parentSheetCost;\n        const paper = sheets * effectivePaperCost;\n        const price = calculatePrice(sheets, option.cutPcs, colorsF, sides);\n        const total = price + paper;\n        return {\n            option: option.label,\n            cutPerParent: option.cutPcs,\n            upsPerSheet: totalUpsPerSheet,\n            upsPerParent: totalUpsPerSheet,\n            parents: sheets,\n            paper,\n            clicks: price,\n            total\n        };\n    }).filter(Boolean);\n}\n// === Excel Offset Calculation (Exact Excel Formulas) ===\nfunction excelOffsetCalculation(param) {\n    let { qty, piece, sides, colorsF, colorsB, parent = {\n        w: 100,\n        h: 70\n    }, allowRotate = true } = param;\n    const colors = colorsF + (sides === 2 ? colorsB !== null && colorsB !== void 0 ? colorsB : 0 : 0);\n    // Excel Formula: ROUNDDOWN((Sheet Width) / (height + 1), 0) Ã— ROUNDDOWN((Sheet Height) / (width + 1), 0)\n    const calculateUpsOption1 = (sheetW, sheetH, pieceW, pieceH)=>{\n        const cols = Math.floor(sheetW / (pieceW + 1));\n        const rows = Math.floor(sheetH / (pieceH + 1));\n        return cols * rows;\n    };\n    // Excel Formula: ROUNDDOWN((Sheet Width) / (width + 1), 0) Ã— ROUNDDOWN((Sheet Height) / (height + 1), 0)\n    const calculateUpsOption2 = (sheetW, sheetH, pieceW, pieceH)=>{\n        const cols = Math.floor(sheetW / (pieceH + 1));\n        const rows = Math.floor(sheetH / (pieceW + 1));\n        return cols * rows;\n    };\n    // Excel Formula: IF(Option 1 > Option 2, Option 1, Option 2)\n    const getBestUps = (option1, option2)=>{\n        return Math.max(option1, option2);\n    };\n    // Excel Formula: ROUNDUP(IF(Sheet Width > 50, 120/Cut pieces, 100/Cut pieces), 0)\n    const calculateWasteSheets = (sheetW, cutPieces)=>{\n        const wasteBase = sheetW > 50 ? 120 : 100;\n        return Math.ceil(wasteBase / cutPieces);\n    };\n    // Excel Formula: ROUNDUP(Quantity / ups per sheet + Waste Sheets, 0)\n    const calculateSheets = (quantity, upsPerSheet, wasteSheets)=>{\n        if (upsPerSheet === 0) return 0;\n        return Math.ceil(quantity / upsPerSheet + wasteSheets);\n    };\n    // Excel Formula: IF(Sheets = 0, 0, unit price + paper cost + Plate cost Ã— 2)\n    const calculatePlateCost = (sheets, unitPrice, paperCost, plateCost)=>{\n        if (sheets === 0) return 0;\n        return unitPrice + paperCost + plateCost * 2;\n    };\n    // Use standard press size (35Ã—50 cm) for offset calculations\n    const press = {\n        w: 35,\n        h: 50\n    };\n    // Calculate UPS for both orientations\n    const upsOption1 = calculateUpsOption1(press.w, press.h, piece.w, piece.h);\n    const upsOption2 = allowRotate ? calculateUpsOption2(press.w, press.h, piece.w, piece.h) : 0;\n    // Get best UPS (Excel formula)\n    const bestUps = getBestUps(upsOption1, upsOption2);\n    if (bestUps === 0) {\n        throw new Error(\"Press size not cuttable from parent.\");\n    }\n    // Calculate waste sheets (Excel formula)\n    const wasteSheets = calculateWasteSheets(press.w, bestUps);\n    // Calculate sheets needed (Excel formula)\n    const pressSheets = calculateSheets(qty, bestUps, wasteSheets);\n    // Calculate press per parent\n    const pressPerParent = Math.floor(parent.w / press.w) * Math.floor(parent.h / press.h);\n    const parents = Math.ceil(pressSheets / pressPerParent);\n    // Calculate costs\n    const plates = colors;\n    const paper = parents * EXCEL_OFFSET_CONSTANTS.parentCost;\n    const platesC = plates * EXCEL_OFFSET_CONSTANTS.plateCost;\n    const mkready = EXCEL_OFFSET_CONSTANTS.makeReadySetup + EXCEL_OFFSET_CONSTANTS.makeReadySheets * (EXCEL_OFFSET_CONSTANTS.parentCost / pressPerParent);\n    const run = pressSheets * sides * (EXCEL_OFFSET_CONSTANTS.runPer1000 / 1000);\n    // Calculate cutting operations\n    const cols = Math.floor(press.w / (piece.w + 1));\n    const rows = Math.floor(press.h / (piece.h + 1));\n    const cutOps = cols && rows ? 4 + (cols - 1) + cols * (rows - 1) : 0;\n    const cutting = cutOps * EXCEL_OFFSET_CONSTANTS.cutOpRate * pressSheets;\n    const total = paper + platesC + mkready + run + cutting;\n    return {\n        pressPerParent,\n        upsPerPress: bestUps,\n        pressSheets,\n        parents,\n        plates,\n        paper,\n        platesC,\n        mkready,\n        run,\n        cutting,\n        total\n    };\n}\n// === Excel Formula Validation ===\nfunction validateExcelFormulas() {\n    console.log('ðŸ” Validating Excel Formulas...');\n    // Test Digital Calculation\n    const digitalTest = excelDigitalCalculation({\n        qty: 1000,\n        piece: {\n            w: 5.5,\n            h: 9\n        },\n        sides: 2,\n        colorsF: 4\n    });\n    console.log('ðŸ“± Digital Test Results:', digitalTest);\n    // Test Offset Calculation\n    const offsetTest = excelOffsetCalculation({\n        qty: 3000,\n        piece: {\n            w: 21,\n            h: 29\n        },\n        sides: 2,\n        colorsF: 2\n    });\n    console.log('ðŸ–¨ï¸ Offset Test Results:', offsetTest);\n    // Validate constants alignment\n    const constantsValidation = validatePricingConstants(EXCEL_DIGITAL_CONSTANTS, EXCEL_OFFSET_CONSTANTS);\n    if (constantsValidation.isValid) {\n        console.log('âœ… Excel Constants Validation: PASSED');\n    } else {\n        console.warn('âš ï¸ Excel Constants Validation: FAILED', constantsValidation.errors);\n    }\n    return {\n        digitalTest,\n        offsetTest,\n        constantsValidation\n    };\n}\n// === Calculation Alignment Validation ===\nfunction validateCalculationAlignment(codeResult, excelResult) {\n    let tolerance = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.01;\n    const difference = Math.abs(codeResult - excelResult);\n    const isAligned = difference <= tolerance;\n    if (!isAligned) {\n        console.warn(\"âš ï¸ Calculation misalignment detected:\", {\n            codeResult,\n            excelResult,\n            difference,\n            tolerance\n        });\n    }\n    return isAligned;\n}\n// === Pricing Constants Validation ===\nfunction validatePricingConstants(digitalPricing, offsetPricing) {\n    const errors = [];\n    // Validate Digital Pricing (perClick is now calculated dynamically)\n    // Note: perClick validation removed as it's now calculated dynamically\n    if (digitalPricing.parentSheetCost !== EXCEL_DIGITAL_CONSTANTS.parentSheetCost) {\n        errors.push(\"Digital parentSheetCost mismatch: \".concat(digitalPricing.parentSheetCost, \" vs \").concat(EXCEL_DIGITAL_CONSTANTS.parentSheetCost));\n    }\n    if (digitalPricing.wasteParents !== EXCEL_DIGITAL_CONSTANTS.wasteParents) {\n        errors.push(\"Digital wasteParents mismatch: \".concat(digitalPricing.wasteParents, \" vs \").concat(EXCEL_DIGITAL_CONSTANTS.wasteParents));\n    }\n    // Validate Offset Pricing\n    if (offsetPricing.parentCost !== EXCEL_OFFSET_CONSTANTS.parentCost) {\n        errors.push(\"Offset parentCost mismatch: \".concat(offsetPricing.parentCost, \" vs \").concat(EXCEL_OFFSET_CONSTANTS.parentCost));\n    }\n    if (offsetPricing.plateCost !== EXCEL_OFFSET_CONSTANTS.plateCost) {\n        errors.push(\"Offset plateCost mismatch: \".concat(offsetPricing.plateCost, \" vs \").concat(EXCEL_OFFSET_CONSTANTS.plateCost));\n    }\n    if (offsetPricing.makeReadySetup !== EXCEL_OFFSET_CONSTANTS.makeReadySetup) {\n        errors.push(\"Offset makeReadySetup mismatch: \".concat(offsetPricing.makeReadySetup, \" vs \").concat(EXCEL_OFFSET_CONSTANTS.makeReadySetup));\n    }\n    if (offsetPricing.runPer1000 !== EXCEL_OFFSET_CONSTANTS.runPer1000) {\n        errors.push(\"Offset runPer1000 mismatch: \".concat(offsetPricing.runPer1000, \" vs \").concat(EXCEL_OFFSET_CONSTANTS.runPer1000));\n    }\n    if (offsetPricing.cutOpRate !== EXCEL_OFFSET_CONSTANTS.cutOpRate) {\n        errors.push(\"Offset cutOpRate mismatch: \".concat(offsetPricing.cutOpRate, \" vs \").concat(EXCEL_OFFSET_CONSTANTS.cutOpRate));\n    }\n    return {\n        isValid: errors.length === 0,\n        errors\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9leGNlbC1jYWxjdWxhdGlvbi50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLGlFQUFpRTtBQTRCakUsNERBQTREO0FBQ3JELE1BQU1BLDBCQUEwQjtJQUNyQ0MsaUJBQWlCO0lBQ2pCQyxjQUFjLEVBQVMsa0NBQWtDO0FBQzNELEVBQUU7QUFFRix3REFBd0Q7QUFDeEQsZ0dBQWdHO0FBQ2hHLHlDQUF5QztBQUN6Qyw2Q0FBNkM7QUFDN0MsbUVBQW1FO0FBQzVELFNBQVNDLGtCQUFrQkMsTUFBYyxFQUFFQyxNQUFjLEVBQUVDLE9BQWU7SUFDL0UsTUFBTUMsY0FBY0gsU0FBU0M7SUFFN0IsZ0VBQWdFO0lBQ2hFLE1BQU1HLG9CQUFvQkYsV0FBVyxJQUFJLElBQUk7SUFFN0Msc0JBQXNCO0lBQ3RCLElBQUlHO0lBQ0osSUFBSUYsY0FBYyxLQUFLO1FBQ3JCLGtDQUFrQztRQUNsQ0UsZUFBZUQsc0JBQXNCLElBQUksT0FBTztJQUNsRCxPQUFPO1FBQ0wsbUNBQW1DO1FBQ25DQyxlQUFlRCxzQkFBc0IsSUFBSSxNQUFNO0lBQ2pEO0lBRUEsa0VBQWtFO0lBQ2xFLGdDQUFnQztJQUNoQyxNQUFNRSxhQUFhLElBQUlMLFNBQVM7SUFFaEMsT0FBT0ksZUFBZUM7QUFDeEI7QUFFTyxNQUFNQyx5QkFBeUI7SUFDcENDLFlBQVk7SUFDWkMsV0FBVztJQUNYQyxnQkFBZ0I7SUFDaEJDLGlCQUFpQjtJQUNqQkMsWUFBWTtJQUNaQyxXQUFXLEtBQVkscUNBQXFDO0FBQzlELEVBQUU7QUFFRiwyREFBMkQ7QUFDcEQsU0FBU0Msd0JBQXdCLEtBa0J2QztRQWxCdUMsRUFDdENDLEdBQUcsRUFDSEMsS0FBSyxFQUNMQyxLQUFLLEVBQ0xmLE9BQU8sRUFDUGdCLE9BQU8sRUFDUEMsU0FBUztRQUFFQyxHQUFHO1FBQUtDLEdBQUc7SUFBRyxDQUFDLEVBQzFCQyxjQUFjLElBQUksRUFDbEJDLGlCQUFpQix5Q0FBMEM7TUFVNUQsR0Fs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RUFBQyxRQUF3QyxPQUFsQ0QsdUJBQXVCQyxVQUFVO0lBQzdHO0lBQ0EsSUFBSTZGLGNBQWM1RixTQUFTLEtBQUtGLHVCQUF1QkUsU0FBUyxFQUFFO1FBQ2hFbUYsT0FBT1UsSUFBSSxDQUFDLDhCQUE0RC9GLE9BQTlCOEYsY0FBYzVGLFNBQVMsRUFBQyxRQUF1QyxPQUFqQ0YsdUJBQXVCRSxTQUFTO0lBQzFHO0lBQ0EsSUFBSTRGLGNBQWMzRixjQUFjLEtBQUtILHVCQUF1QkcsY0FBYyxFQUFFO1FBQzFFa0YsT0FBT1UsSUFBSSxDQUFDLG1DQUFzRS9GLE9BQW5DOEYsY0FBYzNGLGNBQWMsRUFBQyxRQUE0QyxPQUF0Q0gsdUJBQXVCRyxjQUFjO0lBQ3pIO0lBQ0EsSUFBSTJGLGNBQWN6RixVQUFVLEtBQUtMLHVCQUF1QkssVUFBVSxFQUFFO1FBQ2xFZ0YsT0FBT1UsSUFBSSxDQUFDLCtCQUE4RC9GLE9BQS9COEYsY0FBY3pGLFVBQVUsRUFBQyxRQUF3QyxPQUFsQ0wsdUJBQXVCSyxVQUFVO0lBQzdHO0lBQ0EsSUFBSXlGLGNBQWN4RixTQUFTLEtBQUtOLHVCQUF1Qk0sU0FBUyxFQUFFO1FBQ2hFK0UsT0FBT1UsSUFBSSxDQUFDLDhCQUE0RC9GLE9BQTlCOEYsY0FBY3hGLFNBQVMsRUFBQyxRQUF1QyxPQUFqQ04sdUJBQXVCTSxTQUFTO0lBQzFHO0lBRUEsT0FBTztRQUNMNkUsU0FBU0UsT0FBT1csTUFBTSxLQUFLO1FBQzNCWDtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9BbGlma2FfUm9vc3Nlby9EZXNrdG9wL1Byb2plY3QvU21hcnQtcHJpbnRpbmctdXBkYXRlL2xpYi9leGNlbC1jYWxjdWxhdGlvbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBEZWZpbmUgdHlwZXMgbG9jYWxseSBzaW5jZSB0eXBlcyBtb2R1bGUgbWlnaHQgbm90IGJlIGF2YWlsYWJsZVxudHlwZSBDbSA9IG51bWJlcjtcblxuaW50ZXJmYWNlIERpZ2l0YWxDb3N0aW5nUmVzdWx0IHtcbiAgb3B0aW9uOiBzdHJpbmc7XG4gIGN1dFBlclBhcmVudDogbnVtYmVyO1xuICB1cHNQZXJTaGVldDogbnVtYmVyO1xuICB1cHNQZXJQYXJlbnQ6IG51bWJlcjtcbiAgcGFyZW50czogbnVtYmVyO1xuICBwYXBlcjogbnVtYmVyO1xuICBjbGlja3M6IG51bWJlcjtcbiAgdG90YWw6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIE9mZnNldENvc3RpbmdSZXN1bHQge1xuICBwcmVzc1BlclBhcmVudDogbnVtYmVyO1xuICB1cHNQZXJQcmVzczogbnVtYmVyO1xuICBwcmVzc1NoZWV0czogbnVtYmVyO1xuICBwYXJlbnRzOiBudW1iZXI7XG4gIHBsYXRlczogbnVtYmVyO1xuICBwYXBlcjogbnVtYmVyO1xuICBwbGF0ZXNDOiBudW1iZXI7XG4gIG1rcmVhZHk6IG51bWJlcjtcbiAgcnVuOiBudW1iZXI7XG4gIGN1dHRpbmc6IG51bWJlcjtcbiAgdG90YWw6IG51bWJlcjtcbn1cblxuLy8gPT09IEV4Y2VsIENhbGN1bGF0aW9uIENvbnN0YW50cyAoZnJvbSBFeGNlbCBhbmFseXNpcykgPT09XG5leHBvcnQgY29uc3QgRVhDRUxfRElHSVRBTF9DT05TVEFOVFMgPSB7XG4gIHBhcmVudFNoZWV0Q29zdDogMS4wMCwgLy8gQUVEIHBlciBwYXJlbnQgc2hlZXQgKGZyb20gdXNlciBleGFtcGxlKVxuICB3YXN0ZVBhcmVudHM6IDMgICAgICAgIC8vIEZpeGVkIHdhc3RlIHNoZWV0cyAoZnJvbSBFeGNlbClcbn07XG5cbi8vID09PSBEeW5hbWljIFBlci1DbGljayBDYWxjdWxhdGlvbiAoRXhjZWwgRm9ybXVsYSkgPT09XG4vLyBGb3JtdWxhOiA9SUYoW0BTaGVldHNdKltAW0N1dCBwY3NdXT4yMDAsSUYoJEwkMj00LDEuMjUsMC41KSxJRigkTCQyPTQsMS41LDAuNzUpKSAqIG11bHRpcGxpZXJcbi8vIE5vdGU6ICRMJDIgcmVmZXJzIHRvIGNvbG9ycywgbm90IHNpZGVzXG4vLyBNdWx0aXBsaWVyOiAxIGZvciBjdXRQY3M9NCwgMiBmb3IgY3V0UGNzPTNcbi8vIENvbG9yIGNhdGVnb3JpemF0aW9uOiAxLTMgY29sb3JzID0gMSBjb2xvciwgNCsgY29sb3JzID0gNCBjb2xvcnNcbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVQZXJDbGljayhzaGVldHM6IG51bWJlciwgY3V0UGNzOiBudW1iZXIsIGNvbG9yc0Y6IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IHRvdGFsU2hlZXRzID0gc2hlZXRzICogY3V0UGNzO1xuICBcbiAgLy8gQ2F0ZWdvcml6ZSBjb2xvcnM6IDEtMyBjb2xvcnMgPSAxIGNvbG9yLCA0KyBjb2xvcnMgPSA0IGNvbG9yc1xuICBjb25zdCBjYXRlZ29yaXplZENvbG9ycyA9IGNvbG9yc0YgPD0gMyA/IDEgOiA0O1xuICBcbiAgLy8gQmFzZSBwZXItY2xpY2sgcmF0ZVxuICBsZXQgYmFzZVBlckNsaWNrOiBudW1iZXI7XG4gIGlmICh0b3RhbFNoZWV0cyA+IDIwMCkge1xuICAgIC8vIEhpZ2ggdm9sdW1lOiA+IDIwMCB0b3RhbCBzaGVldHNcbiAgICBiYXNlUGVyQ2xpY2sgPSBjYXRlZ29yaXplZENvbG9ycyA9PT0gNCA/IDEuMjUgOiAwLjU7XG4gIH0gZWxzZSB7XG4gICAgLy8gTG93IHZvbHVtZTog4omkIDIwMCB0b3RhbCBzaGVldHMgIFxuICAgIGJhc2VQZXJDbGljayA9IGNhdGVnb3JpemVkQ29sb3JzID09PSA0ID8gMS41IDogMC43NTtcbiAgfVxuICBcbiAgLy8gQXBwbHkgZHluYW1pYyBtdWx0aXBsaWVyIGJhc2VkIG9uIGN1dCBwaWVjZXMgKG9yaWdpbmFsIGZvcm11bGEpXG4gIC8vIE11bHRpcGxpZXIgPSAoNCAtIGN1dFBjcyArIDEpXG4gIGNvbnN0IG11bHRpcGxpZXIgPSA0IC0gY3V0UGNzICsgMTtcbiAgXG4gIHJldHVybiBiYXNlUGVyQ2xpY2sgKiBtdWx0aXBsaWVyO1xufVxuXG5leHBvcnQgY29uc3QgRVhDRUxfT0ZGU0VUX0NPTlNUQU5UUyA9IHtcbiAgcGFyZW50Q29zdDogOC4wMCwgICAgICAvLyBBRUQgcGVyIHBhcmVudCBzaGVldCAoZnJvbSBFeGNlbClcbiAgcGxhdGVDb3N0OiAxMjAuMDAsICAgICAvLyBBRUQgcGVyIHBsYXRlIChmcm9tIEV4Y2VsKVxuICBtYWtlUmVhZHlTZXR1cDogMjAwLjAwLCAvLyBBRUQgc2V0dXAgY29zdCAoZnJvbSBFeGNlbClcbiAgbWFrZVJlYWR5U2hlZXRzOiAxMCwgICAvLyBOdW1iZXIgb2YgbWFrZS1yZWFkeSBzaGVldHMgKGZyb20gRXhjZWwpXG4gIHJ1blBlcjEwMDA6IDYwLjAwLCAgICAgLy8gQUVEIHBlciAxMDAwIGltcHJlc3Npb25zIChmcm9tIEV4Y2VsKVxuICBjdXRPcFJhdGU6IDguMDAgICAgICAgIC8vIEFFRCBwZXIgY3V0IG9wZXJhdGlvbiAoZnJvbSBFeGNlbClcbn07XG5cbi8vID09PSBFeGNlbCBEaWdpdGFsIENhbGN1bGF0aW9uIChFeGFjdCBFeGNlbCBGb3JtdWxhcykgPT09XG5leHBvcnQgZnVuY3Rpb24gZXhjZWxEaWdpdGFsQ2FsY3VsYXRpb24oe1xuICBxdHksXG4gIHBpZWNlLFxuICBzaWRlcyxcbiAgY29sb3JzRixcbiAgY29sb3JzQixcbiAgcGFyZW50ID0geyB3OiAxMDAsIGg6IDcwIH0sIC8vIERlZmF1bHQgcGFyZW50IHNoZWV0IHNpemVcbiAgYWxsb3dSb3RhdGUgPSB0cnVlLFxuICBwYXBlckNvc3RQZXJTaGVldCAvLyBPcHRpb25hbCBtYW51YWwgcGFwZXIgcHJpY2luZyBvdmVycmlkZVxufToge1xuICBxdHk6IG51bWJlcjtcbiAgcGllY2U6IHsgdzogQ207IGg6IENtIH07XG4gIHNpZGVzOiAxIHwgMjtcbiAgY29sb3JzRjogMSB8IDIgfCA0O1xuICBjb2xvcnNCPzogMSB8IDIgfCA0O1xuICBwYXJlbnQ/OiB7IHc6IENtOyBoOiBDbSB9O1xuICBhbGxvd1JvdGF0ZT86IGJvb2xlYW47XG4gIHBhcGVyQ29zdFBlclNoZWV0PzogbnVtYmVyOyAvLyBNYW51YWwgcGFwZXIgcHJpY2luZyBvdmVycmlkZVxufSk6IERpZ2l0YWxDb3N0aW5nUmVzdWx0W10ge1xuICBcbiAgY29uc3QgY29sb3JzID0gY29sb3JzRiArIChzaWRlcyA9PT0gMiA/IChjb2xvcnNCID8/IDApIDogMCk7XG4gIFxuICAvLyBFeGNlbCBGb3JtdWxhOiBST1VORERPV04oKFNoZWV0IFdpZHRoKSAvIChoZWlnaHQgKyAxKSwgMCkgw5cgUk9VTkRET1dOKChTaGVldCBIZWlnaHQpIC8gKHdpZHRoICsgMSksIDApXG4gIGNvbnN0IGNhbGN1bGF0ZVVwc09wdGlvbjEgPSAoc2hlZXRXOiBudW1iZXIsIHNoZWV0SDogbnVtYmVyLCBwaWVjZVc6IG51bWJlciwgcGllY2VIOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCBjb2xzID0gTWF0aC5mbG9vcihzaGVldFcgLyAocGllY2VXICsgMSkpO1xuICAgIGNvbnN0IHJvd3MgPSBNYXRoLmZsb29yKHNoZWV0SCAvIChwaWVjZUggKyAxKSk7XG4gICAgcmV0dXJuIGNvbHMgKiByb3dzO1xuICB9O1xuXG4gIC8vIEV4Y2VsIEZvcm11bGE6IFJPVU5ERE9XTigoU2hlZXQgV2lkdGgpIC8gKHdpZHRoICsgMSksIDApIMOXIFJPVU5ERE9XTigoU2hlZXQgSGVpZ2h0KSAvIChoZWlnaHQgKyAxKSwgMClcbiAgY29uc3QgY2FsY3VsYXRlVXBzT3B0aW9uMiA9IChzaGVldFc6IG51bWJlciwgc2hlZXRIOiBudW1iZXIsIHBpZWNlVzogbnVtYmVyLCBwaWVjZUg6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IGNvbHMgPSBNYXRoLmZsb29yKHNoZWV0VyAvIChwaWVjZUggKyAxKSk7XG4gICAgY29uc3Qgcm93cyA9IE1hdGguZmxvb3Ioc2hlZXRIIC8gKHBpZWNlVyArIDEpKTtcbiAgICByZXR1cm4gY29scyAqIHJvd3M7XG4gIH07XG5cbiAgLy8gRXhjZWwgRm9ybXVsYTogSUYoT3B0aW9uIDEgPiBPcHRpb24gMiwgT3B0aW9uIDEsIE9wdGlvbiAyKVxuICBjb25zdCBnZXRCZXN0VXBzID0gKG9wdGlvbjE6IG51bWJlciwgb3B0aW9uMjogbnVtYmVyKSA9PiB7XG4gICAgcmV0dXJuIE1hdGgubWF4KG9wdGlvbjEsIG9wdGlvbjIpO1xuICB9O1xuXG4gIC8vIEV4Y2VsIEZvcm11bGE6IFJPVU5EVVAoUXVhbnRpdHkgLyB1cHMgcGVyIHNoZWV0ICsgV2FzdGUgU2hlZXRzLCAwKVxuICBjb25zdCBjYWxjdWxhdGVTaGVldHMgPSAocXVhbnRpdHk6IG51bWJlciwgdXBzUGVyU2hlZXQ6IG51bWJlcikgPT4ge1xuICAgIGlmICh1cHNQZXJTaGVldCA9PT0gMCkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIE1hdGguY2VpbChxdWFudGl0eSAvIHVwc1BlclNoZWV0ICsgRVhDRUxfRElHSVRBTF9DT05TVEFOVFMud2FzdGVQYXJlbnRzKTtcbiAgfTtcblxuICAvLyBFeGNlbCBGb3JtdWxhOiBTaGVldHMgw5cgQ3V0IHBpZWNlcyDDlyBQZXIgY2xpY2sgw5cgU2lkZXMgKHByaWNlIGNhbGN1bGF0aW9uKVxuICBjb25zdCBjYWxjdWxhdGVQcmljZSA9IChzaGVldHM6IG51bWJlciwgY3V0UGllY2VzOiBudW1iZXIsIGNvbG9yc0Y6IG51bWJlciwgc2lkZXM6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IHBlckNsaWNrUmF0ZSA9IGNhbGN1bGF0ZVBlckNsaWNrKHNoZWV0cywgY3V0UGllY2VzLCBjb2xvcnNGKTtcbiAgICByZXR1cm4gc2hlZXRzICogY3V0UGllY2VzICogcGVyQ2xpY2tSYXRlICogc2lkZXM7XG4gIH07XG5cbiAgLy8gQ2FsY3VsYXRlIGZvciBkaWZmZXJlbnQgc2hlZXQgc2l6ZXMgKG1hdGNoaW5nIEV4Y2VsIG9wdGlvbnMpXG4gIGNvbnN0IHNoZWV0T3B0aW9ucyA9IFtcbiAgICB7IHc6IDQ4LCBoOiAzMywgbGFiZWw6IFwiNDjDlzMzIGNtXCIsIGN1dFBjczogNCB9LFxuICAgIHsgdzogNzAsIGg6IDMzLCBsYWJlbDogXCI3MMOXMzMgY21cIiwgY3V0UGNzOiAzIH1cbiAgXTtcblxuICByZXR1cm4gc2hlZXRPcHRpb25zLm1hcChvcHRpb24gPT4ge1xuICAgIC8vIENhbGN1bGF0ZSBVUFMgZm9yIGJvdGggb3JpZW50YXRpb25zXG4gICAgY29uc3QgdXBzT3B0aW9uMSA9IGNhbGN1bGF0ZVVwc09wdGlvbjEob3B0aW9uLncsIG9wdGlvbi5oLCBwaWVjZS53LCBwaWVjZS5oKTtcbiAgICBjb25zdCB1cHNPcHRpb24yID0gYWxsb3dSb3RhdGUgPyBjYWxjdWxhdGVVcHNPcHRpb24yKG9wdGlvbi53LCBvcHRpb24uaCwgcGllY2UudywgcGllY2UuaCkgOiAwO1xuICAgIFxuICAgIC8vIEdldCBiZXN0IFVQUyBwZXIgY3V0IHBpZWNlIChFeGNlbCBmb3JtdWxhKVxuICAgIGNvbnN0IHVwc1BlckN1dFBpZWNlID0gZ2V0QmVzdFVwcyh1cHNPcHRpb24xLCB1cHNPcHRpb24yKTtcbiAgICBcbiAgICBpZiAodXBzUGVyQ3V0UGllY2UgPT09IDApIHJldHVybiBudWxsO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRvdGFsIHVwcyBwZXIgc2hlZXQgPSBjdXQgcGllY2VzIMOXIHVwcyBwZXIgY3V0IHBpZWNlXG4gICAgY29uc3QgdG90YWxVcHNQZXJTaGVldCA9IG9wdGlvbi5jdXRQY3MgKiB1cHNQZXJDdXRQaWVjZTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgc2hlZXRzIG5lZWRlZCAoRXhjZWwgZm9ybXVsYSlcbiAgICBjb25zdCBzaGVldHMgPSBjYWxjdWxhdGVTaGVldHMocXR5LCB0b3RhbFVwc1BlclNoZWV0KTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgY29zdHMgKG5vIHVuaXRzIGNhbGN1bGF0aW9uIGZvciBkaWdpdGFsKVxuICAgIC8vIFVzZSBtYW51YWwgcGFwZXIgcHJpY2luZyBpZiBwcm92aWRlZCwgb3RoZXJ3aXNlIHVzZSBkZWZhdWx0IGNvbnN0YW50XG4gICAgY29uc3QgZWZmZWN0aXZlUGFwZXJDb3N0ID0gcGFwZXJDb3N0UGVyU2hlZXQgfHwgRVhDRUxfRElHSVRBTF9DT05TVEFOVFMucGFyZW50U2hlZXRDb3N0O1xuICAgIGNvbnN0IHBhcGVyID0gc2hlZXRzICogZWZmZWN0aXZlUGFwZXJDb3N0O1xuICAgIGNvbnN0IHByaWNlID0gY2FsY3VsYXRlUHJpY2Uoc2hlZXRzLCBvcHRpb24uY3V0UGNzLCBjb2xvcnNGLCBzaWRlcyk7XG4gICAgY29uc3QgdG90YWwgPSBwcmljZSArIHBhcGVyO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9wdGlvbjogb3B0aW9uLmxhYmVsLFxuICAgICAgY3V0UGVyUGFyZW50OiBvcHRpb24uY3V0UGNzLFxuICAgICAgdXBzUGVyU2hlZXQ6IHRvdGFsVXBzUGVyU2hlZXQsXG4gICAgICB1cHNQZXJQYXJlbnQ6IHRvdGFsVXBzUGVyU2hlZXQsXG4gICAgICBwYXJlbnRzOiBzaGVldHMsXG4gICAgICBwYXBlcixcbiAgICAgIGNsaWNrczogcHJpY2UsIC8vIFByaWNlIGluY2x1ZGVzIGNsaWNrIGNvc3RcbiAgICAgIHRvdGFsXG4gICAgfTtcbiAgfSkuZmlsdGVyKEJvb2xlYW4pIGFzIERpZ2l0YWxDb3N0aW5nUmVzdWx0W107XG59XG5cbi8vID09PSBFeGNlbCBPZmZzZXQgQ2FsY3VsYXRpb24gKEV4YWN0IEV4Y2VsIEZvcm11bGFzKSA9PT1cbmV4cG9ydCBmdW5jdGlvbiBleGNlbE9mZnNldENhbGN1bGF0aW9uKHtcbiAgcXR5LFxuICBwaWVjZSxcbiAgc2lkZXMsXG4gIGNvbG9yc0YsXG4gIGNvbG9yc0IsXG4gIHBhcmVudCA9IHsgdzogMTAwLCBoOiA3MCB9LCAvLyBEZWZhdWx0IHBhcmVudCBzaGVldCBzaXplXG4gIGFsbG93Um90YXRlID0gdHJ1ZVxufToge1xuICBxdHk6IG51bWJlcjtcbiAgcGllY2U6IHsgdzogQ207IGg6IENtIH07XG4gIHNpZGVzOiAxIHwgMjtcbiAgY29sb3JzRjogMSB8IDIgfCA0O1xuICBjb2xvcnNCPzogMSB8IDIgfCA0O1xuICBwYXJlbnQ/OiB7IHc6IENtOyBoOiBDbSB9O1xuICBhbGxvd1JvdGF0ZT86IGJvb2xlYW47XG59KTogT2Zmc2V0Q29zdGluZ1Jlc3VsdCB7XG4gIFxuICBjb25zdCBjb2xvcnMgPSBjb2xvcnNGICsgKHNpZGVzID09PSAyID8gKGNvbG9yc0IgPz8gMCkgOiAwKTtcbiAgXG4gIC8vIEV4Y2VsIEZvcm11bGE6IFJPVU5ERE9XTigoU2hlZXQgV2lkdGgpIC8gKGhlaWdodCArIDEpLCAwKSDDlyBST1VORERPV04oKFNoZWV0IEhlaWdodCkgLyAod2lkdGggKyAxKSwgMClcbiAgY29uc3QgY2FsY3VsYXRlVXBzT3B0aW9uMSA9IChzaGVldFc6IG51bWJlciwgc2hlZXRIOiBudW1iZXIsIHBpZWNlVzogbnVtYmVyLCBwaWVjZUg6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IGNvbHMgPSBNYXRoLmZsb29yKHNoZWV0VyAvIChwaWVjZVcgKyAxKSk7XG4gICAgY29uc3Qgcm93cyA9IE1hdGguZmxvb3Ioc2hlZXRIIC8gKHBpZWNlSCArIDEpKTtcbiAgICByZXR1cm4gY29scyAqIHJvd3M7XG4gIH07XG5cbiAgLy8gRXhjZWwgRm9ybXVsYTogUk9VTkRET1dOKChTaGVldCBXaWR0aCkgLyAod2lkdGggKyAxKSwgMCkgw5cgUk9VTkRET1dOKChTaGVldCBIZWlnaHQpIC8gKGhlaWdodCArIDEpLCAwKVxuICBjb25zdCBjYWxjdWxhdGVVcHNPcHRpb24yID0gKHNoZWV0VzogbnVtYmVyLCBzaGVldEg6IG51bWJlciwgcGllY2VXOiBudW1iZXIsIHBpZWNlSDogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgY29scyA9IE1hdGguZmxvb3Ioc2hlZXRXIC8gKHBpZWNlSCArIDEpKTtcbiAgICBjb25zdCByb3dzID0gTWF0aC5mbG9vcihzaGVldEggLyAocGllY2VXICsgMSkpO1xuICAgIHJldHVybiBjb2xzICogcm93cztcbiAgfTtcblxuICAvLyBFeGNlbCBGb3JtdWxhOiBJRihPcHRpb24gMSA+IE9wdGlvbiAyLCBPcHRpb24gMSwgT3B0aW9uIDIpXG4gIGNvbnN0IGdldEJlc3RVcHMgPSAob3B0aW9uMTogbnVtYmVyLCBvcHRpb24yOiBudW1iZXIpID0+IHtcbiAgICByZXR1cm4gTWF0aC5tYXgob3B0aW9uMSwgb3B0aW9uMik7XG4gIH07XG5cbiAgLy8gRXhjZWwgRm9ybXVsYTogUk9VTkRVUChJRihTaGVldCBXaWR0aCA+IDUwLCAxMjAvQ3V0IHBpZWNlcywgMTAwL0N1dCBwaWVjZXMpLCAwKVxuICBjb25zdCBjYWxjdWxhdGVXYXN0ZVNoZWV0cyA9IChzaGVldFc6IG51bWJlciwgY3V0UGllY2VzOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCB3YXN0ZUJhc2UgPSBzaGVldFcgPiA1MCA/IDEyMCA6IDEwMDtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHdhc3RlQmFzZSAvIGN1dFBpZWNlcyk7XG4gIH07XG5cbiAgLy8gRXhjZWwgRm9ybXVsYTogUk9VTkRVUChRdWFudGl0eSAvIHVwcyBwZXIgc2hlZXQgKyBXYXN0ZSBTaGVldHMsIDApXG4gIGNvbnN0IGNhbGN1bGF0ZVNoZWV0cyA9IChxdWFudGl0eTogbnVtYmVyLCB1cHNQZXJTaGVldDogbnVtYmVyLCB3YXN0ZVNoZWV0czogbnVtYmVyKSA9PiB7XG4gICAgaWYgKHVwc1BlclNoZWV0ID09PSAwKSByZXR1cm4gMDtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHF1YW50aXR5IC8gdXBzUGVyU2hlZXQgKyB3YXN0ZVNoZWV0cyk7XG4gIH07XG5cbiAgLy8gRXhjZWwgRm9ybXVsYTogSUYoU2hlZXRzID0gMCwgMCwgdW5pdCBwcmljZSArIHBhcGVyIGNvc3QgKyBQbGF0ZSBjb3N0IMOXIDIpXG4gIGNvbnN0IGNhbGN1bGF0ZVBsYXRlQ29zdCA9IChzaGVldHM6IG51bWJlciwgdW5pdFByaWNlOiBudW1iZXIsIHBhcGVyQ29zdDogbnVtYmVyLCBwbGF0ZUNvc3Q6IG51bWJlcikgPT4ge1xuICAgIGlmIChzaGVldHMgPT09IDApIHJldHVybiAwO1xuICAgIHJldHVybiB1bml0UHJpY2UgKyBwYXBlckNvc3QgKyAocGxhdGVDb3N0ICogMik7XG4gIH07XG5cbiAgLy8gVXNlIHN0YW5kYXJkIHByZXNzIHNpemUgKDM1w5c1MCBjbSkgZm9yIG9mZnNldCBjYWxjdWxhdGlvbnNcbiAgY29uc3QgcHJlc3MgPSB7IHc6IDM1LCBoOiA1MCB9O1xuICBcbiAgLy8gQ2FsY3VsYXRlIFVQUyBmb3IgYm90aCBvcmllbnRhdGlvbnNcbiAgY29uc3QgdXBzT3B0aW9uMSA9IGNhbGN1bGF0ZVVwc09wdGlvbjEocHJlc3MudywgcHJlc3MuaCwgcGllY2UudywgcGllY2UuaCk7XG4gIGNvbnN0IHVwc09wdGlvbjIgPSBhbGxvd1JvdGF0ZSA/IGNhbGN1bGF0ZVVwc09wdGlvbjIocHJlc3MudywgcHJlc3MuaCwgcGllY2UudywgcGllY2UuaCkgOiAwO1xuICBcbiAgLy8gR2V0IGJlc3QgVVBTIChFeGNlbCBmb3JtdWxhKVxuICBjb25zdCBiZXN0VXBzID0gZ2V0QmVzdFVwcyh1cHNPcHRpb24xLCB1cHNPcHRpb24yKTtcbiAgXG4gIGlmIChiZXN0VXBzID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUHJlc3Mgc2l6ZSBub3QgY3V0dGFibGUgZnJvbSBwYXJlbnQuXCIpO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIHdhc3RlIHNoZWV0cyAoRXhjZWwgZm9ybXVsYSlcbiAgY29uc3Qgd2FzdGVTaGVldHMgPSBjYWxjdWxhdGVXYXN0ZVNoZWV0cyhwcmVzcy53LCBiZXN0VXBzKTtcbiAgXG4gIC8vIENhbGN1bGF0ZSBzaGVldHMgbmVlZGVkIChFeGNlbCBmb3JtdWxhKVxuICBjb25zdCBwcmVzc1NoZWV0cyA9IGNhbGN1bGF0ZVNoZWV0cyhxdHksIGJlc3RVcHMsIHdhc3RlU2hlZXRzKTtcbiAgXG4gIC8vIENhbGN1bGF0ZSBwcmVzcyBwZXIgcGFyZW50XG4gIGNvbnN0IHByZXNzUGVyUGFyZW50ID0gTWF0aC5mbG9vcihwYXJlbnQudyAvIHByZXNzLncpICogTWF0aC5mbG9vcihwYXJlbnQuaCAvIHByZXNzLmgpO1xuICBjb25zdCBwYXJlbnRzID0gTWF0aC5jZWlsKHByZXNzU2hlZXRzIC8gcHJlc3NQZXJQYXJlbnQpO1xuXG4gIC8vIENhbGN1bGF0ZSBjb3N0c1xuICBjb25zdCBwbGF0ZXMgPSBjb2xvcnM7XG4gIGNvbnN0IHBhcGVyID0gcGFyZW50cyAqIEVYQ0VMX09GRlNFVF9DT05TVEFOVFMucGFyZW50Q29zdDtcbiAgY29uc3QgcGxhdGVzQyA9IHBsYXRlcyAqIEVYQ0VMX09GRlNFVF9DT05TVEFOVFMucGxhdGVDb3N0O1xuICBjb25zdCBta3JlYWR5ID0gRVhDRUxfT0ZGU0VUX0NPTlNUQU5UUy5tYWtlUmVhZHlTZXR1cCArIChFWENFTF9PRkZTRVRfQ09OU1RBTlRTLm1ha2VSZWFkeVNoZWV0cyAqIChFWENFTF9PRkZTRVRfQ09OU1RBTlRTLnBhcmVudENvc3QgLyBwcmVzc1BlclBhcmVudCkpO1xuICBjb25zdCBydW4gPSAocHJlc3NTaGVldHMgKiBzaWRlcykgKiAoRVhDRUxfT0ZGU0VUX0NPTlNUQU5UUy5ydW5QZXIxMDAwIC8gMTAwMCk7XG4gIFxuICAvLyBDYWxjdWxhdGUgY3V0dGluZyBvcGVyYXRpb25zXG4gIGNvbnN0IGNvbHMgPSBNYXRoLmZsb29yKHByZXNzLncgLyAocGllY2UudyArIDEpKTtcbiAgY29uc3Qgcm93cyA9IE1hdGguZmxvb3IocHJlc3MuaCAvIChwaWVjZS5oICsgMSkpO1xuICBjb25zdCBjdXRPcHMgPSAoY29scyAmJiByb3dzKSA/IDQgKyAoY29scyAtIDEpICsgY29scyAqIChyb3dzIC0gMSkgOiAwO1xuICBjb25zdCBjdXR0aW5nID0gY3V0T3BzICogRVhDRUxfT0ZGU0VUX0NPTlNUQU5UUy5jdXRPcFJhdGUgKiBwcmVzc1NoZWV0cztcbiAgXG4gIGNvbnN0IHRvdGFsID0gcGFwZXIgKyBwbGF0ZXNDICsgbWtyZWFkeSArIHJ1biArIGN1dHRpbmc7XG5cbiAgcmV0dXJuIHtcbiAgICBwcmVzc1BlclBhcmVudCxcbiAgICB1cHNQZXJQcmVzczogYmVzdFVwcyxcbiAgICBwcmVzc1NoZWV0cyxcbiAgICBwYXJlbnRzLFxuICAgIHBsYXRlcyxcbiAgICBwYXBlcixcbiAgICBwbGF0ZXNDLFxuICAgIG1rcmVhZHksXG4gICAgcnVuLFxuICAgIGN1dHRpbmcsXG4gICAgdG90YWxcbiAgfTtcbn1cblxuLy8gPT09IEV4Y2VsIEZvcm11bGEgVmFsaWRhdGlvbiA9PT1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUV4Y2VsRm9ybXVsYXMoKSB7XG4gIGNvbnNvbGUubG9nKCfwn5SNIFZhbGlkYXRpbmcgRXhjZWwgRm9ybXVsYXMuLi4nKTtcbiAgXG4gIC8vIFRlc3QgRGlnaXRhbCBDYWxjdWxhdGlvblxuICBjb25zdCBkaWdpdGFsVGVzdCA9IGV4Y2VsRGlnaXRhbENhbGN1bGF0aW9uKHtcbiAgICBxdHk6IDEwMDAsXG4gICAgcGllY2U6IHsgdzogNS41LCBoOiA5IH0sXG4gICAgc2lkZXM6IDIsXG4gICAgY29sb3JzRjogNFxuICB9KTtcbiAgXG4gIGNvbnNvbGUubG9nKCfwn5OxIERpZ2l0YWwgVGVzdCBSZXN1bHRzOicsIGRpZ2l0YWxUZXN0KTtcbiAgXG4gIC8vIFRlc3QgT2Zmc2V0IENhbGN1bGF0aW9uXG4gIGNvbnN0IG9mZnNldFRlc3QgPSBleGNlbE9mZnNldENhbGN1bGF0aW9uKHtcbiAgICBxdHk6IDMwMDAsXG4gICAgcGllY2U6IHsgdzogMjEsIGg6IDI5IH0sXG4gICAgc2lkZXM6IDIsXG4gICAgY29sb3JzRjogMlxuICB9KTtcbiAgXG4gIGNvbnNvbGUubG9nKCfwn5ao77iPIE9mZnNldCBUZXN0IFJlc3VsdHM6Jywgb2Zmc2V0VGVzdCk7XG4gIFxuICAvLyBWYWxpZGF0ZSBjb25zdGFudHMgYWxpZ25tZW50XG4gIGNvbnN0IGNvbnN0YW50c1ZhbGlkYXRpb24gPSB2YWxpZGF0ZVByaWNpbmdDb25zdGFudHMoXG4gICAgRVhDRUxfRElHSVRBTF9DT05TVEFOVFMsXG4gICAgRVhDRUxfT0ZGU0VUX0NPTlNUQU5UU1xuICApO1xuICBcbiAgaWYgKGNvbnN0YW50c1ZhbGlkYXRpb24uaXNWYWxpZCkge1xuICAgIGNvbnNvbGUubG9nKCfinIUgRXhjZWwgQ29uc3RhbnRzIFZhbGlkYXRpb246IFBBU1NFRCcpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUud2Fybign4pqg77iPIEV4Y2VsIENvbnN0YW50cyBWYWxpZGF0aW9uOiBGQUlMRUQnLCBjb25zdGFudHNWYWxpZGF0aW9uLmVycm9ycyk7XG4gIH1cbiAgXG4gIHJldHVybiB7IGRpZ2l0YWxUZXN0LCBvZmZzZXRUZXN0LCBjb25zdGFudHNWYWxpZGF0aW9uIH07XG59XG5cbi8vID09PSBDYWxjdWxhdGlvbiBBbGlnbm1lbnQgVmFsaWRhdGlvbiA9PT1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUNhbGN1bGF0aW9uQWxpZ25tZW50KFxuICBjb2RlUmVzdWx0OiBudW1iZXIsXG4gIGV4Y2VsUmVzdWx0OiBudW1iZXIsXG4gIHRvbGVyYW5jZTogbnVtYmVyID0gMC4wMVxuKTogYm9vbGVhbiB7XG4gIGNvbnN0IGRpZmZlcmVuY2UgPSBNYXRoLmFicyhjb2RlUmVzdWx0IC0gZXhjZWxSZXN1bHQpO1xuICBjb25zdCBpc0FsaWduZWQgPSBkaWZmZXJlbmNlIDw9IHRvbGVyYW5jZTtcbiAgXG4gIGlmICghaXNBbGlnbmVkKSB7XG4gICAgY29uc29sZS53YXJuKGDimqDvuI8gQ2FsY3VsYXRpb24gbWlzYWxpZ25tZW50IGRldGVjdGVkOmAsIHtcbiAgICAgIGNvZGVSZXN1bHQsXG4gICAgICBleGNlbFJlc3VsdCxcbiAgICAgIGRpZmZlcmVuY2UsXG4gICAgICB0b2xlcmFuY2VcbiAgICB9KTtcbiAgfVxuICBcbiAgcmV0dXJuIGlzQWxpZ25lZDtcbn1cblxuLy8gPT09IFByaWNpbmcgQ29uc3RhbnRzIFZhbGlkYXRpb24gPT09XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVQcmljaW5nQ29uc3RhbnRzKFxuICBkaWdpdGFsUHJpY2luZzogYW55LFxuICBvZmZzZXRQcmljaW5nOiBhbnlcbik6IHsgaXNWYWxpZDogYm9vbGVhbjsgZXJyb3JzOiBzdHJpbmdbXSB9IHtcbiAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuICBcbiAgLy8gVmFsaWRhdGUgRGlnaXRhbCBQcmljaW5nIChwZXJDbGljayBpcyBub3cgY2FsY3VsYXRlZCBkeW5hbWljYWxseSlcbiAgLy8gTm90ZTogcGVyQ2xpY2sgdmFsaWRhdGlvbiByZW1vdmVkIGFzIGl0J3Mgbm93IGNhbGN1bGF0ZWQgZHluYW1pY2FsbHlcbiAgaWYgKGRpZ2l0YWxQcmljaW5nLnBhcmVudFNoZWV0Q29zdCAhPT0gRVhDRUxfRElHSVRBTF9DT05TVEFOVFMucGFyZW50U2hlZXRDb3N0KSB7XG4gICAgZXJyb3JzLnB1c2goYERpZ2l0YWwgcGFyZW50U2hlZXRDb3N0IG1pc21hdGNoOiAke2RpZ2l0YWxQcmljaW5nLnBhcmVudFNoZWV0Q29zdH0gdnMgJHtFWENFTF9ESUdJVEFMX0NPTlNUQU5UUy5wYXJlbnRTaGVldENvc3R9YCk7XG4gIH1cbiAgaWYgKGRpZ2l0YWxQcmljaW5nLndhc3RlUGFyZW50cyAhPT0gRVhDRUxfRElHSVRBTF9DT05TVEFOVFMud2FzdGVQYXJlbnRzKSB7XG4gICAgZXJyb3JzLnB1c2goYERpZ2l0YWwgd2FzdGVQYXJlbnRzIG1pc21hdGNoOiAke2RpZ2l0YWxQcmljaW5nLndhc3RlUGFyZW50c30gdnMgJHtFWENFTF9ESUdJVEFMX0NPTlNUQU5UUy53YXN0ZVBhcmVudHN9YCk7XG4gIH1cbiAgXG4gIC8vIFZhbGlkYXRlIE9mZnNldCBQcmljaW5nXG4gIGlmIChvZmZzZXRQcmljaW5nLnBhcmVudENvc3QgIT09IEVYQ0VMX09GRlNFVF9DT05TVEFOVFMucGFyZW50Q29zdCkge1xuICAgIGVycm9ycy5wdXNoKGBPZmZzZXQgcGFyZW50Q29zdCBtaXNtYXRjaDogJHtvZmZzZXRQcmljaW5nLnBhcmVudENvc3R9IHZzICR7RVhDRUxfT0ZGU0VUX0NPTlNUQU5UUy5wYXJlbnRDb3N0fWApO1xuICB9XG4gIGlmIChvZmZzZXRQcmljaW5nLnBsYXRlQ29zdCAhPT0gRVhDRUxfT0ZGU0VUX0NPTlNUQU5UUy5wbGF0ZUNvc3QpIHtcbiAgICBlcnJvcnMucHVzaChgT2Zmc2V0IHBsYXRlQ29zdCBtaXNtYXRjaDogJHtvZmZzZXRQcmljaW5nLnBsYXRlQ29zdH0gdnMgJHtFWENFTF9PRkZTRVRfQ09OU1RBTlRTLnBsYXRlQ29zdH1gKTtcbiAgfVxuICBpZiAob2Zmc2V0UHJpY2luZy5tYWtlUmVhZHlTZXR1cCAhPT0gRVhDRUxfT0ZGU0VUX0NPTlNUQU5UUy5tYWtlUmVhZHlTZXR1cCkge1xuICAgIGVycm9ycy5wdXNoKGBPZmZzZXQgbWFrZVJlYWR5U2V0dXAgbWlzbWF0Y2g6ICR7b2Zmc2V0UHJpY2luZy5tYWtlUmVhZHlTZXR1cH0gdnMgJHtFWENFTF9PRkZTRVRfQ09OU1RBTlRTLm1ha2VSZWFkeVNldHVwfWApO1xuICB9XG4gIGlmIChvZmZzZXRQcmljaW5nLnJ1blBlcjEwMDAgIT09IEVYQ0VMX09GRlNFVF9DT05TVEFOVFMucnVuUGVyMTAwMCkge1xuICAgIGVycm9ycy5wdXNoKGBPZmZzZXQgcnVuUGVyMTAwMCBtaXNtYXRjaDogJHtvZmZzZXRQcmljaW5nLnJ1blBlcjEwMDB9IHZzICR7RVhDRUxfT0ZGU0VUX0NPTlNUQU5UUy5ydW5QZXIxMDAwfWApO1xuICB9XG4gIGlmIChvZmZzZXRQcmljaW5nLmN1dE9wUmF0ZSAhPT0gRVhDRUxfT0ZGU0VUX0NPTlNUQU5UUy5jdXRPcFJhdGUpIHtcbiAgICBlcnJvcnMucHVzaChgT2Zmc2V0IGN1dE9wUmF0ZSBtaXNtYXRjaDogJHtvZmZzZXRQcmljaW5nLmN1dE9wUmF0ZX0gdnMgJHtFWENFTF9PRkZTRVRfQ09OU1RBTlRTLmN1dE9wUmF0ZX1gKTtcbiAgfVxuICBcbiAgcmV0dXJuIHtcbiAgICBpc1ZhbGlkOiBlcnJvcnMubGVuZ3RoID09PSAwLFxuICAgIGVycm9yc1xuICB9O1xufVxuXG5cblxuIl0sIm5hbWVzIjpbIkVYQ0VMX0RJR0lUQUxfQ09OU1RBTlRTIiwicGFyZW50U2hlZXRDb3N0Iiwid2FzdGVQYXJlbnRzIiwiY2FsY3VsYXRlUGVyQ2xpY2siLCJzaGVldHMiLCJjdXRQY3MiLCJjb2xvcnNGIiwidG90YWxTaGVldHMiLCJjYXRlZ29yaXplZENvbG9ycyIsImJhc2VQZXJDbGljayIsIm11bHRpcGxpZXIiLCJFWENFTF9PRkZTRVRfQ09OU1RBTlRTIiwicGFyZW50Q29zdCIsInBsYXRlQ29zdCIsIm1ha2VSZWFkeVNldHVwIiwibWFrZVJlYWR5U2hlZXRzIiwicnVuUGVyMTAwMCIsImN1dE9wUmF0ZSIsImV4Y2VsRGlnaXRhbENhbGN1bGF0aW9uIiwicXR5IiwicGllY2UiLCJzaWRlcyIsImNvbG9yc0IiLCJwYXJlbnQiLCJ3IiwiaCIsImFsbG93Um90YXRlIiwicGFwZXJDb3N0UGVyU2hlZXQiLCJjb2xvcnMiLCJjYWxjdWxhdGVVcHNPcHRpb24xIiwic2hlZXRXIiwic2hlZXRIIiwicGllY2VXIiwicGllY2VIIiwiY29scyIsIk1hdGgiLCJmbG9vciIsInJvd3MiLCJjYWxjdWxhdGVVcHNPcHRpb24yIiwiZ2V0QmVzdFVwcyIsIm9wdGlvbjEiLCJvcHRpb24yIiwibWF4IiwiY2FsY3VsYXRlU2hlZXRzIiwicXVhbnRpdHkiLCJ1cHNQZXJTaGVldCIsImNlaWwiLCJjYWxjdWxhdGVQcmljZSIsImN1dFBpZWNlcyIsInBlckNsaWNrUmF0ZSIsInNoZWV0T3B0aW9ucyIsImxhYmVsIiwibWFwIiwib3B0aW9uIiwidXBzT3B0aW9uMSIsInVwc09wdGlvbjIiLCJ1cHNQZXJDdXRQaWVjZSIsInRvdGFsVXBzUGVyU2hlZXQiLCJlZmZlY3RpdmVQYXBlckNvc3QiLCJwYXBlciIsInByaWNlIiwidG90YWwiLCJjdXRQZXJQYXJlbnQiLCJ1cHNQZXJQYXJlbnQiLCJwYXJlbnRzIiwiY2xpY2tzIiwiZmlsdGVyIiwiQm9vbGVhbiIsImV4Y2VsT2Zmc2V0Q2FsY3VsYXRpb24iLCJjYWxjdWxhdGVXYXN0ZVNoZWV0cyIsIndhc3RlQmFzZSIsIndhc3RlU2hlZXRzIiwiY2FsY3VsYXRlUGxhdGVDb3N0IiwidW5pdFByaWNlIiwicGFwZXJDb3N0IiwicHJlc3MiLCJiZXN0VXBzIiwiRXJyb3IiLCJwcmVzc1NoZWV0cyIsInByZXNzUGVyUGFyZW50IiwicGxhdGVzIiwicGxhdGVzQyIsIm1rcmVhZHkiLCJydW4iLCJjdXRPcHMiLCJjdXR0aW5nIiwidXBzUGVyUHJlc3MiLCJ2YWxpZGF0ZUV4Y2VsRm9ybXVsYXMiLCJjb25zb2xlIiwibG9nIiwiZGlnaXRhbFRlc3QiLCJvZmZzZXRUZXN0IiwiY29uc3RhbnRzVmFsaWRhdGlvbiIsInZhbGlkYXRlUHJpY2luZ0NvbnN0YW50cyIsImlzVmFsaWQiLCJ3YXJuIiwiZXJyb3JzIiwidmFsaWRhdGVDYWxjdWxhdGlvbkFsaWdubWVudCIsImNvZGVSZXN1bHQiLCJleGNlbFJlc3VsdCIsInRvbGVyYW5jZSIsImRpZmZlcmVuY2UiLCJhYnMiLCJpc0FsaWduZWQiLCJkaWdpdGFsUHJpY2luZyIsIm9mZnNldFByaWNpbmciLCJwdXNoIiwibGVuZ3RoIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/excel-calculation.ts\n"));

/***/ })

});