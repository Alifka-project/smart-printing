"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(root)/create-quote/page",{

/***/ "(app-pages-browser)/./lib/excel-calculation.ts":
/*!**********************************!*\
  !*** ./lib/excel-calculation.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXCEL_DIGITAL_CONSTANTS: () => (/* binding */ EXCEL_DIGITAL_CONSTANTS),\n/* harmony export */   EXCEL_OFFSET_CONSTANTS: () => (/* binding */ EXCEL_OFFSET_CONSTANTS),\n/* harmony export */   calculatePerClick: () => (/* binding */ calculatePerClick),\n/* harmony export */   excelDigitalCalculation: () => (/* binding */ excelDigitalCalculation),\n/* harmony export */   excelOffsetCalculation: () => (/* binding */ excelOffsetCalculation),\n/* harmony export */   validateCalculationAlignment: () => (/* binding */ validateCalculationAlignment),\n/* harmony export */   validateExcelFormulas: () => (/* binding */ validateExcelFormulas),\n/* harmony export */   validatePricingConstants: () => (/* binding */ validatePricingConstants)\n/* harmony export */ });\n// Define types locally since types module might not be available\n// === Excel Calculation Constants (from Excel analysis) ===\nconst EXCEL_DIGITAL_CONSTANTS = {\n    parentSheetCost: 1.00,\n    wasteParents: 3 // Fixed waste sheets (from Excel)\n};\n// === Dynamic Per-Click Calculation (Excel Formula) ===\n// Formula: =IF([@Sheets]*[@[Cut pcs]]>200,IF($L$2=4,1.25,0.5),IF($L$2=4,1.5,0.75)) * multiplier\n// Note: $L$2 refers to colors, not sides\n// Multiplier: 1 for cutPcs=4, 2 for cutPcs=3\n// Color categorization: 1-3 colors = 1 color, 4+ colors = 4 colors\nfunction calculatePerClick(sheets, cutPcs, colorsF) {\n    const totalSheets = sheets * cutPcs;\n    // Categorize colors: 1-3 colors = 1 color, 4+ colors = 4 colors\n    const categorizedColors = colorsF <= 3 ? 1 : 4;\n    // Base per-click rate\n    let basePerClick;\n    if (totalSheets > 200) {\n        // High volume: > 200 total sheets\n        basePerClick = categorizedColors === 4 ? 1.25 : 0.5;\n    } else {\n        // Low volume: â‰¤ 200 total sheets  \n        basePerClick = categorizedColors === 4 ? 1.5 : 0.75;\n    }\n    // Apply dynamic multiplier based on cut pieces (original formula)\n    // Multiplier = (4 - cutPcs + 1)\n    const multiplier = 4 - cutPcs + 1;\n    return basePerClick * multiplier;\n}\nconst EXCEL_OFFSET_CONSTANTS = {\n    parentCost: 8.00,\n    plateCost: 120.00,\n    makeReadySetup: 200.00,\n    makeReadySheets: 10,\n    runPer1000: 60.00,\n    cutOpRate: 8.00 // AED per cut operation (from Excel)\n};\n// === Excel Digital Calculation (Exact Excel Formulas) ===\nfunction excelDigitalCalculation(param) {\n    let { qty, piece, sides, colorsF, colorsB, parent = {\n        w: 100,\n        h: 70\n    }, allowRotate = true, paperCostPerSheet// Optional manual paper pricing override\n     } = param;\n    const colors = colorsF + (sides === 2 ? colorsB !== null && colorsB !== void 0 ? colorsB : 0 : 0);\n    // Excel Formula: ROUNDDOWN((Sheet Width) / (height + 1), 0) Ã— ROUNDDOWN((Sheet Height) / (width + 1), 0)\n    const calculateUpsOption1 = (sheetW, sheetH, pieceW, pieceH)=>{\n        const cols = Math.floor(sheetW / (pieceW + 1));\n        const rows = Math.floor(sheetH / (pieceH + 1));\n        return cols * rows;\n    };\n    // Excel Formula: ROUNDDOWN((Sheet Width) / (width + 1), 0) Ã— ROUNDDOWN((Sheet Height) / (height + 1), 0)\n    const calculateUpsOption2 = (sheetW, sheetH, pieceW, pieceH)=>{\n        const cols = Math.floor(sheetW / (pieceH + 1));\n        const rows = Math.floor(sheetH / (pieceW + 1));\n        return cols * rows;\n    };\n    // Excel Formula: IF(Option 1 > Option 2, Option 1, Option 2)\n    const getBestUps = (option1, option2)=>{\n        return Math.max(option1, option2);\n    };\n    // Excel Formula: ROUNDUP(Quantity / ups per sheet + Waste Sheets, 0)\n    const calculateSheets = (quantity, upsPerSheet)=>{\n        if (upsPerSheet === 0) return 0;\n        return Math.ceil(quantity / upsPerSheet + EXCEL_DIGITAL_CONSTANTS.wasteParents);\n    };\n    // Excel Formula: Sheets Ã— Cut pieces Ã— Per click Ã— Sides (price calculation)\n    const calculatePrice = (sheets, cutPieces, colorsF, sides)=>{\n        const perClickRate = calculatePerClick(sheets, cutPieces, colorsF);\n        return sheets * cutPieces * perClickRate * sides;\n    };\n    // Calculate for different sheet sizes (matching Excel options)\n    const sheetOptions = [\n        {\n            w: 48,\n            h: 33,\n            label: \"48Ã—33 cm\",\n            cutPcs: 4\n        },\n        {\n            w: 70,\n            h: 33,\n            label: \"70Ã—33 cm\",\n            cutPcs: 3\n        }\n    ];\n    return sheetOptions.map((option)=>{\n        // Calculate UPS for both orientations\n        const upsOption1 = calculateUpsOption1(option.w, option.h, piece.w, piece.h);\n        const upsOption2 = allowRotate ? calculateUpsOption2(option.w, option.h, piece.w, piece.h) : 0;\n        // Get best UPS per cut piece (Excel formula)\n        const upsPerCutPiece = getBestUps(upsOption1, upsOption2);\n        if (upsPerCutPiece === 0) return null;\n        // Calculate total ups per sheet = cut pieces Ã— ups per cut piece\n        const totalUpsPerSheet = option.cutPcs * upsPerCutPiece;\n        // Calculate sheets needed (Excel formula)\n        const sheets = calculateSheets(qty, totalUpsPerSheet);\n        // Calculate costs (no units calculation for digital)\n        // Use manual paper pricing if provided, otherwise use default constant\n        const effectivePaperCost = paperCostPerSheet !== undefined && paperCostPerSheet !== null ? paperCostPerSheet : EXCEL_DIGITAL_CONSTANTS.parentSheetCost;\n        console.log('ðŸ” excelDigitalCalculation - Paper cost calculation:', {\n            paperCostPerSheet,\n            effectivePaperCost,\n            sheets,\n            paperCost: sheets * effectivePaperCost\n        });\n        const paper = sheets * effectivePaperCost;\n        const price = calculatePrice(sheets, option.cutPcs, colorsF, sides);\n        const total = price + paper;\n        return {\n            option: option.label,\n            cutPerParent: option.cutPcs,\n            upsPerSheet: totalUpsPerSheet,\n            upsPerParent: totalUpsPerSheet,\n            parents: sheets,\n            paper,\n            clicks: price,\n            total\n        };\n    }).filter(Boolean);\n}\n// === Excel Offset Calculation (Exact Excel Formulas) ===\nfunction excelOffsetCalculation(param) {\n    let { qty, piece, sides, colorsF, colorsB, parent = {\n        w: 100,\n        h: 70\n    }, allowRotate = true } = param;\n    const colors = colorsF + (sides === 2 ? colorsB !== null && colorsB !== void 0 ? colorsB : 0 : 0);\n    // Excel Formula: ROUNDDOWN((Sheet Width) / (height + 1), 0) Ã— ROUNDDOWN((Sheet Height) / (width + 1), 0)\n    const calculateUpsOption1 = (sheetW, sheetH, pieceW, pieceH)=>{\n        const cols = Math.floor(sheetW / (pieceW + 1));\n        const rows = Math.floor(sheetH / (pieceH + 1));\n        return cols * rows;\n    };\n    // Excel Formula: ROUNDDOWN((Sheet Width) / (width + 1), 0) Ã— ROUNDDOWN((Sheet Height) / (height + 1), 0)\n    const calculateUpsOption2 = (sheetW, sheetH, pieceW, pieceH)=>{\n        const cols = Math.floor(sheetW / (pieceH + 1));\n        const rows = Math.floor(sheetH / (pieceW + 1));\n        return cols * rows;\n    };\n    // Excel Formula: IF(Option 1 > Option 2, Option 1, Option 2)\n    const getBestUps = (option1, option2)=>{\n        return Math.max(option1, option2);\n    };\n    // Excel Formula: ROUNDUP(IF(Sheet Width > 50, 120/Cut pieces, 100/Cut pieces), 0)\n    const calculateWasteSheets = (sheetW, cutPieces)=>{\n        const wasteBase = sheetW > 50 ? 120 : 100;\n        return Math.ceil(wasteBase / cutPieces);\n    };\n    // Excel Formula: ROUNDUP(Quantity / ups per sheet + Waste Sheets, 0)\n    const calculateSheets = (quantity, upsPerSheet, wasteSheets)=>{\n        if (upsPerSheet === 0) return 0;\n        return Math.ceil(quantity / upsPerSheet + wasteSheets);\n    };\n    // Excel Formula: IF(Sheets = 0, 0, unit price + paper cost + Plate cost Ã— 2)\n    const calculatePlateCost = (sheets, unitPrice, paperCost, plateCost)=>{\n        if (sheets === 0) return 0;\n        return unitPrice + paperCost + plateCost * 2;\n    };\n    // Use standard press size (35Ã—50 cm) for offset calculations\n    const press = {\n        w: 35,\n        h: 50\n    };\n    // Calculate UPS for both orientations\n    const upsOption1 = calculateUpsOption1(press.w, press.h, piece.w, piece.h);\n    const upsOption2 = allowRotate ? calculateUpsOption2(press.w, press.h, piece.w, piece.h) : 0;\n    // Get best UPS (Excel formula)\n    const bestUps = getBestUps(upsOption1, upsOption2);\n    if (bestUps === 0) {\n        throw new Error(\"Press size not cuttable from parent.\");\n    }\n    // Calculate waste sheets (Excel formula)\n    const wasteSheets = calculateWasteSheets(press.w, bestUps);\n    // Calculate sheets needed (Excel formula)\n    const pressSheets = calculateSheets(qty, bestUps, wasteSheets);\n    // Calculate press per parent\n    const pressPerParent = Math.floor(parent.w / press.w) * Math.floor(parent.h / press.h);\n    const parents = Math.ceil(pressSheets / pressPerParent);\n    // Calculate costs\n    const plates = colors;\n    const paper = parents * EXCEL_OFFSET_CONSTANTS.parentCost;\n    const platesC = plates * EXCEL_OFFSET_CONSTANTS.plateCost;\n    const mkready = EXCEL_OFFSET_CONSTANTS.makeReadySetup + EXCEL_OFFSET_CONSTANTS.makeReadySheets * (EXCEL_OFFSET_CONSTANTS.parentCost / pressPerParent);\n    const run = pressSheets * sides * (EXCEL_OFFSET_CONSTANTS.runPer1000 / 1000);\n    // Calculate cutting operations\n    const cols = Math.floor(press.w / (piece.w + 1));\n    const rows = Math.floor(press.h / (piece.h + 1));\n    const cutOps = cols && rows ? 4 + (cols - 1) + cols * (rows - 1) : 0;\n    const cutting = cutOps * EXCEL_OFFSET_CONSTANTS.cutOpRate * pressSheets;\n    const total = paper + platesC + mkready + run + cutting;\n    return {\n        pressPerParent,\n        upsPerPress: bestUps,\n        pressSheets,\n        parents,\n        plates,\n        paper,\n        platesC,\n        mkready,\n        run,\n        cutting,\n        total\n    };\n}\n// === Excel Formula Validation ===\nfunction validateExcelFormulas() {\n    console.log('ðŸ” Validating Excel Formulas...');\n    // Test Digital Calculation\n    const digitalTest = excelDigitalCalculation({\n        qty: 1000,\n        piece: {\n            w: 5.5,\n            h: 9\n        },\n        sides: 2,\n        colorsF: 4\n    });\n    console.log('ðŸ“± Digital Test Results:', digitalTest);\n    // Test Offset Calculation\n    const offsetTest = excelOffsetCalculation({\n        qty: 3000,\n        piece: {\n            w: 21,\n            h: 29\n        },\n        sides: 2,\n        colorsF: 2\n    });\n    console.log('ðŸ–¨ï¸ Offset Test Results:', offsetTest);\n    // Validate constants alignment\n    const constantsValidation = validatePricingConstants(EXCEL_DIGITAL_CONSTANTS, EXCEL_OFFSET_CONSTANTS);\n    if (constantsValidation.isValid) {\n        console.log('âœ… Excel Constants Validation: PASSED');\n    } else {\n        console.warn('âš ï¸ Excel Constants Validation: FAILED', constantsValidation.errors);\n    }\n    return {\n        digitalTest,\n        offsetTest,\n        constantsValidation\n    };\n}\n// === Calculation Alignment Validation ===\nfunction validateCalculationAlignment(codeResult, excelResult) {\n    let tolerance = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.01;\n    const difference = Math.abs(codeResult - excelResult);\n    const isAligned = difference <= tolerance;\n    if (!isAligned) {\n        console.warn(\"âš ï¸ Calculation misalignment detected:\", {\n            codeResult,\n            excelResult,\n            difference,\n            tolerance\n        });\n    }\n    return isAligned;\n}\n// === Pricing Constants Validation ===\nfunction validatePricingConstants(digitalPricing, offsetPricing) {\n    const errors = [];\n    // Validate Digital Pricing (perClick is now calculated dynamically)\n    // Note: perClick validation removed as it's now calculated dynamically\n    if (digitalPricing.parentSheetCost !== EXCEL_DIGITAL_CONSTANTS.parentSheetCost) {\n        errors.push(\"Digital parentSheetCost mismatch: \".concat(digitalPricing.parentSheetCost, \" vs \").concat(EXCEL_DIGITAL_CONSTANTS.parentSheetCost));\n    }\n    if (digitalPricing.wasteParents !== EXCEL_DIGITAL_CONSTANTS.wasteParents) {\n        errors.push(\"Digital wasteParents mismatch: \".concat(digitalPricing.wasteParents, \" vs \").concat(EXCEL_DIGITAL_CONSTANTS.wasteParents));\n    }\n    // Validate Offset Pricing\n    if (offsetPricing.parentCost !== EXCEL_OFFSET_CONSTANTS.parentCost) {\n        errors.push(\"Offset parentCost mismatch: \".concat(offsetPricing.parentCost, \" vs \").concat(EXCEL_OFFSET_CONSTANTS.parentCost));\n    }\n    if (offsetPricing.plateCost !== EXCEL_OFFSET_CONSTANTS.plateCost) {\n        errors.push(\"Offset plateCost mismatch: \".concat(offsetPricing.plateCost, \" vs \").concat(EXCEL_OFFSET_CONSTANTS.plateCost));\n    }\n    if (offsetPricing.makeReadySetup !== EXCEL_OFFSET_CONSTANTS.makeReadySetup) {\n        errors.push(\"Offset makeReadySetup mismatch: \".concat(offsetPricing.makeReadySetup, \" vs \").concat(EXCEL_OFFSET_CONSTANTS.makeReadySetup));\n    }\n    if (offsetPricing.runPer1000 !== EXCEL_OFFSET_CONSTANTS.runPer1000) {\n        errors.push(\"Offset runPer1000 mismatch: \".concat(offsetPricing.runPer1000, \" vs \").concat(EXCEL_OFFSET_CONSTANTS.runPer1000));\n    }\n    if (offsetPricing.cutOpRate !== EXCEL_OFFSET_CONSTANTS.cutOpRate) {\n        errors.push(\"Offset cutOpRate mismatch: \".concat(offsetPricing.cutOpRate, \" vs \").concat(EXCEL_OFFSET_CONSTANTS.cutOpRate));\n    }\n    return {\n        isValid: errors.length === 0,\n        errors\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9leGNlbC1jYWxjdWxhdGlvbi50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLGlFQUFpRTtBQTRCakUsNERBQTREO0FBQ3JELE1BQU1BLDBCQUEwQjtJQUNyQ0MsaUJBQWlCO0lBQ2pCQyxjQUFjLEVBQVMsa0NBQWtDO0FBQzNELEVBQUU7QUFFRix3REFBd0Q7QUFDeEQsZ0dBQWdHO0FBQ2hHLHlDQUF5QztBQUN6Qyw2Q0FBNkM7QUFDN0MsbUVBQW1FO0FBQzVELFNBQVNDLGtCQUFrQkMsTUFBYyxFQUFFQyxNQUFjLEVBQUVDLE9BQWU7SUFDL0UsTUFBTUMsY0FBY0gsU0FBU0M7SUFFN0IsZ0VBQWdFO0lBQ2hFLE1BQU1HLG9CQUFvQkYsV0FBVyxJQUFJLElBQUk7SUFFN0Msc0JBQXNCO0lBQ3RCLElBQUlHO0lBQ0osSUFBSUYsY0FBYyxLQUFLO1FBQ3JCLGtDQUFrQztRQUNsQ0UsZUFBZUQsc0JBQXNCLElBQUksT0FBTztJQUNsRCxPQUFPO1FBQ0wsbUNBQW1DO1FBQ25DQyxlQUFlRCxzQkFBc0IsSUFBSSxNQUFNO0lBQ2pEO0lBRUEsa0VBQWtFO0lBQ2xFLGdDQUFnQztJQUNoQyxNQUFNRSxhQUFhLElBQUlMLFNBQVM7SUFFaEMsT0FBT0ksZUFBZUM7QUFDeEI7QUFFTyxNQUFNQyx5QkFBeUI7SUFDcENDLFlBQVk7SUFDWkMsV0FBVztJQUNYQyxnQkFBZ0I7SUFDaEJDLGlCQUFpQjtJQUNqQkMsWUFBWTtJQUNaQyxXQUFXLEtBQVkscUNBQXFDO0FBQzlELEVBQUU7QUFFRiwyREFBMkQ7QUFDcEQsU0FBU0Msd0JBQXdCLEtBa0J2QztRQWxCdUMsRUFDdENDLEdBQUcsRUFDSEMsS0FBSyxFQUNMQyxLQUFLLEVBQ0xmLE9BQU8sRUFDUGdCLE9BQU8sRUFDUEMsU0FBUztRQUFFQyxHQUFHO1FBQUtDLEdBQUc7SUFBRyxDQUFDLEVBQzFCQyxjQUFjLElBQUksRUFDbEJDLGlCQUFpQix5Q0FBMEM7TUFVNUQsR0Fs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O0lBRUEsMEJBQTBCO0lBQzFCLElBQUl3RyxjQUFjOUYsVUFBVSxLQUFLRCx1QkFBdUJDLFVBQVUsRUFBRTtRQUNsRXFGLE9BQU9VLElBQUksQ0FBQywrQkFBOERoRyxPQUEvQitGLGNBQWM5RixVQUFVLEVBQUMsUUFBd0MsT0FBbENELHVCQUF1QkMsVUFBVTtJQUM3RztJQUNBLElBQUk4RixjQUFjN0YsU0FBUyxLQUFLRix1QkFBdUJFLFNBQVMsRUFBRTtRQUNoRW9GLE9BQU9VLElBQUksQ0FBQyw4QkFBNERoRyxPQUE5QitGLGNBQWM3RixTQUFTLEVBQUMsUUFBdUMsT0FBakNGLHVCQUF1QkUsU0FBUztJQUMxRztJQUNBLElBQUk2RixjQUFjNUYsY0FBYyxLQUFLSCx1QkFBdUJHLGNBQWMsRUFBRTtRQUMxRW1GLE9BQU9VLElBQUksQ0FBQyxtQ0FBc0VoRyxPQUFuQytGLGNBQWM1RixjQUFjLEVBQUMsUUFBNEMsT0FBdENILHVCQUF1QkcsY0FBYztJQUN6SDtJQUNBLElBQUk0RixjQUFjMUYsVUFBVSxLQUFLTCx1QkFBdUJLLFVBQVUsRUFBRTtRQUNsRWlGLE9BQU9VLElBQUksQ0FBQywrQkFBOERoRyxPQUEvQitGLGNBQWMxRixVQUFVLEVBQUMsUUFBd0MsT0FBbENMLHVCQUF1QkssVUFBVTtJQUM3RztJQUNBLElBQUkwRixjQUFjekYsU0FBUyxLQUFLTix1QkFBdUJNLFNBQVMsRUFBRTtRQUNoRWdGLE9BQU9VLElBQUksQ0FBQyw4QkFBNERoRyxPQUE5QitGLGNBQWN6RixTQUFTLEVBQUMsUUFBdUMsT0FBakNOLHVCQUF1Qk0sU0FBUztJQUMxRztJQUVBLE9BQU87UUFDTDhFLFNBQVNFLE9BQU9XLE1BQU0sS0FBSztRQUMzQlg7SUFDRjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvQWxpZmthX1Jvb3NzZW8vRGVza3RvcC9Qcm9qZWN0L1NtYXJ0LXByaW50aW5nLXVwZGF0ZS9saWIvZXhjZWwtY2FsY3VsYXRpb24udHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRGVmaW5lIHR5cGVzIGxvY2FsbHkgc2luY2UgdHlwZXMgbW9kdWxlIG1pZ2h0IG5vdCBiZSBhdmFpbGFibGVcbnR5cGUgQ20gPSBudW1iZXI7XG5cbmludGVyZmFjZSBEaWdpdGFsQ29zdGluZ1Jlc3VsdCB7XG4gIG9wdGlvbjogc3RyaW5nO1xuICBjdXRQZXJQYXJlbnQ6IG51bWJlcjtcbiAgdXBzUGVyU2hlZXQ6IG51bWJlcjtcbiAgdXBzUGVyUGFyZW50OiBudW1iZXI7XG4gIHBhcmVudHM6IG51bWJlcjtcbiAgcGFwZXI6IG51bWJlcjtcbiAgY2xpY2tzOiBudW1iZXI7XG4gIHRvdGFsOiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBPZmZzZXRDb3N0aW5nUmVzdWx0IHtcbiAgcHJlc3NQZXJQYXJlbnQ6IG51bWJlcjtcbiAgdXBzUGVyUHJlc3M6IG51bWJlcjtcbiAgcHJlc3NTaGVldHM6IG51bWJlcjtcbiAgcGFyZW50czogbnVtYmVyO1xuICBwbGF0ZXM6IG51bWJlcjtcbiAgcGFwZXI6IG51bWJlcjtcbiAgcGxhdGVzQzogbnVtYmVyO1xuICBta3JlYWR5OiBudW1iZXI7XG4gIHJ1bjogbnVtYmVyO1xuICBjdXR0aW5nOiBudW1iZXI7XG4gIHRvdGFsOiBudW1iZXI7XG59XG5cbi8vID09PSBFeGNlbCBDYWxjdWxhdGlvbiBDb25zdGFudHMgKGZyb20gRXhjZWwgYW5hbHlzaXMpID09PVxuZXhwb3J0IGNvbnN0IEVYQ0VMX0RJR0lUQUxfQ09OU1RBTlRTID0ge1xuICBwYXJlbnRTaGVldENvc3Q6IDEuMDAsIC8vIEFFRCBwZXIgcGFyZW50IHNoZWV0IChmcm9tIHVzZXIgZXhhbXBsZSlcbiAgd2FzdGVQYXJlbnRzOiAzICAgICAgICAvLyBGaXhlZCB3YXN0ZSBzaGVldHMgKGZyb20gRXhjZWwpXG59O1xuXG4vLyA9PT0gRHluYW1pYyBQZXItQ2xpY2sgQ2FsY3VsYXRpb24gKEV4Y2VsIEZvcm11bGEpID09PVxuLy8gRm9ybXVsYTogPUlGKFtAU2hlZXRzXSpbQFtDdXQgcGNzXV0+MjAwLElGKCRMJDI9NCwxLjI1LDAuNSksSUYoJEwkMj00LDEuNSwwLjc1KSkgKiBtdWx0aXBsaWVyXG4vLyBOb3RlOiAkTCQyIHJlZmVycyB0byBjb2xvcnMsIG5vdCBzaWRlc1xuLy8gTXVsdGlwbGllcjogMSBmb3IgY3V0UGNzPTQsIDIgZm9yIGN1dFBjcz0zXG4vLyBDb2xvciBjYXRlZ29yaXphdGlvbjogMS0zIGNvbG9ycyA9IDEgY29sb3IsIDQrIGNvbG9ycyA9IDQgY29sb3JzXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlUGVyQ2xpY2soc2hlZXRzOiBudW1iZXIsIGN1dFBjczogbnVtYmVyLCBjb2xvcnNGOiBudW1iZXIpOiBudW1iZXIge1xuICBjb25zdCB0b3RhbFNoZWV0cyA9IHNoZWV0cyAqIGN1dFBjcztcbiAgXG4gIC8vIENhdGVnb3JpemUgY29sb3JzOiAxLTMgY29sb3JzID0gMSBjb2xvciwgNCsgY29sb3JzID0gNCBjb2xvcnNcbiAgY29uc3QgY2F0ZWdvcml6ZWRDb2xvcnMgPSBjb2xvcnNGIDw9IDMgPyAxIDogNDtcbiAgXG4gIC8vIEJhc2UgcGVyLWNsaWNrIHJhdGVcbiAgbGV0IGJhc2VQZXJDbGljazogbnVtYmVyO1xuICBpZiAodG90YWxTaGVldHMgPiAyMDApIHtcbiAgICAvLyBIaWdoIHZvbHVtZTogPiAyMDAgdG90YWwgc2hlZXRzXG4gICAgYmFzZVBlckNsaWNrID0gY2F0ZWdvcml6ZWRDb2xvcnMgPT09IDQgPyAxLjI1IDogMC41O1xuICB9IGVsc2Uge1xuICAgIC8vIExvdyB2b2x1bWU6IOKJpCAyMDAgdG90YWwgc2hlZXRzICBcbiAgICBiYXNlUGVyQ2xpY2sgPSBjYXRlZ29yaXplZENvbG9ycyA9PT0gNCA/IDEuNSA6IDAuNzU7XG4gIH1cbiAgXG4gIC8vIEFwcGx5IGR5bmFtaWMgbXVsdGlwbGllciBiYXNlZCBvbiBjdXQgcGllY2VzIChvcmlnaW5hbCBmb3JtdWxhKVxuICAvLyBNdWx0aXBsaWVyID0gKDQgLSBjdXRQY3MgKyAxKVxuICBjb25zdCBtdWx0aXBsaWVyID0gNCAtIGN1dFBjcyArIDE7XG4gIFxuICByZXR1cm4gYmFzZVBlckNsaWNrICogbXVsdGlwbGllcjtcbn1cblxuZXhwb3J0IGNvbnN0IEVYQ0VMX09GRlNFVF9DT05TVEFOVFMgPSB7XG4gIHBhcmVudENvc3Q6IDguMDAsICAgICAgLy8gQUVEIHBlciBwYXJlbnQgc2hlZXQgKGZyb20gRXhjZWwpXG4gIHBsYXRlQ29zdDogMTIwLjAwLCAgICAgLy8gQUVEIHBlciBwbGF0ZSAoZnJvbSBFeGNlbClcbiAgbWFrZVJlYWR5U2V0dXA6IDIwMC4wMCwgLy8gQUVEIHNldHVwIGNvc3QgKGZyb20gRXhjZWwpXG4gIG1ha2VSZWFkeVNoZWV0czogMTAsICAgLy8gTnVtYmVyIG9mIG1ha2UtcmVhZHkgc2hlZXRzIChmcm9tIEV4Y2VsKVxuICBydW5QZXIxMDAwOiA2MC4wMCwgICAgIC8vIEFFRCBwZXIgMTAwMCBpbXByZXNzaW9ucyAoZnJvbSBFeGNlbClcbiAgY3V0T3BSYXRlOiA4LjAwICAgICAgICAvLyBBRUQgcGVyIGN1dCBvcGVyYXRpb24gKGZyb20gRXhjZWwpXG59O1xuXG4vLyA9PT0gRXhjZWwgRGlnaXRhbCBDYWxjdWxhdGlvbiAoRXhhY3QgRXhjZWwgRm9ybXVsYXMpID09PVxuZXhwb3J0IGZ1bmN0aW9uIGV4Y2VsRGlnaXRhbENhbGN1bGF0aW9uKHtcbiAgcXR5LFxuICBwaWVjZSxcbiAgc2lkZXMsXG4gIGNvbG9yc0YsXG4gIGNvbG9yc0IsXG4gIHBhcmVudCA9IHsgdzogMTAwLCBoOiA3MCB9LCAvLyBEZWZhdWx0IHBhcmVudCBzaGVldCBzaXplXG4gIGFsbG93Um90YXRlID0gdHJ1ZSxcbiAgcGFwZXJDb3N0UGVyU2hlZXQgLy8gT3B0aW9uYWwgbWFudWFsIHBhcGVyIHByaWNpbmcgb3ZlcnJpZGVcbn06IHtcbiAgcXR5OiBudW1iZXI7XG4gIHBpZWNlOiB7IHc6IENtOyBoOiBDbSB9O1xuICBzaWRlczogMSB8IDI7XG4gIGNvbG9yc0Y6IDEgfCAyIHwgNDtcbiAgY29sb3JzQj86IDEgfCAyIHwgNDtcbiAgcGFyZW50PzogeyB3OiBDbTsgaDogQ20gfTtcbiAgYWxsb3dSb3RhdGU/OiBib29sZWFuO1xuICBwYXBlckNvc3RQZXJTaGVldD86IG51bWJlcjsgLy8gTWFudWFsIHBhcGVyIHByaWNpbmcgb3ZlcnJpZGVcbn0pOiBEaWdpdGFsQ29zdGluZ1Jlc3VsdFtdIHtcbiAgXG4gIGNvbnN0IGNvbG9ycyA9IGNvbG9yc0YgKyAoc2lkZXMgPT09IDIgPyAoY29sb3JzQiA/PyAwKSA6IDApO1xuICBcbiAgLy8gRXhjZWwgRm9ybXVsYTogUk9VTkRET1dOKChTaGVldCBXaWR0aCkgLyAoaGVpZ2h0ICsgMSksIDApIMOXIFJPVU5ERE9XTigoU2hlZXQgSGVpZ2h0KSAvICh3aWR0aCArIDEpLCAwKVxuICBjb25zdCBjYWxjdWxhdGVVcHNPcHRpb24xID0gKHNoZWV0VzogbnVtYmVyLCBzaGVldEg6IG51bWJlciwgcGllY2VXOiBudW1iZXIsIHBpZWNlSDogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgY29scyA9IE1hdGguZmxvb3Ioc2hlZXRXIC8gKHBpZWNlVyArIDEpKTtcbiAgICBjb25zdCByb3dzID0gTWF0aC5mbG9vcihzaGVldEggLyAocGllY2VIICsgMSkpO1xuICAgIHJldHVybiBjb2xzICogcm93cztcbiAgfTtcblxuICAvLyBFeGNlbCBGb3JtdWxhOiBST1VORERPV04oKFNoZWV0IFdpZHRoKSAvICh3aWR0aCArIDEpLCAwKSDDlyBST1VORERPV04oKFNoZWV0IEhlaWdodCkgLyAoaGVpZ2h0ICsgMSksIDApXG4gIGNvbnN0IGNhbGN1bGF0ZVVwc09wdGlvbjIgPSAoc2hlZXRXOiBudW1iZXIsIHNoZWV0SDogbnVtYmVyLCBwaWVjZVc6IG51bWJlciwgcGllY2VIOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCBjb2xzID0gTWF0aC5mbG9vcihzaGVldFcgLyAocGllY2VIICsgMSkpO1xuICAgIGNvbnN0IHJvd3MgPSBNYXRoLmZsb29yKHNoZWV0SCAvIChwaWVjZVcgKyAxKSk7XG4gICAgcmV0dXJuIGNvbHMgKiByb3dzO1xuICB9O1xuXG4gIC8vIEV4Y2VsIEZvcm11bGE6IElGKE9wdGlvbiAxID4gT3B0aW9uIDIsIE9wdGlvbiAxLCBPcHRpb24gMilcbiAgY29uc3QgZ2V0QmVzdFVwcyA9IChvcHRpb24xOiBudW1iZXIsIG9wdGlvbjI6IG51bWJlcikgPT4ge1xuICAgIHJldHVybiBNYXRoLm1heChvcHRpb24xLCBvcHRpb24yKTtcbiAgfTtcblxuICAvLyBFeGNlbCBGb3JtdWxhOiBST1VORFVQKFF1YW50aXR5IC8gdXBzIHBlciBzaGVldCArIFdhc3RlIFNoZWV0cywgMClcbiAgY29uc3QgY2FsY3VsYXRlU2hlZXRzID0gKHF1YW50aXR5OiBudW1iZXIsIHVwc1BlclNoZWV0OiBudW1iZXIpID0+IHtcbiAgICBpZiAodXBzUGVyU2hlZXQgPT09IDApIHJldHVybiAwO1xuICAgIHJldHVybiBNYXRoLmNlaWwocXVhbnRpdHkgLyB1cHNQZXJTaGVldCArIEVYQ0VMX0RJR0lUQUxfQ09OU1RBTlRTLndhc3RlUGFyZW50cyk7XG4gIH07XG5cbiAgLy8gRXhjZWwgRm9ybXVsYTogU2hlZXRzIMOXIEN1dCBwaWVjZXMgw5cgUGVyIGNsaWNrIMOXIFNpZGVzIChwcmljZSBjYWxjdWxhdGlvbilcbiAgY29uc3QgY2FsY3VsYXRlUHJpY2UgPSAoc2hlZXRzOiBudW1iZXIsIGN1dFBpZWNlczogbnVtYmVyLCBjb2xvcnNGOiBudW1iZXIsIHNpZGVzOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCBwZXJDbGlja1JhdGUgPSBjYWxjdWxhdGVQZXJDbGljayhzaGVldHMsIGN1dFBpZWNlcywgY29sb3JzRik7XG4gICAgcmV0dXJuIHNoZWV0cyAqIGN1dFBpZWNlcyAqIHBlckNsaWNrUmF0ZSAqIHNpZGVzO1xuICB9O1xuXG4gIC8vIENhbGN1bGF0ZSBmb3IgZGlmZmVyZW50IHNoZWV0IHNpemVzIChtYXRjaGluZyBFeGNlbCBvcHRpb25zKVxuICBjb25zdCBzaGVldE9wdGlvbnMgPSBbXG4gICAgeyB3OiA0OCwgaDogMzMsIGxhYmVsOiBcIjQ4w5czMyBjbVwiLCBjdXRQY3M6IDQgfSxcbiAgICB7IHc6IDcwLCBoOiAzMywgbGFiZWw6IFwiNzDDlzMzIGNtXCIsIGN1dFBjczogMyB9XG4gIF07XG5cbiAgcmV0dXJuIHNoZWV0T3B0aW9ucy5tYXAob3B0aW9uID0+IHtcbiAgICAvLyBDYWxjdWxhdGUgVVBTIGZvciBib3RoIG9yaWVudGF0aW9uc1xuICAgIGNvbnN0IHVwc09wdGlvbjEgPSBjYWxjdWxhdGVVcHNPcHRpb24xKG9wdGlvbi53LCBvcHRpb24uaCwgcGllY2UudywgcGllY2UuaCk7XG4gICAgY29uc3QgdXBzT3B0aW9uMiA9IGFsbG93Um90YXRlID8gY2FsY3VsYXRlVXBzT3B0aW9uMihvcHRpb24udywgb3B0aW9uLmgsIHBpZWNlLncsIHBpZWNlLmgpIDogMDtcbiAgICBcbiAgICAvLyBHZXQgYmVzdCBVUFMgcGVyIGN1dCBwaWVjZSAoRXhjZWwgZm9ybXVsYSlcbiAgICBjb25zdCB1cHNQZXJDdXRQaWVjZSA9IGdldEJlc3RVcHModXBzT3B0aW9uMSwgdXBzT3B0aW9uMik7XG4gICAgXG4gICAgaWYgKHVwc1BlckN1dFBpZWNlID09PSAwKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIENhbGN1bGF0ZSB0b3RhbCB1cHMgcGVyIHNoZWV0ID0gY3V0IHBpZWNlcyDDlyB1cHMgcGVyIGN1dCBwaWVjZVxuICAgIGNvbnN0IHRvdGFsVXBzUGVyU2hlZXQgPSBvcHRpb24uY3V0UGNzICogdXBzUGVyQ3V0UGllY2U7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIHNoZWV0cyBuZWVkZWQgKEV4Y2VsIGZvcm11bGEpXG4gICAgY29uc3Qgc2hlZXRzID0gY2FsY3VsYXRlU2hlZXRzKHF0eSwgdG90YWxVcHNQZXJTaGVldCk7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIGNvc3RzIChubyB1bml0cyBjYWxjdWxhdGlvbiBmb3IgZGlnaXRhbClcbiAgICAvLyBVc2UgbWFudWFsIHBhcGVyIHByaWNpbmcgaWYgcHJvdmlkZWQsIG90aGVyd2lzZSB1c2UgZGVmYXVsdCBjb25zdGFudFxuICAgIGNvbnN0IGVmZmVjdGl2ZVBhcGVyQ29zdCA9IHBhcGVyQ29zdFBlclNoZWV0ICE9PSB1bmRlZmluZWQgJiYgcGFwZXJDb3N0UGVyU2hlZXQgIT09IG51bGwgXG4gICAgICA/IHBhcGVyQ29zdFBlclNoZWV0IFxuICAgICAgOiBFWENFTF9ESUdJVEFMX0NPTlNUQU5UUy5wYXJlbnRTaGVldENvc3Q7XG4gICAgXG4gICAgY29uc29sZS5sb2coJ/CflI0gZXhjZWxEaWdpdGFsQ2FsY3VsYXRpb24gLSBQYXBlciBjb3N0IGNhbGN1bGF0aW9uOicsIHtcbiAgICAgIHBhcGVyQ29zdFBlclNoZWV0LFxuICAgICAgZWZmZWN0aXZlUGFwZXJDb3N0LFxuICAgICAgc2hlZXRzLFxuICAgICAgcGFwZXJDb3N0OiBzaGVldHMgKiBlZmZlY3RpdmVQYXBlckNvc3RcbiAgICB9KTtcbiAgICBcbiAgICBjb25zdCBwYXBlciA9IHNoZWV0cyAqIGVmZmVjdGl2ZVBhcGVyQ29zdDtcbiAgICBjb25zdCBwcmljZSA9IGNhbGN1bGF0ZVByaWNlKHNoZWV0cywgb3B0aW9uLmN1dFBjcywgY29sb3JzRiwgc2lkZXMpO1xuICAgIGNvbnN0IHRvdGFsID0gcHJpY2UgKyBwYXBlcjtcblxuICAgIHJldHVybiB7XG4gICAgICBvcHRpb246IG9wdGlvbi5sYWJlbCxcbiAgICAgIGN1dFBlclBhcmVudDogb3B0aW9uLmN1dFBjcyxcbiAgICAgIHVwc1BlclNoZWV0OiB0b3RhbFVwc1BlclNoZWV0LFxuICAgICAgdXBzUGVyUGFyZW50OiB0b3RhbFVwc1BlclNoZWV0LFxuICAgICAgcGFyZW50czogc2hlZXRzLFxuICAgICAgcGFwZXIsXG4gICAgICBjbGlja3M6IHByaWNlLCAvLyBQcmljZSBpbmNsdWRlcyBjbGljayBjb3N0XG4gICAgICB0b3RhbFxuICAgIH07XG4gIH0pLmZpbHRlcihCb29sZWFuKSBhcyBEaWdpdGFsQ29zdGluZ1Jlc3VsdFtdO1xufVxuXG4vLyA9PT0gRXhjZWwgT2Zmc2V0IENhbGN1bGF0aW9uIChFeGFjdCBFeGNlbCBGb3JtdWxhcykgPT09XG5leHBvcnQgZnVuY3Rpb24gZXhjZWxPZmZzZXRDYWxjdWxhdGlvbih7XG4gIHF0eSxcbiAgcGllY2UsXG4gIHNpZGVzLFxuICBjb2xvcnNGLFxuICBjb2xvcnNCLFxuICBwYXJlbnQgPSB7IHc6IDEwMCwgaDogNzAgfSwgLy8gRGVmYXVsdCBwYXJlbnQgc2hlZXQgc2l6ZVxuICBhbGxvd1JvdGF0ZSA9IHRydWVcbn06IHtcbiAgcXR5OiBudW1iZXI7XG4gIHBpZWNlOiB7IHc6IENtOyBoOiBDbSB9O1xuICBzaWRlczogMSB8IDI7XG4gIGNvbG9yc0Y6IDEgfCAyIHwgNDtcbiAgY29sb3JzQj86IDEgfCAyIHwgNDtcbiAgcGFyZW50PzogeyB3OiBDbTsgaDogQ20gfTtcbiAgYWxsb3dSb3RhdGU/OiBib29sZWFuO1xufSk6IE9mZnNldENvc3RpbmdSZXN1bHQge1xuICBcbiAgY29uc3QgY29sb3JzID0gY29sb3JzRiArIChzaWRlcyA9PT0gMiA/IChjb2xvcnNCID8/IDApIDogMCk7XG4gIFxuICAvLyBFeGNlbCBGb3JtdWxhOiBST1VORERPV04oKFNoZWV0IFdpZHRoKSAvIChoZWlnaHQgKyAxKSwgMCkgw5cgUk9VTkRET1dOKChTaGVldCBIZWlnaHQpIC8gKHdpZHRoICsgMSksIDApXG4gIGNvbnN0IGNhbGN1bGF0ZVVwc09wdGlvbjEgPSAoc2hlZXRXOiBudW1iZXIsIHNoZWV0SDogbnVtYmVyLCBwaWVjZVc6IG51bWJlciwgcGllY2VIOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCBjb2xzID0gTWF0aC5mbG9vcihzaGVldFcgLyAocGllY2VXICsgMSkpO1xuICAgIGNvbnN0IHJvd3MgPSBNYXRoLmZsb29yKHNoZWV0SCAvIChwaWVjZUggKyAxKSk7XG4gICAgcmV0dXJuIGNvbHMgKiByb3dzO1xuICB9O1xuXG4gIC8vIEV4Y2VsIEZvcm11bGE6IFJPVU5ERE9XTigoU2hlZXQgV2lkdGgpIC8gKHdpZHRoICsgMSksIDApIMOXIFJPVU5ERE9XTigoU2hlZXQgSGVpZ2h0KSAvIChoZWlnaHQgKyAxKSwgMClcbiAgY29uc3QgY2FsY3VsYXRlVXBzT3B0aW9uMiA9IChzaGVldFc6IG51bWJlciwgc2hlZXRIOiBudW1iZXIsIHBpZWNlVzogbnVtYmVyLCBwaWVjZUg6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IGNvbHMgPSBNYXRoLmZsb29yKHNoZWV0VyAvIChwaWVjZUggKyAxKSk7XG4gICAgY29uc3Qgcm93cyA9IE1hdGguZmxvb3Ioc2hlZXRIIC8gKHBpZWNlVyArIDEpKTtcbiAgICByZXR1cm4gY29scyAqIHJvd3M7XG4gIH07XG5cbiAgLy8gRXhjZWwgRm9ybXVsYTogSUYoT3B0aW9uIDEgPiBPcHRpb24gMiwgT3B0aW9uIDEsIE9wdGlvbiAyKVxuICBjb25zdCBnZXRCZXN0VXBzID0gKG9wdGlvbjE6IG51bWJlciwgb3B0aW9uMjogbnVtYmVyKSA9PiB7XG4gICAgcmV0dXJuIE1hdGgubWF4KG9wdGlvbjEsIG9wdGlvbjIpO1xuICB9O1xuXG4gIC8vIEV4Y2VsIEZvcm11bGE6IFJPVU5EVVAoSUYoU2hlZXQgV2lkdGggPiA1MCwgMTIwL0N1dCBwaWVjZXMsIDEwMC9DdXQgcGllY2VzKSwgMClcbiAgY29uc3QgY2FsY3VsYXRlV2FzdGVTaGVldHMgPSAoc2hlZXRXOiBudW1iZXIsIGN1dFBpZWNlczogbnVtYmVyKSA9PiB7XG4gICAgY29uc3Qgd2FzdGVCYXNlID0gc2hlZXRXID4gNTAgPyAxMjAgOiAxMDA7XG4gICAgcmV0dXJuIE1hdGguY2VpbCh3YXN0ZUJhc2UgLyBjdXRQaWVjZXMpO1xuICB9O1xuXG4gIC8vIEV4Y2VsIEZvcm11bGE6IFJPVU5EVVAoUXVhbnRpdHkgLyB1cHMgcGVyIHNoZWV0ICsgV2FzdGUgU2hlZXRzLCAwKVxuICBjb25zdCBjYWxjdWxhdGVTaGVldHMgPSAocXVhbnRpdHk6IG51bWJlciwgdXBzUGVyU2hlZXQ6IG51bWJlciwgd2FzdGVTaGVldHM6IG51bWJlcikgPT4ge1xuICAgIGlmICh1cHNQZXJTaGVldCA9PT0gMCkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIE1hdGguY2VpbChxdWFudGl0eSAvIHVwc1BlclNoZWV0ICsgd2FzdGVTaGVldHMpO1xuICB9O1xuXG4gIC8vIEV4Y2VsIEZvcm11bGE6IElGKFNoZWV0cyA9IDAsIDAsIHVuaXQgcHJpY2UgKyBwYXBlciBjb3N0ICsgUGxhdGUgY29zdCDDlyAyKVxuICBjb25zdCBjYWxjdWxhdGVQbGF0ZUNvc3QgPSAoc2hlZXRzOiBudW1iZXIsIHVuaXRQcmljZTogbnVtYmVyLCBwYXBlckNvc3Q6IG51bWJlciwgcGxhdGVDb3N0OiBudW1iZXIpID0+IHtcbiAgICBpZiAoc2hlZXRzID09PSAwKSByZXR1cm4gMDtcbiAgICByZXR1cm4gdW5pdFByaWNlICsgcGFwZXJDb3N0ICsgKHBsYXRlQ29zdCAqIDIpO1xuICB9O1xuXG4gIC8vIFVzZSBzdGFuZGFyZCBwcmVzcyBzaXplICgzNcOXNTAgY20pIGZvciBvZmZzZXQgY2FsY3VsYXRpb25zXG4gIGNvbnN0IHByZXNzID0geyB3OiAzNSwgaDogNTAgfTtcbiAgXG4gIC8vIENhbGN1bGF0ZSBVUFMgZm9yIGJvdGggb3JpZW50YXRpb25zXG4gIGNvbnN0IHVwc09wdGlvbjEgPSBjYWxjdWxhdGVVcHNPcHRpb24xKHByZXNzLncsIHByZXNzLmgsIHBpZWNlLncsIHBpZWNlLmgpO1xuICBjb25zdCB1cHNPcHRpb24yID0gYWxsb3dSb3RhdGUgPyBjYWxjdWxhdGVVcHNPcHRpb24yKHByZXNzLncsIHByZXNzLmgsIHBpZWNlLncsIHBpZWNlLmgpIDogMDtcbiAgXG4gIC8vIEdldCBiZXN0IFVQUyAoRXhjZWwgZm9ybXVsYSlcbiAgY29uc3QgYmVzdFVwcyA9IGdldEJlc3RVcHModXBzT3B0aW9uMSwgdXBzT3B0aW9uMik7XG4gIFxuICBpZiAoYmVzdFVwcyA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlByZXNzIHNpemUgbm90IGN1dHRhYmxlIGZyb20gcGFyZW50LlwiKTtcbiAgfVxuXG4gIC8vIENhbGN1bGF0ZSB3YXN0ZSBzaGVldHMgKEV4Y2VsIGZvcm11bGEpXG4gIGNvbnN0IHdhc3RlU2hlZXRzID0gY2FsY3VsYXRlV2FzdGVTaGVldHMocHJlc3MudywgYmVzdFVwcyk7XG4gIFxuICAvLyBDYWxjdWxhdGUgc2hlZXRzIG5lZWRlZCAoRXhjZWwgZm9ybXVsYSlcbiAgY29uc3QgcHJlc3NTaGVldHMgPSBjYWxjdWxhdGVTaGVldHMocXR5LCBiZXN0VXBzLCB3YXN0ZVNoZWV0cyk7XG4gIFxuICAvLyBDYWxjdWxhdGUgcHJlc3MgcGVyIHBhcmVudFxuICBjb25zdCBwcmVzc1BlclBhcmVudCA9IE1hdGguZmxvb3IocGFyZW50LncgLyBwcmVzcy53KSAqIE1hdGguZmxvb3IocGFyZW50LmggLyBwcmVzcy5oKTtcbiAgY29uc3QgcGFyZW50cyA9IE1hdGguY2VpbChwcmVzc1NoZWV0cyAvIHByZXNzUGVyUGFyZW50KTtcblxuICAvLyBDYWxjdWxhdGUgY29zdHNcbiAgY29uc3QgcGxhdGVzID0gY29sb3JzO1xuICBjb25zdCBwYXBlciA9IHBhcmVudHMgKiBFWENFTF9PRkZTRVRfQ09OU1RBTlRTLnBhcmVudENvc3Q7XG4gIGNvbnN0IHBsYXRlc0MgPSBwbGF0ZXMgKiBFWENFTF9PRkZTRVRfQ09OU1RBTlRTLnBsYXRlQ29zdDtcbiAgY29uc3QgbWtyZWFkeSA9IEVYQ0VMX09GRlNFVF9DT05TVEFOVFMubWFrZVJlYWR5U2V0dXAgKyAoRVhDRUxfT0ZGU0VUX0NPTlNUQU5UUy5tYWtlUmVhZHlTaGVldHMgKiAoRVhDRUxfT0ZGU0VUX0NPTlNUQU5UUy5wYXJlbnRDb3N0IC8gcHJlc3NQZXJQYXJlbnQpKTtcbiAgY29uc3QgcnVuID0gKHByZXNzU2hlZXRzICogc2lkZXMpICogKEVYQ0VMX09GRlNFVF9DT05TVEFOVFMucnVuUGVyMTAwMCAvIDEwMDApO1xuICBcbiAgLy8gQ2FsY3VsYXRlIGN1dHRpbmcgb3BlcmF0aW9uc1xuICBjb25zdCBjb2xzID0gTWF0aC5mbG9vcihwcmVzcy53IC8gKHBpZWNlLncgKyAxKSk7XG4gIGNvbnN0IHJvd3MgPSBNYXRoLmZsb29yKHByZXNzLmggLyAocGllY2UuaCArIDEpKTtcbiAgY29uc3QgY3V0T3BzID0gKGNvbHMgJiYgcm93cykgPyA0ICsgKGNvbHMgLSAxKSArIGNvbHMgKiAocm93cyAtIDEpIDogMDtcbiAgY29uc3QgY3V0dGluZyA9IGN1dE9wcyAqIEVYQ0VMX09GRlNFVF9DT05TVEFOVFMuY3V0T3BSYXRlICogcHJlc3NTaGVldHM7XG4gIFxuICBjb25zdCB0b3RhbCA9IHBhcGVyICsgcGxhdGVzQyArIG1rcmVhZHkgKyBydW4gKyBjdXR0aW5nO1xuXG4gIHJldHVybiB7XG4gICAgcHJlc3NQZXJQYXJlbnQsXG4gICAgdXBzUGVyUHJlc3M6IGJlc3RVcHMsXG4gICAgcHJlc3NTaGVldHMsXG4gICAgcGFyZW50cyxcbiAgICBwbGF0ZXMsXG4gICAgcGFwZXIsXG4gICAgcGxhdGVzQyxcbiAgICBta3JlYWR5LFxuICAgIHJ1bixcbiAgICBjdXR0aW5nLFxuICAgIHRvdGFsXG4gIH07XG59XG5cbi8vID09PSBFeGNlbCBGb3JtdWxhIFZhbGlkYXRpb24gPT09XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVFeGNlbEZvcm11bGFzKCkge1xuICBjb25zb2xlLmxvZygn8J+UjSBWYWxpZGF0aW5nIEV4Y2VsIEZvcm11bGFzLi4uJyk7XG4gIFxuICAvLyBUZXN0IERpZ2l0YWwgQ2FsY3VsYXRpb25cbiAgY29uc3QgZGlnaXRhbFRlc3QgPSBleGNlbERpZ2l0YWxDYWxjdWxhdGlvbih7XG4gICAgcXR5OiAxMDAwLFxuICAgIHBpZWNlOiB7IHc6IDUuNSwgaDogOSB9LFxuICAgIHNpZGVzOiAyLFxuICAgIGNvbG9yc0Y6IDRcbiAgfSk7XG4gIFxuICBjb25zb2xlLmxvZygn8J+TsSBEaWdpdGFsIFRlc3QgUmVzdWx0czonLCBkaWdpdGFsVGVzdCk7XG4gIFxuICAvLyBUZXN0IE9mZnNldCBDYWxjdWxhdGlvblxuICBjb25zdCBvZmZzZXRUZXN0ID0gZXhjZWxPZmZzZXRDYWxjdWxhdGlvbih7XG4gICAgcXR5OiAzMDAwLFxuICAgIHBpZWNlOiB7IHc6IDIxLCBoOiAyOSB9LFxuICAgIHNpZGVzOiAyLFxuICAgIGNvbG9yc0Y6IDJcbiAgfSk7XG4gIFxuICBjb25zb2xlLmxvZygn8J+WqO+4jyBPZmZzZXQgVGVzdCBSZXN1bHRzOicsIG9mZnNldFRlc3QpO1xuICBcbiAgLy8gVmFsaWRhdGUgY29uc3RhbnRzIGFsaWdubWVudFxuICBjb25zdCBjb25zdGFudHNWYWxpZGF0aW9uID0gdmFsaWRhdGVQcmljaW5nQ29uc3RhbnRzKFxuICAgIEVYQ0VMX0RJR0lUQUxfQ09OU1RBTlRTLFxuICAgIEVYQ0VMX09GRlNFVF9DT05TVEFOVFNcbiAgKTtcbiAgXG4gIGlmIChjb25zdGFudHNWYWxpZGF0aW9uLmlzVmFsaWQpIHtcbiAgICBjb25zb2xlLmxvZygn4pyFIEV4Y2VsIENvbnN0YW50cyBWYWxpZGF0aW9uOiBQQVNTRUQnKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBFeGNlbCBDb25zdGFudHMgVmFsaWRhdGlvbjogRkFJTEVEJywgY29uc3RhbnRzVmFsaWRhdGlvbi5lcnJvcnMpO1xuICB9XG4gIFxuICByZXR1cm4geyBkaWdpdGFsVGVzdCwgb2Zmc2V0VGVzdCwgY29uc3RhbnRzVmFsaWRhdGlvbiB9O1xufVxuXG4vLyA9PT0gQ2FsY3VsYXRpb24gQWxpZ25tZW50IFZhbGlkYXRpb24gPT09XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVDYWxjdWxhdGlvbkFsaWdubWVudChcbiAgY29kZVJlc3VsdDogbnVtYmVyLFxuICBleGNlbFJlc3VsdDogbnVtYmVyLFxuICB0b2xlcmFuY2U6IG51bWJlciA9IDAuMDFcbik6IGJvb2xlYW4ge1xuICBjb25zdCBkaWZmZXJlbmNlID0gTWF0aC5hYnMoY29kZVJlc3VsdCAtIGV4Y2VsUmVzdWx0KTtcbiAgY29uc3QgaXNBbGlnbmVkID0gZGlmZmVyZW5jZSA8PSB0b2xlcmFuY2U7XG4gIFxuICBpZiAoIWlzQWxpZ25lZCkge1xuICAgIGNvbnNvbGUud2Fybihg4pqg77iPIENhbGN1bGF0aW9uIG1pc2FsaWdubWVudCBkZXRlY3RlZDpgLCB7XG4gICAgICBjb2RlUmVzdWx0LFxuICAgICAgZXhjZWxSZXN1bHQsXG4gICAgICBkaWZmZXJlbmNlLFxuICAgICAgdG9sZXJhbmNlXG4gICAgfSk7XG4gIH1cbiAgXG4gIHJldHVybiBpc0FsaWduZWQ7XG59XG5cbi8vID09PSBQcmljaW5nIENvbnN0YW50cyBWYWxpZGF0aW9uID09PVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUHJpY2luZ0NvbnN0YW50cyhcbiAgZGlnaXRhbFByaWNpbmc6IGFueSxcbiAgb2Zmc2V0UHJpY2luZzogYW55XG4pOiB7IGlzVmFsaWQ6IGJvb2xlYW47IGVycm9yczogc3RyaW5nW10gfSB7XG4gIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcbiAgXG4gIC8vIFZhbGlkYXRlIERpZ2l0YWwgUHJpY2luZyAocGVyQ2xpY2sgaXMgbm93IGNhbGN1bGF0ZWQgZHluYW1pY2FsbHkpXG4gIC8vIE5vdGU6IHBlckNsaWNrIHZhbGlkYXRpb24gcmVtb3ZlZCBhcyBpdCdzIG5vdyBjYWxjdWxhdGVkIGR5bmFtaWNhbGx5XG4gIGlmIChkaWdpdGFsUHJpY2luZy5wYXJlbnRTaGVldENvc3QgIT09IEVYQ0VMX0RJR0lUQUxfQ09OU1RBTlRTLnBhcmVudFNoZWV0Q29zdCkge1xuICAgIGVycm9ycy5wdXNoKGBEaWdpdGFsIHBhcmVudFNoZWV0Q29zdCBtaXNtYXRjaDogJHtkaWdpdGFsUHJpY2luZy5wYXJlbnRTaGVldENvc3R9IHZzICR7RVhDRUxfRElHSVRBTF9DT05TVEFOVFMucGFyZW50U2hlZXRDb3N0fWApO1xuICB9XG4gIGlmIChkaWdpdGFsUHJpY2luZy53YXN0ZVBhcmVudHMgIT09IEVYQ0VMX0RJR0lUQUxfQ09OU1RBTlRTLndhc3RlUGFyZW50cykge1xuICAgIGVycm9ycy5wdXNoKGBEaWdpdGFsIHdhc3RlUGFyZW50cyBtaXNtYXRjaDogJHtkaWdpdGFsUHJpY2luZy53YXN0ZVBhcmVudHN9IHZzICR7RVhDRUxfRElHSVRBTF9DT05TVEFOVFMud2FzdGVQYXJlbnRzfWApO1xuICB9XG4gIFxuICAvLyBWYWxpZGF0ZSBPZmZzZXQgUHJpY2luZ1xuICBpZiAob2Zmc2V0UHJpY2luZy5wYXJlbnRDb3N0ICE9PSBFWENFTF9PRkZTRVRfQ09OU1RBTlRTLnBhcmVudENvc3QpIHtcbiAgICBlcnJvcnMucHVzaChgT2Zmc2V0IHBhcmVudENvc3QgbWlzbWF0Y2g6ICR7b2Zmc2V0UHJpY2luZy5wYXJlbnRDb3N0fSB2cyAke0VYQ0VMX09GRlNFVF9DT05TVEFOVFMucGFyZW50Q29zdH1gKTtcbiAgfVxuICBpZiAob2Zmc2V0UHJpY2luZy5wbGF0ZUNvc3QgIT09IEVYQ0VMX09GRlNFVF9DT05TVEFOVFMucGxhdGVDb3N0KSB7XG4gICAgZXJyb3JzLnB1c2goYE9mZnNldCBwbGF0ZUNvc3QgbWlzbWF0Y2g6ICR7b2Zmc2V0UHJpY2luZy5wbGF0ZUNvc3R9IHZzICR7RVhDRUxfT0ZGU0VUX0NPTlNUQU5UUy5wbGF0ZUNvc3R9YCk7XG4gIH1cbiAgaWYgKG9mZnNldFByaWNpbmcubWFrZVJlYWR5U2V0dXAgIT09IEVYQ0VMX09GRlNFVF9DT05TVEFOVFMubWFrZVJlYWR5U2V0dXApIHtcbiAgICBlcnJvcnMucHVzaChgT2Zmc2V0IG1ha2VSZWFkeVNldHVwIG1pc21hdGNoOiAke29mZnNldFByaWNpbmcubWFrZVJlYWR5U2V0dXB9IHZzICR7RVhDRUxfT0ZGU0VUX0NPTlNUQU5UUy5tYWtlUmVhZHlTZXR1cH1gKTtcbiAgfVxuICBpZiAob2Zmc2V0UHJpY2luZy5ydW5QZXIxMDAwICE9PSBFWENFTF9PRkZTRVRfQ09OU1RBTlRTLnJ1blBlcjEwMDApIHtcbiAgICBlcnJvcnMucHVzaChgT2Zmc2V0IHJ1blBlcjEwMDAgbWlzbWF0Y2g6ICR7b2Zmc2V0UHJpY2luZy5ydW5QZXIxMDAwfSB2cyAke0VYQ0VMX09GRlNFVF9DT05TVEFOVFMucnVuUGVyMTAwMH1gKTtcbiAgfVxuICBpZiAob2Zmc2V0UHJpY2luZy5jdXRPcFJhdGUgIT09IEVYQ0VMX09GRlNFVF9DT05TVEFOVFMuY3V0T3BSYXRlKSB7XG4gICAgZXJyb3JzLnB1c2goYE9mZnNldCBjdXRPcFJhdGUgbWlzbWF0Y2g6ICR7b2Zmc2V0UHJpY2luZy5jdXRPcFJhdGV9IHZzICR7RVhDRUxfT0ZGU0VUX0NPTlNUQU5UUy5jdXRPcFJhdGV9YCk7XG4gIH1cbiAgXG4gIHJldHVybiB7XG4gICAgaXNWYWxpZDogZXJyb3JzLmxlbmd0aCA9PT0gMCxcbiAgICBlcnJvcnNcbiAgfTtcbn1cblxuXG5cbiJdLCJuYW1lcyI6WyJFWENFTF9ESUdJVEFMX0NPTlNUQU5UUyIsInBhcmVudFNoZWV0Q29zdCIsIndhc3RlUGFyZW50cyIsImNhbGN1bGF0ZVBlckNsaWNrIiwic2hlZXRzIiwiY3V0UGNzIiwiY29sb3JzRiIsInRvdGFsU2hlZXRzIiwiY2F0ZWdvcml6ZWRDb2xvcnMiLCJiYXNlUGVyQ2xpY2siLCJtdWx0aXBsaWVyIiwiRVhDRUxfT0ZGU0VUX0NPTlNUQU5UUyIsInBhcmVudENvc3QiLCJwbGF0ZUNvc3QiLCJtYWtlUmVhZHlTZXR1cCIsIm1ha2VSZWFkeVNoZWV0cyIsInJ1blBlcjEwMDAiLCJjdXRPcFJhdGUiLCJleGNlbERpZ2l0YWxDYWxjdWxhdGlvbiIsInF0eSIsInBpZWNlIiwic2lkZXMiLCJjb2xvcnNCIiwicGFyZW50IiwidyIsImgiLCJhbGxvd1JvdGF0ZSIsInBhcGVyQ29zdFBlclNoZWV0IiwiY29sb3JzIiwiY2FsY3VsYXRlVXBzT3B0aW9uMSIsInNoZWV0VyIsInNoZWV0SCIsInBpZWNlVyIsInBpZWNlSCIsImNvbHMiLCJNYXRoIiwiZmxvb3IiLCJyb3dzIiwiY2FsY3VsYXRlVXBzT3B0aW9uMiIsImdldEJlc3RVcHMiLCJvcHRpb24xIiwib3B0aW9uMiIsIm1heCIsImNhbGN1bGF0ZVNoZWV0cyIsInF1YW50aXR5IiwidXBzUGVyU2hlZXQiLCJjZWlsIiwiY2FsY3VsYXRlUHJpY2UiLCJjdXRQaWVjZXMiLCJwZXJDbGlja1JhdGUiLCJzaGVldE9wdGlvbnMiLCJsYWJlbCIsIm1hcCIsIm9wdGlvbiIsInVwc09wdGlvbjEiLCJ1cHNPcHRpb24yIiwidXBzUGVyQ3V0UGllY2UiLCJ0b3RhbFVwc1BlclNoZWV0IiwiZWZmZWN0aXZlUGFwZXJDb3N0IiwidW5kZWZpbmVkIiwiY29uc29sZSIsImxvZyIsInBhcGVyQ29zdCIsInBhcGVyIiwicHJpY2UiLCJ0b3RhbCIsImN1dFBlclBhcmVudCIsInVwc1BlclBhcmVudCIsInBhcmVudHMiLCJjbGlja3MiLCJmaWx0ZXIiLCJCb29sZWFuIiwiZXhjZWxPZmZzZXRDYWxjdWxhdGlvbiIsImNhbGN1bGF0ZVdhc3RlU2hlZXRzIiwid2FzdGVCYXNlIiwid2FzdGVTaGVldHMiLCJjYWxjdWxhdGVQbGF0ZUNvc3QiLCJ1bml0UHJpY2UiLCJwcmVzcyIsImJlc3RVcHMiLCJFcnJvciIsInByZXNzU2hlZXRzIiwicHJlc3NQZXJQYXJlbnQiLCJwbGF0ZXMiLCJwbGF0ZXNDIiwibWtyZWFkeSIsInJ1biIsImN1dE9wcyIsImN1dHRpbmciLCJ1cHNQZXJQcmVzcyIsInZhbGlkYXRlRXhjZWxGb3JtdWxhcyIsImRpZ2l0YWxUZXN0Iiwib2Zmc2V0VGVzdCIsImNvbnN0YW50c1ZhbGlkYXRpb24iLCJ2YWxpZGF0ZVByaWNpbmdDb25zdGFudHMiLCJpc1ZhbGlkIiwid2FybiIsImVycm9ycyIsInZhbGlkYXRlQ2FsY3VsYXRpb25BbGlnbm1lbnQiLCJjb2RlUmVzdWx0IiwiZXhjZWxSZXN1bHQiLCJ0b2xlcmFuY2UiLCJkaWZmZXJlbmNlIiwiYWJzIiwiaXNBbGlnbmVkIiwiZGlnaXRhbFByaWNpbmciLCJvZmZzZXRQcmljaW5nIiwicHVzaCIsImxlbmd0aCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/excel-calculation.ts\n"));

/***/ })

});