"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(root)/create-quote/page",{

/***/ "(app-pages-browser)/./lib/excel-calculation.ts":
/*!**********************************!*\
  !*** ./lib/excel-calculation.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXCEL_DIGITAL_CONSTANTS: () => (/* binding */ EXCEL_DIGITAL_CONSTANTS),\n/* harmony export */   EXCEL_OFFSET_CONSTANTS: () => (/* binding */ EXCEL_OFFSET_CONSTANTS),\n/* harmony export */   calculatePerClick: () => (/* binding */ calculatePerClick),\n/* harmony export */   excelDigitalCalculation: () => (/* binding */ excelDigitalCalculation),\n/* harmony export */   excelOffsetCalculation: () => (/* binding */ excelOffsetCalculation),\n/* harmony export */   validateCalculationAlignment: () => (/* binding */ validateCalculationAlignment),\n/* harmony export */   validateExcelFormulas: () => (/* binding */ validateExcelFormulas),\n/* harmony export */   validatePricingConstants: () => (/* binding */ validatePricingConstants)\n/* harmony export */ });\n// Define types locally since types module might not be available\n// === Excel Calculation Constants (from Excel analysis) ===\nconst EXCEL_DIGITAL_CONSTANTS = {\n    parentSheetCost: 1.00,\n    wasteParents: 3 // Fixed waste sheets (from Excel)\n};\n// === Dynamic Per-Click Calculation (Excel Formula) ===\n// Formula: =IF([@Sheets]*[@[Cut pcs]]>200,IF($L$2=4,1.25,0.5),IF($L$2=4,1.5,0.75)) * multiplier\n// Note: $L$2 refers to colors, not sides\n// Multiplier: 1 for cutPcs=4, 2 for cutPcs=3\n// Color categorization: 1-3 colors = 1 color, 4+ colors = 4 colors\nfunction calculatePerClick(sheets, cutPcs, colorsF) {\n    const totalSheets = sheets * cutPcs;\n    // Categorize colors: 1-3 colors = 1 color, 4+ colors = 4 colors\n    const categorizedColors = colorsF <= 3 ? 1 : 4;\n    // Base per-click rate\n    let basePerClick;\n    if (totalSheets > 200) {\n        // High volume: > 200 total sheets\n        basePerClick = categorizedColors === 4 ? 1.25 : 0.5;\n    } else {\n        // Low volume: â‰¤ 200 total sheets  \n        basePerClick = categorizedColors === 4 ? 1.5 : 0.75;\n    }\n    // Apply dynamic multiplier based on cut pieces (original formula)\n    // Multiplier = (4 - cutPcs + 1)\n    const multiplier = 4 - cutPcs + 1;\n    return basePerClick * multiplier;\n}\nconst EXCEL_OFFSET_CONSTANTS = {\n    parentCost: 8.00,\n    plateCost: 120.00,\n    makeReadySetup: 200.00,\n    makeReadySheets: 10,\n    runPer1000: 60.00,\n    cutOpRate: 8.00 // AED per cut operation (from Excel)\n};\n// === Excel Digital Calculation (Exact Excel Formulas) ===\nfunction excelDigitalCalculation(param) {\n    let { qty, piece, sides, colorsF, colorsB, parent = {\n        w: 100,\n        h: 70\n    }, allowRotate = true, paperCostPerSheet// Optional manual paper pricing override\n     } = param;\n    const colors = colorsF + (sides === 2 ? colorsB !== null && colorsB !== void 0 ? colorsB : 0 : 0);\n    // Excel Formula: ROUNDDOWN((Sheet Width) / (height + 1), 0) Ã— ROUNDDOWN((Sheet Height) / (width + 1), 0)\n    const calculateUpsOption1 = (sheetW, sheetH, pieceW, pieceH)=>{\n        const cols = Math.floor(sheetW / (pieceW + 1));\n        const rows = Math.floor(sheetH / (pieceH + 1));\n        return cols * rows;\n    };\n    // Excel Formula: ROUNDDOWN((Sheet Width) / (width + 1), 0) Ã— ROUNDDOWN((Sheet Height) / (height + 1), 0)\n    const calculateUpsOption2 = (sheetW, sheetH, pieceW, pieceH)=>{\n        const cols = Math.floor(sheetW / (pieceH + 1));\n        const rows = Math.floor(sheetH / (pieceW + 1));\n        return cols * rows;\n    };\n    // Excel Formula: IF(Option 1 > Option 2, Option 1, Option 2)\n    const getBestUps = (option1, option2)=>{\n        return Math.max(option1, option2);\n    };\n    // Excel Formula: ROUNDUP(Quantity / ups per sheet + Waste Sheets, 0)\n    const calculateSheets = (quantity, upsPerSheet)=>{\n        if (upsPerSheet === 0) return 0;\n        return Math.ceil(quantity / upsPerSheet + EXCEL_DIGITAL_CONSTANTS.wasteParents);\n    };\n    // Excel Formula: Sheets Ã— Cut pieces Ã— Per click Ã— Sides (price calculation)\n    const calculatePrice = (sheets, cutPieces, colorsF, sides)=>{\n        const perClickRate = calculatePerClick(sheets, cutPieces, colorsF);\n        return sheets * cutPieces * perClickRate * sides;\n    };\n    // Calculate for different sheet sizes (matching Excel options)\n    const sheetOptions = [\n        {\n            w: 48,\n            h: 33,\n            label: \"48Ã—33 cm\",\n            cutPcs: 4\n        },\n        {\n            w: 70,\n            h: 33,\n            label: \"70Ã—33 cm\",\n            cutPcs: 3\n        }\n    ];\n    return sheetOptions.map((option)=>{\n        // Calculate UPS for both orientations\n        const upsOption1 = calculateUpsOption1(option.w, option.h, piece.w, piece.h);\n        const upsOption2 = allowRotate ? calculateUpsOption2(option.w, option.h, piece.w, piece.h) : 0;\n        // Get best UPS per cut piece (Excel formula)\n        const upsPerCutPiece = getBestUps(upsOption1, upsOption2);\n        if (upsPerCutPiece === 0) return null;\n        // Calculate total ups per sheet = cut pieces Ã— ups per cut piece\n        const totalUpsPerSheet = option.cutPcs * upsPerCutPiece;\n        // Calculate sheets needed (Excel formula)\n        const sheets = calculateSheets(qty, totalUpsPerSheet);\n        // Calculate costs (no units calculation for digital)\n        // Use manual paper pricing if provided, otherwise use default constant\n        const effectivePaperCost = paperCostPerSheet !== undefined && paperCostPerSheet !== null ? paperCostPerSheet : EXCEL_DIGITAL_CONSTANTS.parentSheetCost;\n        const paper = sheets * effectivePaperCost;\n        const price = calculatePrice(sheets, option.cutPcs, colorsF, sides);\n        const total = price + paper;\n        return {\n            option: option.label,\n            cutPerParent: option.cutPcs,\n            upsPerSheet: totalUpsPerSheet,\n            upsPerParent: totalUpsPerSheet,\n            parents: sheets,\n            paper,\n            clicks: price,\n            total\n        };\n    }).filter(Boolean);\n}\n// === Excel Offset Calculation (Exact Excel Formulas) ===\nfunction excelOffsetCalculation(param) {\n    let { qty, piece, sides, colorsF, colorsB, parent = {\n        w: 100,\n        h: 70\n    }, allowRotate = true } = param;\n    const colors = colorsF + (sides === 2 ? colorsB !== null && colorsB !== void 0 ? colorsB : 0 : 0);\n    // Excel Formula: ROUNDDOWN((Sheet Width) / (height + 1), 0) Ã— ROUNDDOWN((Sheet Height) / (width + 1), 0)\n    const calculateUpsOption1 = (sheetW, sheetH, pieceW, pieceH)=>{\n        const cols = Math.floor(sheetW / (pieceW + 1));\n        const rows = Math.floor(sheetH / (pieceH + 1));\n        return cols * rows;\n    };\n    // Excel Formula: ROUNDDOWN((Sheet Width) / (width + 1), 0) Ã— ROUNDDOWN((Sheet Height) / (height + 1), 0)\n    const calculateUpsOption2 = (sheetW, sheetH, pieceW, pieceH)=>{\n        const cols = Math.floor(sheetW / (pieceH + 1));\n        const rows = Math.floor(sheetH / (pieceW + 1));\n        return cols * rows;\n    };\n    // Excel Formula: IF(Option 1 > Option 2, Option 1, Option 2)\n    const getBestUps = (option1, option2)=>{\n        return Math.max(option1, option2);\n    };\n    // Excel Formula: ROUNDUP(IF(Sheet Width > 50, 120/Cut pieces, 100/Cut pieces), 0)\n    const calculateWasteSheets = (sheetW, cutPieces)=>{\n        const wasteBase = sheetW > 50 ? 120 : 100;\n        return Math.ceil(wasteBase / cutPieces);\n    };\n    // Excel Formula: ROUNDUP(Quantity / ups per sheet + Waste Sheets, 0)\n    const calculateSheets = (quantity, upsPerSheet, wasteSheets)=>{\n        if (upsPerSheet === 0) return 0;\n        return Math.ceil(quantity / upsPerSheet + wasteSheets);\n    };\n    // Excel Formula: IF(Sheets = 0, 0, unit price + paper cost + Plate cost Ã— 2)\n    const calculatePlateCost = (sheets, unitPrice, paperCost, plateCost)=>{\n        if (sheets === 0) return 0;\n        return unitPrice + paperCost + plateCost * 2;\n    };\n    // Use standard press size (35Ã—50 cm) for offset calculations\n    const press = {\n        w: 35,\n        h: 50\n    };\n    // Calculate UPS for both orientations\n    const upsOption1 = calculateUpsOption1(press.w, press.h, piece.w, piece.h);\n    const upsOption2 = allowRotate ? calculateUpsOption2(press.w, press.h, piece.w, piece.h) : 0;\n    // Get best UPS (Excel formula)\n    const bestUps = getBestUps(upsOption1, upsOption2);\n    if (bestUps === 0) {\n        throw new Error(\"Press size not cuttable from parent.\");\n    }\n    // Calculate waste sheets (Excel formula)\n    const wasteSheets = calculateWasteSheets(press.w, bestUps);\n    // Calculate sheets needed (Excel formula)\n    const pressSheets = calculateSheets(qty, bestUps, wasteSheets);\n    // Calculate press per parent\n    const pressPerParent = Math.floor(parent.w / press.w) * Math.floor(parent.h / press.h);\n    const parents = Math.ceil(pressSheets / pressPerParent);\n    // Calculate costs\n    const plates = colors;\n    const paper = parents * EXCEL_OFFSET_CONSTANTS.parentCost;\n    const platesC = plates * EXCEL_OFFSET_CONSTANTS.plateCost;\n    const mkready = EXCEL_OFFSET_CONSTANTS.makeReadySetup + EXCEL_OFFSET_CONSTANTS.makeReadySheets * (EXCEL_OFFSET_CONSTANTS.parentCost / pressPerParent);\n    const run = pressSheets * sides * (EXCEL_OFFSET_CONSTANTS.runPer1000 / 1000);\n    // Calculate cutting operations\n    const cols = Math.floor(press.w / (piece.w + 1));\n    const rows = Math.floor(press.h / (piece.h + 1));\n    const cutOps = cols && rows ? 4 + (cols - 1) + cols * (rows - 1) : 0;\n    const cutting = cutOps * EXCEL_OFFSET_CONSTANTS.cutOpRate * pressSheets;\n    const total = paper + platesC + mkready + run + cutting;\n    return {\n        pressPerParent,\n        upsPerPress: bestUps,\n        pressSheets,\n        parents,\n        plates,\n        paper,\n        platesC,\n        mkready,\n        run,\n        cutting,\n        total\n    };\n}\n// === Excel Formula Validation ===\nfunction validateExcelFormulas() {\n    console.log('ðŸ” Validating Excel Formulas...');\n    // Test Digital Calculation\n    const digitalTest = excelDigitalCalculation({\n        qty: 1000,\n        piece: {\n            w: 5.5,\n            h: 9\n        },\n        sides: 2,\n        colorsF: 4\n    });\n    console.log('ðŸ“± Digital Test Results:', digitalTest);\n    // Test Offset Calculation\n    const offsetTest = excelOffsetCalculation({\n        qty: 3000,\n        piece: {\n            w: 21,\n            h: 29\n        },\n        sides: 2,\n        colorsF: 2\n    });\n    console.log('ðŸ–¨ï¸ Offset Test Results:', offsetTest);\n    // Validate constants alignment\n    const constantsValidation = validatePricingConstants(EXCEL_DIGITAL_CONSTANTS, EXCEL_OFFSET_CONSTANTS);\n    if (constantsValidation.isValid) {\n        console.log('âœ… Excel Constants Validation: PASSED');\n    } else {\n        console.warn('âš ï¸ Excel Constants Validation: FAILED', constantsValidation.errors);\n    }\n    return {\n        digitalTest,\n        offsetTest,\n        constantsValidation\n    };\n}\n// === Calculation Alignment Validation ===\nfunction validateCalculationAlignment(codeResult, excelResult) {\n    let tolerance = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.01;\n    const difference = Math.abs(codeResult - excelResult);\n    const isAligned = difference <= tolerance;\n    if (!isAligned) {\n        console.warn(\"âš ï¸ Calculation misalignment detected:\", {\n            codeResult,\n            excelResult,\n            difference,\n            tolerance\n        });\n    }\n    return isAligned;\n}\n// === Pricing Constants Validation ===\nfunction validatePricingConstants(digitalPricing, offsetPricing) {\n    const errors = [];\n    // Validate Digital Pricing (perClick is now calculated dynamically)\n    // Note: perClick validation removed as it's now calculated dynamically\n    if (digitalPricing.parentSheetCost !== EXCEL_DIGITAL_CONSTANTS.parentSheetCost) {\n        errors.push(\"Digital parentSheetCost mismatch: \".concat(digitalPricing.parentSheetCost, \" vs \").concat(EXCEL_DIGITAL_CONSTANTS.parentSheetCost));\n    }\n    if (digitalPricing.wasteParents !== EXCEL_DIGITAL_CONSTANTS.wasteParents) {\n        errors.push(\"Digital wasteParents mismatch: \".concat(digitalPricing.wasteParents, \" vs \").concat(EXCEL_DIGITAL_CONSTANTS.wasteParents));\n    }\n    // Validate Offset Pricing\n    if (offsetPricing.parentCost !== EXCEL_OFFSET_CONSTANTS.parentCost) {\n        errors.push(\"Offset parentCost mismatch: \".concat(offsetPricing.parentCost, \" vs \").concat(EXCEL_OFFSET_CONSTANTS.parentCost));\n    }\n    if (offsetPricing.plateCost !== EXCEL_OFFSET_CONSTANTS.plateCost) {\n        errors.push(\"Offset plateCost mismatch: \".concat(offsetPricing.plateCost, \" vs \").concat(EXCEL_OFFSET_CONSTANTS.plateCost));\n    }\n    if (offsetPricing.makeReadySetup !== EXCEL_OFFSET_CONSTANTS.makeReadySetup) {\n        errors.push(\"Offset makeReadySetup mismatch: \".concat(offsetPricing.makeReadySetup, \" vs \").concat(EXCEL_OFFSET_CONSTANTS.makeReadySetup));\n    }\n    if (offsetPricing.runPer1000 !== EXCEL_OFFSET_CONSTANTS.runPer1000) {\n        errors.push(\"Offset runPer1000 mismatch: \".concat(offsetPricing.runPer1000, \" vs \").concat(EXCEL_OFFSET_CONSTANTS.runPer1000));\n    }\n    if (offsetPricing.cutOpRate !== EXCEL_OFFSET_CONSTANTS.cutOpRate) {\n        errors.push(\"Offset cutOpRate mismatch: \".concat(offsetPricing.cutOpRate, \" vs \").concat(EXCEL_OFFSET_CONSTANTS.cutOpRate));\n    }\n    return {\n        isValid: errors.length === 0,\n        errors\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9leGNlbC1jYWxjdWxhdGlvbi50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLGlFQUFpRTtBQTRCakUsNERBQTREO0FBQ3JELE1BQU1BLDBCQUEwQjtJQUNyQ0MsaUJBQWlCO0lBQ2pCQyxjQUFjLEVBQVMsa0NBQWtDO0FBQzNELEVBQUU7QUFFRix3REFBd0Q7QUFDeEQsZ0dBQWdHO0FBQ2hHLHlDQUF5QztBQUN6Qyw2Q0FBNkM7QUFDN0MsbUVBQW1FO0FBQzVELFNBQVNDLGtCQUFrQkMsTUFBYyxFQUFFQyxNQUFjLEVBQUVDLE9BQWU7SUFDL0UsTUFBTUMsY0FBY0gsU0FBU0M7SUFFN0IsZ0VBQWdFO0lBQ2hFLE1BQU1HLG9CQUFvQkYsV0FBVyxJQUFJLElBQUk7SUFFN0Msc0JBQXNCO0lBQ3RCLElBQUlHO0lBQ0osSUFBSUYsY0FBYyxLQUFLO1FBQ3JCLGtDQUFrQztRQUNsQ0UsZUFBZUQsc0JBQXNCLElBQUksT0FBTztJQUNsRCxPQUFPO1FBQ0wsbUNBQW1DO1FBQ25DQyxlQUFlRCxzQkFBc0IsSUFBSSxNQUFNO0lBQ2pEO0lBRUEsa0VBQWtFO0lBQ2xFLGdDQUFnQztJQUNoQyxNQUFNRSxhQUFhLElBQUlMLFNBQVM7SUFFaEMsT0FBT0ksZUFBZUM7QUFDeEI7QUFFTyxNQUFNQyx5QkFBeUI7SUFDcENDLFlBQVk7SUFDWkMsV0FBVztJQUNYQyxnQkFBZ0I7SUFDaEJDLGlCQUFpQjtJQUNqQkMsWUFBWTtJQUNaQyxXQUFXLEtBQVkscUNBQXFDO0FBQzlELEVBQUU7QUFFRiwyREFBMkQ7QUFDcEQsU0FBU0Msd0JBQXdCLEtBa0J2QztRQWxCdUMsRUFDdENDLEdBQUcsRUFDSEMsS0FBSyxFQUNMQyxLQUFLLEVBQ0xmLE9BQU8sRUFDUGdCLE9BQU8sRUFDUEMsU0FBUztRQUFFQyxHQUFHO1FBQUtDLEdBQUc7SUFBRyxDQUFDLEVBQzFCQyxjQUFjLElBQUksRUFDbEJDLGlCQUFpQix5Q0FBMEM7TUFVNUQsR0Fs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K0JBQThEaEcsT0FBL0IrRixjQUFjOUYsVUFBVSxFQUFDLFFBQXdDLE9BQWxDRCx1QkFBdUJDLFVBQVU7SUFDN0c7SUFDQSxJQUFJOEYsY0FBYzdGLFNBQVMsS0FBS0YsdUJBQXVCRSxTQUFTLEVBQUU7UUFDaEVvRixPQUFPVSxJQUFJLENBQUMsOEJBQTREaEcsT0FBOUIrRixjQUFjN0YsU0FBUyxFQUFDLFFBQXVDLE9BQWpDRix1QkFBdUJFLFNBQVM7SUFDMUc7SUFDQSxJQUFJNkYsY0FBYzVGLGNBQWMsS0FBS0gsdUJBQXVCRyxjQUFjLEVBQUU7UUFDMUVtRixPQUFPVSxJQUFJLENBQUMsbUNBQXNFaEcsT0FBbkMrRixjQUFjNUYsY0FBYyxFQUFDLFFBQTRDLE9BQXRDSCx1QkFBdUJHLGNBQWM7SUFDekg7SUFDQSxJQUFJNEYsY0FBYzFGLFVBQVUsS0FBS0wsdUJBQXVCSyxVQUFVLEVBQUU7UUFDbEVpRixPQUFPVSxJQUFJLENBQUMsK0JBQThEaEcsT0FBL0IrRixjQUFjMUYsVUFBVSxFQUFDLFFBQXdDLE9BQWxDTCx1QkFBdUJLLFVBQVU7SUFDN0c7SUFDQSxJQUFJMEYsY0FBY3pGLFNBQVMsS0FBS04sdUJBQXVCTSxTQUFTLEVBQUU7UUFDaEVnRixPQUFPVSxJQUFJLENBQUMsOEJBQTREaEcsT0FBOUIrRixjQUFjekYsU0FBUyxFQUFDLFFBQXVDLE9BQWpDTix1QkFBdUJNLFNBQVM7SUFDMUc7SUFFQSxPQUFPO1FBQ0w4RSxTQUFTRSxPQUFPVyxNQUFNLEtBQUs7UUFDM0JYO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL0FsaWZrYV9Sb29zc2VvL0Rlc2t0b3AvUHJvamVjdC9TbWFydC1wcmludGluZy11cGRhdGUvbGliL2V4Y2VsLWNhbGN1bGF0aW9uLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIERlZmluZSB0eXBlcyBsb2NhbGx5IHNpbmNlIHR5cGVzIG1vZHVsZSBtaWdodCBub3QgYmUgYXZhaWxhYmxlXG50eXBlIENtID0gbnVtYmVyO1xuXG5pbnRlcmZhY2UgRGlnaXRhbENvc3RpbmdSZXN1bHQge1xuICBvcHRpb246IHN0cmluZztcbiAgY3V0UGVyUGFyZW50OiBudW1iZXI7XG4gIHVwc1BlclNoZWV0OiBudW1iZXI7XG4gIHVwc1BlclBhcmVudDogbnVtYmVyO1xuICBwYXJlbnRzOiBudW1iZXI7XG4gIHBhcGVyOiBudW1iZXI7XG4gIGNsaWNrczogbnVtYmVyO1xuICB0b3RhbDogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgT2Zmc2V0Q29zdGluZ1Jlc3VsdCB7XG4gIHByZXNzUGVyUGFyZW50OiBudW1iZXI7XG4gIHVwc1BlclByZXNzOiBudW1iZXI7XG4gIHByZXNzU2hlZXRzOiBudW1iZXI7XG4gIHBhcmVudHM6IG51bWJlcjtcbiAgcGxhdGVzOiBudW1iZXI7XG4gIHBhcGVyOiBudW1iZXI7XG4gIHBsYXRlc0M6IG51bWJlcjtcbiAgbWtyZWFkeTogbnVtYmVyO1xuICBydW46IG51bWJlcjtcbiAgY3V0dGluZzogbnVtYmVyO1xuICB0b3RhbDogbnVtYmVyO1xufVxuXG4vLyA9PT0gRXhjZWwgQ2FsY3VsYXRpb24gQ29uc3RhbnRzIChmcm9tIEV4Y2VsIGFuYWx5c2lzKSA9PT1cbmV4cG9ydCBjb25zdCBFWENFTF9ESUdJVEFMX0NPTlNUQU5UUyA9IHtcbiAgcGFyZW50U2hlZXRDb3N0OiAxLjAwLCAvLyBBRUQgcGVyIHBhcmVudCBzaGVldCAoZnJvbSB1c2VyIGV4YW1wbGUpXG4gIHdhc3RlUGFyZW50czogMyAgICAgICAgLy8gRml4ZWQgd2FzdGUgc2hlZXRzIChmcm9tIEV4Y2VsKVxufTtcblxuLy8gPT09IER5bmFtaWMgUGVyLUNsaWNrIENhbGN1bGF0aW9uIChFeGNlbCBGb3JtdWxhKSA9PT1cbi8vIEZvcm11bGE6ID1JRihbQFNoZWV0c10qW0BbQ3V0IHBjc11dPjIwMCxJRigkTCQyPTQsMS4yNSwwLjUpLElGKCRMJDI9NCwxLjUsMC43NSkpICogbXVsdGlwbGllclxuLy8gTm90ZTogJEwkMiByZWZlcnMgdG8gY29sb3JzLCBub3Qgc2lkZXNcbi8vIE11bHRpcGxpZXI6IDEgZm9yIGN1dFBjcz00LCAyIGZvciBjdXRQY3M9M1xuLy8gQ29sb3IgY2F0ZWdvcml6YXRpb246IDEtMyBjb2xvcnMgPSAxIGNvbG9yLCA0KyBjb2xvcnMgPSA0IGNvbG9yc1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVBlckNsaWNrKHNoZWV0czogbnVtYmVyLCBjdXRQY3M6IG51bWJlciwgY29sb3JzRjogbnVtYmVyKTogbnVtYmVyIHtcbiAgY29uc3QgdG90YWxTaGVldHMgPSBzaGVldHMgKiBjdXRQY3M7XG4gIFxuICAvLyBDYXRlZ29yaXplIGNvbG9yczogMS0zIGNvbG9ycyA9IDEgY29sb3IsIDQrIGNvbG9ycyA9IDQgY29sb3JzXG4gIGNvbnN0IGNhdGVnb3JpemVkQ29sb3JzID0gY29sb3JzRiA8PSAzID8gMSA6IDQ7XG4gIFxuICAvLyBCYXNlIHBlci1jbGljayByYXRlXG4gIGxldCBiYXNlUGVyQ2xpY2s6IG51bWJlcjtcbiAgaWYgKHRvdGFsU2hlZXRzID4gMjAwKSB7XG4gICAgLy8gSGlnaCB2b2x1bWU6ID4gMjAwIHRvdGFsIHNoZWV0c1xuICAgIGJhc2VQZXJDbGljayA9IGNhdGVnb3JpemVkQ29sb3JzID09PSA0ID8gMS4yNSA6IDAuNTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMb3cgdm9sdW1lOiDiiaQgMjAwIHRvdGFsIHNoZWV0cyAgXG4gICAgYmFzZVBlckNsaWNrID0gY2F0ZWdvcml6ZWRDb2xvcnMgPT09IDQgPyAxLjUgOiAwLjc1O1xuICB9XG4gIFxuICAvLyBBcHBseSBkeW5hbWljIG11bHRpcGxpZXIgYmFzZWQgb24gY3V0IHBpZWNlcyAob3JpZ2luYWwgZm9ybXVsYSlcbiAgLy8gTXVsdGlwbGllciA9ICg0IC0gY3V0UGNzICsgMSlcbiAgY29uc3QgbXVsdGlwbGllciA9IDQgLSBjdXRQY3MgKyAxO1xuICBcbiAgcmV0dXJuIGJhc2VQZXJDbGljayAqIG11bHRpcGxpZXI7XG59XG5cbmV4cG9ydCBjb25zdCBFWENFTF9PRkZTRVRfQ09OU1RBTlRTID0ge1xuICBwYXJlbnRDb3N0OiA4LjAwLCAgICAgIC8vIEFFRCBwZXIgcGFyZW50IHNoZWV0IChmcm9tIEV4Y2VsKVxuICBwbGF0ZUNvc3Q6IDEyMC4wMCwgICAgIC8vIEFFRCBwZXIgcGxhdGUgKGZyb20gRXhjZWwpXG4gIG1ha2VSZWFkeVNldHVwOiAyMDAuMDAsIC8vIEFFRCBzZXR1cCBjb3N0IChmcm9tIEV4Y2VsKVxuICBtYWtlUmVhZHlTaGVldHM6IDEwLCAgIC8vIE51bWJlciBvZiBtYWtlLXJlYWR5IHNoZWV0cyAoZnJvbSBFeGNlbClcbiAgcnVuUGVyMTAwMDogNjAuMDAsICAgICAvLyBBRUQgcGVyIDEwMDAgaW1wcmVzc2lvbnMgKGZyb20gRXhjZWwpXG4gIGN1dE9wUmF0ZTogOC4wMCAgICAgICAgLy8gQUVEIHBlciBjdXQgb3BlcmF0aW9uIChmcm9tIEV4Y2VsKVxufTtcblxuLy8gPT09IEV4Y2VsIERpZ2l0YWwgQ2FsY3VsYXRpb24gKEV4YWN0IEV4Y2VsIEZvcm11bGFzKSA9PT1cbmV4cG9ydCBmdW5jdGlvbiBleGNlbERpZ2l0YWxDYWxjdWxhdGlvbih7XG4gIHF0eSxcbiAgcGllY2UsXG4gIHNpZGVzLFxuICBjb2xvcnNGLFxuICBjb2xvcnNCLFxuICBwYXJlbnQgPSB7IHc6IDEwMCwgaDogNzAgfSwgLy8gRGVmYXVsdCBwYXJlbnQgc2hlZXQgc2l6ZVxuICBhbGxvd1JvdGF0ZSA9IHRydWUsXG4gIHBhcGVyQ29zdFBlclNoZWV0IC8vIE9wdGlvbmFsIG1hbnVhbCBwYXBlciBwcmljaW5nIG92ZXJyaWRlXG59OiB7XG4gIHF0eTogbnVtYmVyO1xuICBwaWVjZTogeyB3OiBDbTsgaDogQ20gfTtcbiAgc2lkZXM6IDEgfCAyO1xuICBjb2xvcnNGOiAxIHwgMiB8IDQ7XG4gIGNvbG9yc0I/OiAxIHwgMiB8IDQ7XG4gIHBhcmVudD86IHsgdzogQ207IGg6IENtIH07XG4gIGFsbG93Um90YXRlPzogYm9vbGVhbjtcbiAgcGFwZXJDb3N0UGVyU2hlZXQ/OiBudW1iZXI7IC8vIE1hbnVhbCBwYXBlciBwcmljaW5nIG92ZXJyaWRlXG59KTogRGlnaXRhbENvc3RpbmdSZXN1bHRbXSB7XG4gIFxuICBjb25zdCBjb2xvcnMgPSBjb2xvcnNGICsgKHNpZGVzID09PSAyID8gKGNvbG9yc0IgPz8gMCkgOiAwKTtcbiAgXG4gIC8vIEV4Y2VsIEZvcm11bGE6IFJPVU5ERE9XTigoU2hlZXQgV2lkdGgpIC8gKGhlaWdodCArIDEpLCAwKSDDlyBST1VORERPV04oKFNoZWV0IEhlaWdodCkgLyAod2lkdGggKyAxKSwgMClcbiAgY29uc3QgY2FsY3VsYXRlVXBzT3B0aW9uMSA9IChzaGVldFc6IG51bWJlciwgc2hlZXRIOiBudW1iZXIsIHBpZWNlVzogbnVtYmVyLCBwaWVjZUg6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IGNvbHMgPSBNYXRoLmZsb29yKHNoZWV0VyAvIChwaWVjZVcgKyAxKSk7XG4gICAgY29uc3Qgcm93cyA9IE1hdGguZmxvb3Ioc2hlZXRIIC8gKHBpZWNlSCArIDEpKTtcbiAgICByZXR1cm4gY29scyAqIHJvd3M7XG4gIH07XG5cbiAgLy8gRXhjZWwgRm9ybXVsYTogUk9VTkRET1dOKChTaGVldCBXaWR0aCkgLyAod2lkdGggKyAxKSwgMCkgw5cgUk9VTkRET1dOKChTaGVldCBIZWlnaHQpIC8gKGhlaWdodCArIDEpLCAwKVxuICBjb25zdCBjYWxjdWxhdGVVcHNPcHRpb24yID0gKHNoZWV0VzogbnVtYmVyLCBzaGVldEg6IG51bWJlciwgcGllY2VXOiBudW1iZXIsIHBpZWNlSDogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgY29scyA9IE1hdGguZmxvb3Ioc2hlZXRXIC8gKHBpZWNlSCArIDEpKTtcbiAgICBjb25zdCByb3dzID0gTWF0aC5mbG9vcihzaGVldEggLyAocGllY2VXICsgMSkpO1xuICAgIHJldHVybiBjb2xzICogcm93cztcbiAgfTtcblxuICAvLyBFeGNlbCBGb3JtdWxhOiBJRihPcHRpb24gMSA+IE9wdGlvbiAyLCBPcHRpb24gMSwgT3B0aW9uIDIpXG4gIGNvbnN0IGdldEJlc3RVcHMgPSAob3B0aW9uMTogbnVtYmVyLCBvcHRpb24yOiBudW1iZXIpID0+IHtcbiAgICByZXR1cm4gTWF0aC5tYXgob3B0aW9uMSwgb3B0aW9uMik7XG4gIH07XG5cbiAgLy8gRXhjZWwgRm9ybXVsYTogUk9VTkRVUChRdWFudGl0eSAvIHVwcyBwZXIgc2hlZXQgKyBXYXN0ZSBTaGVldHMsIDApXG4gIGNvbnN0IGNhbGN1bGF0ZVNoZWV0cyA9IChxdWFudGl0eTogbnVtYmVyLCB1cHNQZXJTaGVldDogbnVtYmVyKSA9PiB7XG4gICAgaWYgKHVwc1BlclNoZWV0ID09PSAwKSByZXR1cm4gMDtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHF1YW50aXR5IC8gdXBzUGVyU2hlZXQgKyBFWENFTF9ESUdJVEFMX0NPTlNUQU5UUy53YXN0ZVBhcmVudHMpO1xuICB9O1xuXG4gIC8vIEV4Y2VsIEZvcm11bGE6IFNoZWV0cyDDlyBDdXQgcGllY2VzIMOXIFBlciBjbGljayDDlyBTaWRlcyAocHJpY2UgY2FsY3VsYXRpb24pXG4gIGNvbnN0IGNhbGN1bGF0ZVByaWNlID0gKHNoZWV0czogbnVtYmVyLCBjdXRQaWVjZXM6IG51bWJlciwgY29sb3JzRjogbnVtYmVyLCBzaWRlczogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgcGVyQ2xpY2tSYXRlID0gY2FsY3VsYXRlUGVyQ2xpY2soc2hlZXRzLCBjdXRQaWVjZXMsIGNvbG9yc0YpO1xuICAgIHJldHVybiBzaGVldHMgKiBjdXRQaWVjZXMgKiBwZXJDbGlja1JhdGUgKiBzaWRlcztcbiAgfTtcblxuICAvLyBDYWxjdWxhdGUgZm9yIGRpZmZlcmVudCBzaGVldCBzaXplcyAobWF0Y2hpbmcgRXhjZWwgb3B0aW9ucylcbiAgY29uc3Qgc2hlZXRPcHRpb25zID0gW1xuICAgIHsgdzogNDgsIGg6IDMzLCBsYWJlbDogXCI0OMOXMzMgY21cIiwgY3V0UGNzOiA0IH0sXG4gICAgeyB3OiA3MCwgaDogMzMsIGxhYmVsOiBcIjcww5czMyBjbVwiLCBjdXRQY3M6IDMgfVxuICBdO1xuXG4gIHJldHVybiBzaGVldE9wdGlvbnMubWFwKG9wdGlvbiA9PiB7XG4gICAgLy8gQ2FsY3VsYXRlIFVQUyBmb3IgYm90aCBvcmllbnRhdGlvbnNcbiAgICBjb25zdCB1cHNPcHRpb24xID0gY2FsY3VsYXRlVXBzT3B0aW9uMShvcHRpb24udywgb3B0aW9uLmgsIHBpZWNlLncsIHBpZWNlLmgpO1xuICAgIGNvbnN0IHVwc09wdGlvbjIgPSBhbGxvd1JvdGF0ZSA/IGNhbGN1bGF0ZVVwc09wdGlvbjIob3B0aW9uLncsIG9wdGlvbi5oLCBwaWVjZS53LCBwaWVjZS5oKSA6IDA7XG4gICAgXG4gICAgLy8gR2V0IGJlc3QgVVBTIHBlciBjdXQgcGllY2UgKEV4Y2VsIGZvcm11bGEpXG4gICAgY29uc3QgdXBzUGVyQ3V0UGllY2UgPSBnZXRCZXN0VXBzKHVwc09wdGlvbjEsIHVwc09wdGlvbjIpO1xuICAgIFxuICAgIGlmICh1cHNQZXJDdXRQaWVjZSA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBDYWxjdWxhdGUgdG90YWwgdXBzIHBlciBzaGVldCA9IGN1dCBwaWVjZXMgw5cgdXBzIHBlciBjdXQgcGllY2VcbiAgICBjb25zdCB0b3RhbFVwc1BlclNoZWV0ID0gb3B0aW9uLmN1dFBjcyAqIHVwc1BlckN1dFBpZWNlO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBzaGVldHMgbmVlZGVkIChFeGNlbCBmb3JtdWxhKVxuICAgIGNvbnN0IHNoZWV0cyA9IGNhbGN1bGF0ZVNoZWV0cyhxdHksIHRvdGFsVXBzUGVyU2hlZXQpO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBjb3N0cyAobm8gdW5pdHMgY2FsY3VsYXRpb24gZm9yIGRpZ2l0YWwpXG4gICAgLy8gVXNlIG1hbnVhbCBwYXBlciBwcmljaW5nIGlmIHByb3ZpZGVkLCBvdGhlcndpc2UgdXNlIGRlZmF1bHQgY29uc3RhbnRcbiAgICBjb25zdCBlZmZlY3RpdmVQYXBlckNvc3QgPSBwYXBlckNvc3RQZXJTaGVldCAhPT0gdW5kZWZpbmVkICYmIHBhcGVyQ29zdFBlclNoZWV0ICE9PSBudWxsIFxuICAgICAgPyBwYXBlckNvc3RQZXJTaGVldCBcbiAgICAgIDogRVhDRUxfRElHSVRBTF9DT05TVEFOVFMucGFyZW50U2hlZXRDb3N0O1xuICAgIGNvbnN0IHBhcGVyID0gc2hlZXRzICogZWZmZWN0aXZlUGFwZXJDb3N0O1xuICAgIGNvbnN0IHByaWNlID0gY2FsY3VsYXRlUHJpY2Uoc2hlZXRzLCBvcHRpb24uY3V0UGNzLCBjb2xvcnNGLCBzaWRlcyk7XG4gICAgY29uc3QgdG90YWwgPSBwcmljZSArIHBhcGVyO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9wdGlvbjogb3B0aW9uLmxhYmVsLFxuICAgICAgY3V0UGVyUGFyZW50OiBvcHRpb24uY3V0UGNzLFxuICAgICAgdXBzUGVyU2hlZXQ6IHRvdGFsVXBzUGVyU2hlZXQsXG4gICAgICB1cHNQZXJQYXJlbnQ6IHRvdGFsVXBzUGVyU2hlZXQsXG4gICAgICBwYXJlbnRzOiBzaGVldHMsXG4gICAgICBwYXBlcixcbiAgICAgIGNsaWNrczogcHJpY2UsIC8vIFByaWNlIGluY2x1ZGVzIGNsaWNrIGNvc3RcbiAgICAgIHRvdGFsXG4gICAgfTtcbiAgfSkuZmlsdGVyKEJvb2xlYW4pIGFzIERpZ2l0YWxDb3N0aW5nUmVzdWx0W107XG59XG5cbi8vID09PSBFeGNlbCBPZmZzZXQgQ2FsY3VsYXRpb24gKEV4YWN0IEV4Y2VsIEZvcm11bGFzKSA9PT1cbmV4cG9ydCBmdW5jdGlvbiBleGNlbE9mZnNldENhbGN1bGF0aW9uKHtcbiAgcXR5LFxuICBwaWVjZSxcbiAgc2lkZXMsXG4gIGNvbG9yc0YsXG4gIGNvbG9yc0IsXG4gIHBhcmVudCA9IHsgdzogMTAwLCBoOiA3MCB9LCAvLyBEZWZhdWx0IHBhcmVudCBzaGVldCBzaXplXG4gIGFsbG93Um90YXRlID0gdHJ1ZVxufToge1xuICBxdHk6IG51bWJlcjtcbiAgcGllY2U6IHsgdzogQ207IGg6IENtIH07XG4gIHNpZGVzOiAxIHwgMjtcbiAgY29sb3JzRjogMSB8IDIgfCA0O1xuICBjb2xvcnNCPzogMSB8IDIgfCA0O1xuICBwYXJlbnQ/OiB7IHc6IENtOyBoOiBDbSB9O1xuICBhbGxvd1JvdGF0ZT86IGJvb2xlYW47XG59KTogT2Zmc2V0Q29zdGluZ1Jlc3VsdCB7XG4gIFxuICBjb25zdCBjb2xvcnMgPSBjb2xvcnNGICsgKHNpZGVzID09PSAyID8gKGNvbG9yc0IgPz8gMCkgOiAwKTtcbiAgXG4gIC8vIEV4Y2VsIEZvcm11bGE6IFJPVU5ERE9XTigoU2hlZXQgV2lkdGgpIC8gKGhlaWdodCArIDEpLCAwKSDDlyBST1VORERPV04oKFNoZWV0IEhlaWdodCkgLyAod2lkdGggKyAxKSwgMClcbiAgY29uc3QgY2FsY3VsYXRlVXBzT3B0aW9uMSA9IChzaGVldFc6IG51bWJlciwgc2hlZXRIOiBudW1iZXIsIHBpZWNlVzogbnVtYmVyLCBwaWVjZUg6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IGNvbHMgPSBNYXRoLmZsb29yKHNoZWV0VyAvIChwaWVjZVcgKyAxKSk7XG4gICAgY29uc3Qgcm93cyA9IE1hdGguZmxvb3Ioc2hlZXRIIC8gKHBpZWNlSCArIDEpKTtcbiAgICByZXR1cm4gY29scyAqIHJvd3M7XG4gIH07XG5cbiAgLy8gRXhjZWwgRm9ybXVsYTogUk9VTkRET1dOKChTaGVldCBXaWR0aCkgLyAod2lkdGggKyAxKSwgMCkgw5cgUk9VTkRET1dOKChTaGVldCBIZWlnaHQpIC8gKGhlaWdodCArIDEpLCAwKVxuICBjb25zdCBjYWxjdWxhdGVVcHNPcHRpb24yID0gKHNoZWV0VzogbnVtYmVyLCBzaGVldEg6IG51bWJlciwgcGllY2VXOiBudW1iZXIsIHBpZWNlSDogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgY29scyA9IE1hdGguZmxvb3Ioc2hlZXRXIC8gKHBpZWNlSCArIDEpKTtcbiAgICBjb25zdCByb3dzID0gTWF0aC5mbG9vcihzaGVldEggLyAocGllY2VXICsgMSkpO1xuICAgIHJldHVybiBjb2xzICogcm93cztcbiAgfTtcblxuICAvLyBFeGNlbCBGb3JtdWxhOiBJRihPcHRpb24gMSA+IE9wdGlvbiAyLCBPcHRpb24gMSwgT3B0aW9uIDIpXG4gIGNvbnN0IGdldEJlc3RVcHMgPSAob3B0aW9uMTogbnVtYmVyLCBvcHRpb24yOiBudW1iZXIpID0+IHtcbiAgICByZXR1cm4gTWF0aC5tYXgob3B0aW9uMSwgb3B0aW9uMik7XG4gIH07XG5cbiAgLy8gRXhjZWwgRm9ybXVsYTogUk9VTkRVUChJRihTaGVldCBXaWR0aCA+IDUwLCAxMjAvQ3V0IHBpZWNlcywgMTAwL0N1dCBwaWVjZXMpLCAwKVxuICBjb25zdCBjYWxjdWxhdGVXYXN0ZVNoZWV0cyA9IChzaGVldFc6IG51bWJlciwgY3V0UGllY2VzOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCB3YXN0ZUJhc2UgPSBzaGVldFcgPiA1MCA/IDEyMCA6IDEwMDtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHdhc3RlQmFzZSAvIGN1dFBpZWNlcyk7XG4gIH07XG5cbiAgLy8gRXhjZWwgRm9ybXVsYTogUk9VTkRVUChRdWFudGl0eSAvIHVwcyBwZXIgc2hlZXQgKyBXYXN0ZSBTaGVldHMsIDApXG4gIGNvbnN0IGNhbGN1bGF0ZVNoZWV0cyA9IChxdWFudGl0eTogbnVtYmVyLCB1cHNQZXJTaGVldDogbnVtYmVyLCB3YXN0ZVNoZWV0czogbnVtYmVyKSA9PiB7XG4gICAgaWYgKHVwc1BlclNoZWV0ID09PSAwKSByZXR1cm4gMDtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHF1YW50aXR5IC8gdXBzUGVyU2hlZXQgKyB3YXN0ZVNoZWV0cyk7XG4gIH07XG5cbiAgLy8gRXhjZWwgRm9ybXVsYTogSUYoU2hlZXRzID0gMCwgMCwgdW5pdCBwcmljZSArIHBhcGVyIGNvc3QgKyBQbGF0ZSBjb3N0IMOXIDIpXG4gIGNvbnN0IGNhbGN1bGF0ZVBsYXRlQ29zdCA9IChzaGVldHM6IG51bWJlciwgdW5pdFByaWNlOiBudW1iZXIsIHBhcGVyQ29zdDogbnVtYmVyLCBwbGF0ZUNvc3Q6IG51bWJlcikgPT4ge1xuICAgIGlmIChzaGVldHMgPT09IDApIHJldHVybiAwO1xuICAgIHJldHVybiB1bml0UHJpY2UgKyBwYXBlckNvc3QgKyAocGxhdGVDb3N0ICogMik7XG4gIH07XG5cbiAgLy8gVXNlIHN0YW5kYXJkIHByZXNzIHNpemUgKDM1w5c1MCBjbSkgZm9yIG9mZnNldCBjYWxjdWxhdGlvbnNcbiAgY29uc3QgcHJlc3MgPSB7IHc6IDM1LCBoOiA1MCB9O1xuICBcbiAgLy8gQ2FsY3VsYXRlIFVQUyBmb3IgYm90aCBvcmllbnRhdGlvbnNcbiAgY29uc3QgdXBzT3B0aW9uMSA9IGNhbGN1bGF0ZVVwc09wdGlvbjEocHJlc3MudywgcHJlc3MuaCwgcGllY2UudywgcGllY2UuaCk7XG4gIGNvbnN0IHVwc09wdGlvbjIgPSBhbGxvd1JvdGF0ZSA/IGNhbGN1bGF0ZVVwc09wdGlvbjIocHJlc3MudywgcHJlc3MuaCwgcGllY2UudywgcGllY2UuaCkgOiAwO1xuICBcbiAgLy8gR2V0IGJlc3QgVVBTIChFeGNlbCBmb3JtdWxhKVxuICBjb25zdCBiZXN0VXBzID0gZ2V0QmVzdFVwcyh1cHNPcHRpb24xLCB1cHNPcHRpb24yKTtcbiAgXG4gIGlmIChiZXN0VXBzID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUHJlc3Mgc2l6ZSBub3QgY3V0dGFibGUgZnJvbSBwYXJlbnQuXCIpO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIHdhc3RlIHNoZWV0cyAoRXhjZWwgZm9ybXVsYSlcbiAgY29uc3Qgd2FzdGVTaGVldHMgPSBjYWxjdWxhdGVXYXN0ZVNoZWV0cyhwcmVzcy53LCBiZXN0VXBzKTtcbiAgXG4gIC8vIENhbGN1bGF0ZSBzaGVldHMgbmVlZGVkIChFeGNlbCBmb3JtdWxhKVxuICBjb25zdCBwcmVzc1NoZWV0cyA9IGNhbGN1bGF0ZVNoZWV0cyhxdHksIGJlc3RVcHMsIHdhc3RlU2hlZXRzKTtcbiAgXG4gIC8vIENhbGN1bGF0ZSBwcmVzcyBwZXIgcGFyZW50XG4gIGNvbnN0IHByZXNzUGVyUGFyZW50ID0gTWF0aC5mbG9vcihwYXJlbnQudyAvIHByZXNzLncpICogTWF0aC5mbG9vcihwYXJlbnQuaCAvIHByZXNzLmgpO1xuICBjb25zdCBwYXJlbnRzID0gTWF0aC5jZWlsKHByZXNzU2hlZXRzIC8gcHJlc3NQZXJQYXJlbnQpO1xuXG4gIC8vIENhbGN1bGF0ZSBjb3N0c1xuICBjb25zdCBwbGF0ZXMgPSBjb2xvcnM7XG4gIGNvbnN0IHBhcGVyID0gcGFyZW50cyAqIEVYQ0VMX09GRlNFVF9DT05TVEFOVFMucGFyZW50Q29zdDtcbiAgY29uc3QgcGxhdGVzQyA9IHBsYXRlcyAqIEVYQ0VMX09GRlNFVF9DT05TVEFOVFMucGxhdGVDb3N0O1xuICBjb25zdCBta3JlYWR5ID0gRVhDRUxfT0ZGU0VUX0NPTlNUQU5UUy5tYWtlUmVhZHlTZXR1cCArIChFWENFTF9PRkZTRVRfQ09OU1RBTlRTLm1ha2VSZWFkeVNoZWV0cyAqIChFWENFTF9PRkZTRVRfQ09OU1RBTlRTLnBhcmVudENvc3QgLyBwcmVzc1BlclBhcmVudCkpO1xuICBjb25zdCBydW4gPSAocHJlc3NTaGVldHMgKiBzaWRlcykgKiAoRVhDRUxfT0ZGU0VUX0NPTlNUQU5UUy5ydW5QZXIxMDAwIC8gMTAwMCk7XG4gIFxuICAvLyBDYWxjdWxhdGUgY3V0dGluZyBvcGVyYXRpb25zXG4gIGNvbnN0IGNvbHMgPSBNYXRoLmZsb29yKHByZXNzLncgLyAocGllY2UudyArIDEpKTtcbiAgY29uc3Qgcm93cyA9IE1hdGguZmxvb3IocHJlc3MuaCAvIChwaWVjZS5oICsgMSkpO1xuICBjb25zdCBjdXRPcHMgPSAoY29scyAmJiByb3dzKSA/IDQgKyAoY29scyAtIDEpICsgY29scyAqIChyb3dzIC0gMSkgOiAwO1xuICBjb25zdCBjdXR0aW5nID0gY3V0T3BzICogRVhDRUxfT0ZGU0VUX0NPTlNUQU5UUy5jdXRPcFJhdGUgKiBwcmVzc1NoZWV0cztcbiAgXG4gIGNvbnN0IHRvdGFsID0gcGFwZXIgKyBwbGF0ZXNDICsgbWtyZWFkeSArIHJ1biArIGN1dHRpbmc7XG5cbiAgcmV0dXJuIHtcbiAgICBwcmVzc1BlclBhcmVudCxcbiAgICB1cHNQZXJQcmVzczogYmVzdFVwcyxcbiAgICBwcmVzc1NoZWV0cyxcbiAgICBwYXJlbnRzLFxuICAgIHBsYXRlcyxcbiAgICBwYXBlcixcbiAgICBwbGF0ZXNDLFxuICAgIG1rcmVhZHksXG4gICAgcnVuLFxuICAgIGN1dHRpbmcsXG4gICAgdG90YWxcbiAgfTtcbn1cblxuLy8gPT09IEV4Y2VsIEZvcm11bGEgVmFsaWRhdGlvbiA9PT1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUV4Y2VsRm9ybXVsYXMoKSB7XG4gIGNvbnNvbGUubG9nKCfwn5SNIFZhbGlkYXRpbmcgRXhjZWwgRm9ybXVsYXMuLi4nKTtcbiAgXG4gIC8vIFRlc3QgRGlnaXRhbCBDYWxjdWxhdGlvblxuICBjb25zdCBkaWdpdGFsVGVzdCA9IGV4Y2VsRGlnaXRhbENhbGN1bGF0aW9uKHtcbiAgICBxdHk6IDEwMDAsXG4gICAgcGllY2U6IHsgdzogNS41LCBoOiA5IH0sXG4gICAgc2lkZXM6IDIsXG4gICAgY29sb3JzRjogNFxuICB9KTtcbiAgXG4gIGNvbnNvbGUubG9nKCfwn5OxIERpZ2l0YWwgVGVzdCBSZXN1bHRzOicsIGRpZ2l0YWxUZXN0KTtcbiAgXG4gIC8vIFRlc3QgT2Zmc2V0IENhbGN1bGF0aW9uXG4gIGNvbnN0IG9mZnNldFRlc3QgPSBleGNlbE9mZnNldENhbGN1bGF0aW9uKHtcbiAgICBxdHk6IDMwMDAsXG4gICAgcGllY2U6IHsgdzogMjEsIGg6IDI5IH0sXG4gICAgc2lkZXM6IDIsXG4gICAgY29sb3JzRjogMlxuICB9KTtcbiAgXG4gIGNvbnNvbGUubG9nKCfwn5ao77iPIE9mZnNldCBUZXN0IFJlc3VsdHM6Jywgb2Zmc2V0VGVzdCk7XG4gIFxuICAvLyBWYWxpZGF0ZSBjb25zdGFudHMgYWxpZ25tZW50XG4gIGNvbnN0IGNvbnN0YW50c1ZhbGlkYXRpb24gPSB2YWxpZGF0ZVByaWNpbmdDb25zdGFudHMoXG4gICAgRVhDRUxfRElHSVRBTF9DT05TVEFOVFMsXG4gICAgRVhDRUxfT0ZGU0VUX0NPTlNUQU5UU1xuICApO1xuICBcbiAgaWYgKGNvbnN0YW50c1ZhbGlkYXRpb24uaXNWYWxpZCkge1xuICAgIGNvbnNvbGUubG9nKCfinIUgRXhjZWwgQ29uc3RhbnRzIFZhbGlkYXRpb246IFBBU1NFRCcpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUud2Fybign4pqg77iPIEV4Y2VsIENvbnN0YW50cyBWYWxpZGF0aW9uOiBGQUlMRUQnLCBjb25zdGFudHNWYWxpZGF0aW9uLmVycm9ycyk7XG4gIH1cbiAgXG4gIHJldHVybiB7IGRpZ2l0YWxUZXN0LCBvZmZzZXRUZXN0LCBjb25zdGFudHNWYWxpZGF0aW9uIH07XG59XG5cbi8vID09PSBDYWxjdWxhdGlvbiBBbGlnbm1lbnQgVmFsaWRhdGlvbiA9PT1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUNhbGN1bGF0aW9uQWxpZ25tZW50KFxuICBjb2RlUmVzdWx0OiBudW1iZXIsXG4gIGV4Y2VsUmVzdWx0OiBudW1iZXIsXG4gIHRvbGVyYW5jZTogbnVtYmVyID0gMC4wMVxuKTogYm9vbGVhbiB7XG4gIGNvbnN0IGRpZmZlcmVuY2UgPSBNYXRoLmFicyhjb2RlUmVzdWx0IC0gZXhjZWxSZXN1bHQpO1xuICBjb25zdCBpc0FsaWduZWQgPSBkaWZmZXJlbmNlIDw9IHRvbGVyYW5jZTtcbiAgXG4gIGlmICghaXNBbGlnbmVkKSB7XG4gICAgY29uc29sZS53YXJuKGDimqDvuI8gQ2FsY3VsYXRpb24gbWlzYWxpZ25tZW50IGRldGVjdGVkOmAsIHtcbiAgICAgIGNvZGVSZXN1bHQsXG4gICAgICBleGNlbFJlc3VsdCxcbiAgICAgIGRpZmZlcmVuY2UsXG4gICAgICB0b2xlcmFuY2VcbiAgICB9KTtcbiAgfVxuICBcbiAgcmV0dXJuIGlzQWxpZ25lZDtcbn1cblxuLy8gPT09IFByaWNpbmcgQ29uc3RhbnRzIFZhbGlkYXRpb24gPT09XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVQcmljaW5nQ29uc3RhbnRzKFxuICBkaWdpdGFsUHJpY2luZzogYW55LFxuICBvZmZzZXRQcmljaW5nOiBhbnlcbik6IHsgaXNWYWxpZDogYm9vbGVhbjsgZXJyb3JzOiBzdHJpbmdbXSB9IHtcbiAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuICBcbiAgLy8gVmFsaWRhdGUgRGlnaXRhbCBQcmljaW5nIChwZXJDbGljayBpcyBub3cgY2FsY3VsYXRlZCBkeW5hbWljYWxseSlcbiAgLy8gTm90ZTogcGVyQ2xpY2sgdmFsaWRhdGlvbiByZW1vdmVkIGFzIGl0J3Mgbm93IGNhbGN1bGF0ZWQgZHluYW1pY2FsbHlcbiAgaWYgKGRpZ2l0YWxQcmljaW5nLnBhcmVudFNoZWV0Q29zdCAhPT0gRVhDRUxfRElHSVRBTF9DT05TVEFOVFMucGFyZW50U2hlZXRDb3N0KSB7XG4gICAgZXJyb3JzLnB1c2goYERpZ2l0YWwgcGFyZW50U2hlZXRDb3N0IG1pc21hdGNoOiAke2RpZ2l0YWxQcmljaW5nLnBhcmVudFNoZWV0Q29zdH0gdnMgJHtFWENFTF9ESUdJVEFMX0NPTlNUQU5UUy5wYXJlbnRTaGVldENvc3R9YCk7XG4gIH1cbiAgaWYgKGRpZ2l0YWxQcmljaW5nLndhc3RlUGFyZW50cyAhPT0gRVhDRUxfRElHSVRBTF9DT05TVEFOVFMud2FzdGVQYXJlbnRzKSB7XG4gICAgZXJyb3JzLnB1c2goYERpZ2l0YWwgd2FzdGVQYXJlbnRzIG1pc21hdGNoOiAke2RpZ2l0YWxQcmljaW5nLndhc3RlUGFyZW50c30gdnMgJHtFWENFTF9ESUdJVEFMX0NPTlNUQU5UUy53YXN0ZVBhcmVudHN9YCk7XG4gIH1cbiAgXG4gIC8vIFZhbGlkYXRlIE9mZnNldCBQcmljaW5nXG4gIGlmIChvZmZzZXRQcmljaW5nLnBhcmVudENvc3QgIT09IEVYQ0VMX09GRlNFVF9DT05TVEFOVFMucGFyZW50Q29zdCkge1xuICAgIGVycm9ycy5wdXNoKGBPZmZzZXQgcGFyZW50Q29zdCBtaXNtYXRjaDogJHtvZmZzZXRQcmljaW5nLnBhcmVudENvc3R9IHZzICR7RVhDRUxfT0ZGU0VUX0NPTlNUQU5UUy5wYXJlbnRDb3N0fWApO1xuICB9XG4gIGlmIChvZmZzZXRQcmljaW5nLnBsYXRlQ29zdCAhPT0gRVhDRUxfT0ZGU0VUX0NPTlNUQU5UUy5wbGF0ZUNvc3QpIHtcbiAgICBlcnJvcnMucHVzaChgT2Zmc2V0IHBsYXRlQ29zdCBtaXNtYXRjaDogJHtvZmZzZXRQcmljaW5nLnBsYXRlQ29zdH0gdnMgJHtFWENFTF9PRkZTRVRfQ09OU1RBTlRTLnBsYXRlQ29zdH1gKTtcbiAgfVxuICBpZiAob2Zmc2V0UHJpY2luZy5tYWtlUmVhZHlTZXR1cCAhPT0gRVhDRUxfT0ZGU0VUX0NPTlNUQU5UUy5tYWtlUmVhZHlTZXR1cCkge1xuICAgIGVycm9ycy5wdXNoKGBPZmZzZXQgbWFrZVJlYWR5U2V0dXAgbWlzbWF0Y2g6ICR7b2Zmc2V0UHJpY2luZy5tYWtlUmVhZHlTZXR1cH0gdnMgJHtFWENFTF9PRkZTRVRfQ09OU1RBTlRTLm1ha2VSZWFkeVNldHVwfWApO1xuICB9XG4gIGlmIChvZmZzZXRQcmljaW5nLnJ1blBlcjEwMDAgIT09IEVYQ0VMX09GRlNFVF9DT05TVEFOVFMucnVuUGVyMTAwMCkge1xuICAgIGVycm9ycy5wdXNoKGBPZmZzZXQgcnVuUGVyMTAwMCBtaXNtYXRjaDogJHtvZmZzZXRQcmljaW5nLnJ1blBlcjEwMDB9IHZzICR7RVhDRUxfT0ZGU0VUX0NPTlNUQU5UUy5ydW5QZXIxMDAwfWApO1xuICB9XG4gIGlmIChvZmZzZXRQcmljaW5nLmN1dE9wUmF0ZSAhPT0gRVhDRUxfT0ZGU0VUX0NPTlNUQU5UUy5jdXRPcFJhdGUpIHtcbiAgICBlcnJvcnMucHVzaChgT2Zmc2V0IGN1dE9wUmF0ZSBtaXNtYXRjaDogJHtvZmZzZXRQcmljaW5nLmN1dE9wUmF0ZX0gdnMgJHtFWENFTF9PRkZTRVRfQ09OU1RBTlRTLmN1dE9wUmF0ZX1gKTtcbiAgfVxuICBcbiAgcmV0dXJuIHtcbiAgICBpc1ZhbGlkOiBlcnJvcnMubGVuZ3RoID09PSAwLFxuICAgIGVycm9yc1xuICB9O1xufVxuXG5cblxuIl0sIm5hbWVzIjpbIkVYQ0VMX0RJR0lUQUxfQ09OU1RBTlRTIiwicGFyZW50U2hlZXRDb3N0Iiwid2FzdGVQYXJlbnRzIiwiY2FsY3VsYXRlUGVyQ2xpY2siLCJzaGVldHMiLCJjdXRQY3MiLCJjb2xvcnNGIiwidG90YWxTaGVldHMiLCJjYXRlZ29yaXplZENvbG9ycyIsImJhc2VQZXJDbGljayIsIm11bHRpcGxpZXIiLCJFWENFTF9PRkZTRVRfQ09OU1RBTlRTIiwicGFyZW50Q29zdCIsInBsYXRlQ29zdCIsIm1ha2VSZWFkeVNldHVwIiwibWFrZVJlYWR5U2hlZXRzIiwicnVuUGVyMTAwMCIsImN1dE9wUmF0ZSIsImV4Y2VsRGlnaXRhbENhbGN1bGF0aW9uIiwicXR5IiwicGllY2UiLCJzaWRlcyIsImNvbG9yc0IiLCJwYXJlbnQiLCJ3IiwiaCIsImFsbG93Um90YXRlIiwicGFwZXJDb3N0UGVyU2hlZXQiLCJjb2xvcnMiLCJjYWxjdWxhdGVVcHNPcHRpb24xIiwic2hlZXRXIiwic2hlZXRIIiwicGllY2VXIiwicGllY2VIIiwiY29scyIsIk1hdGgiLCJmbG9vciIsInJvd3MiLCJjYWxjdWxhdGVVcHNPcHRpb24yIiwiZ2V0QmVzdFVwcyIsIm9wdGlvbjEiLCJvcHRpb24yIiwibWF4IiwiY2FsY3VsYXRlU2hlZXRzIiwicXVhbnRpdHkiLCJ1cHNQZXJTaGVldCIsImNlaWwiLCJjYWxjdWxhdGVQcmljZSIsImN1dFBpZWNlcyIsInBlckNsaWNrUmF0ZSIsInNoZWV0T3B0aW9ucyIsImxhYmVsIiwibWFwIiwib3B0aW9uIiwidXBzT3B0aW9uMSIsInVwc09wdGlvbjIiLCJ1cHNQZXJDdXRQaWVjZSIsInRvdGFsVXBzUGVyU2hlZXQiLCJlZmZlY3RpdmVQYXBlckNvc3QiLCJ1bmRlZmluZWQiLCJwYXBlciIsInByaWNlIiwidG90YWwiLCJjdXRQZXJQYXJlbnQiLCJ1cHNQZXJQYXJlbnQiLCJwYXJlbnRzIiwiY2xpY2tzIiwiZmlsdGVyIiwiQm9vbGVhbiIsImV4Y2VsT2Zmc2V0Q2FsY3VsYXRpb24iLCJjYWxjdWxhdGVXYXN0ZVNoZWV0cyIsIndhc3RlQmFzZSIsIndhc3RlU2hlZXRzIiwiY2FsY3VsYXRlUGxhdGVDb3N0IiwidW5pdFByaWNlIiwicGFwZXJDb3N0IiwicHJlc3MiLCJiZXN0VXBzIiwiRXJyb3IiLCJwcmVzc1NoZWV0cyIsInByZXNzUGVyUGFyZW50IiwicGxhdGVzIiwicGxhdGVzQyIsIm1rcmVhZHkiLCJydW4iLCJjdXRPcHMiLCJjdXR0aW5nIiwidXBzUGVyUHJlc3MiLCJ2YWxpZGF0ZUV4Y2VsRm9ybXVsYXMiLCJjb25zb2xlIiwibG9nIiwiZGlnaXRhbFRlc3QiLCJvZmZzZXRUZXN0IiwiY29uc3RhbnRzVmFsaWRhdGlvbiIsInZhbGlkYXRlUHJpY2luZ0NvbnN0YW50cyIsImlzVmFsaWQiLCJ3YXJuIiwiZXJyb3JzIiwidmFsaWRhdGVDYWxjdWxhdGlvbkFsaWdubWVudCIsImNvZGVSZXN1bHQiLCJleGNlbFJlc3VsdCIsInRvbGVyYW5jZSIsImRpZmZlcmVuY2UiLCJhYnMiLCJpc0FsaWduZWQiLCJkaWdpdGFsUHJpY2luZyIsIm9mZnNldFByaWNpbmciLCJwdXNoIiwibGVuZ3RoIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/excel-calculation.ts\n"));

/***/ })

});