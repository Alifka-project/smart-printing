"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(root)/create-quote/page",{

/***/ "(app-pages-browser)/./lib/dynamic-press-calculator.ts":
/*!*****************************************!*\
  !*** ./lib/dynamic-press-calculator.ts ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_CUTTING_CONSTRAINTS: () => (/* binding */ DEFAULT_CUTTING_CONSTRAINTS),\n/* harmony export */   calculateOptimalPressDimensions: () => (/* binding */ calculateOptimalPressDimensions),\n/* harmony export */   calculateVisualizationPressDimensions: () => (/* binding */ calculateVisualizationPressDimensions),\n/* harmony export */   getBestPressDimension: () => (/* binding */ getBestPressDimension),\n/* harmony export */   validatePressCalculations: () => (/* binding */ validatePressCalculations)\n/* harmony export */ });\n// Define Cm type locally since types module might not be available\n// === Dynamic Press Dimension Calculator ===\n// This module calculates optimal press dimensions based on product size\n// Following the Excel sheet logic for cutting operations\n// Units-table VLOOKUP (cumulative) in closed form - same as Excel\nconst unitPrice = (units)=>{\n    const u = Math.max(0, Math.floor(units));\n    if (u <= 10) return 50 * u;\n    if (u <= 20) return 60 * u - u * u; // 60u - u^2\n    return 40 * u;\n};\n// Default cutting constraints based on Excel analysis\nconst DEFAULT_CUTTING_CONSTRAINTS = {\n    parentWidth: 100,\n    parentHeight: 70,\n    minPressWidth: 20,\n    minPressHeight: 15,\n    maxPressWidth: 100,\n    maxPressHeight: 70,\n    cuttingMargin: 1.0,\n    gapBetweenPieces: 0.5 // 0.5cm gap between pieces\n};\n/**\n * Calculate optimal press dimensions based on product size\n * Following Excel sheet logic: press dimensions should maximize cutting efficiency\n */ function calculateOptimalPressDimensions(productDimensions) {\n    let constraints = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_CUTTING_CONSTRAINTS;\n    const { width: productWidth, height: productHeight } = productDimensions;\n    const { parentWidth, parentHeight, minPressWidth, minPressHeight, maxPressWidth, maxPressHeight, cuttingMargin, gapBetweenPieces } = constraints;\n    console.log('üîç Calculating optimal press dimensions for product:', productDimensions);\n    console.log('üìè Using constraints:', constraints);\n    const pressOptions = [];\n    // Calculate all possible press dimensions that fit within parent sheet\n    // with reasonable cutting margins\n    const stepSize = 5; // 5cm increments for press dimensions\n    for(let pressWidth = minPressWidth; pressWidth <= maxPressWidth; pressWidth += stepSize){\n        for(let pressHeight = minPressHeight; pressHeight <= maxPressHeight; pressHeight += stepSize){\n            // Check if press fits within parent sheet with margins\n            if (pressWidth + cuttingMargin <= parentWidth && pressHeight + cuttingMargin <= parentHeight) {\n                // Calculate how many pieces fit on this press sheet\n                const piecesPerPress = calculatePiecesPerPress(pressWidth, pressHeight, productWidth, productHeight, gapBetweenPieces);\n                // Calculate how many press sheets fit in parent sheet\n                const pressSheetsPerParent = calculatePressSheetsPerParent(parentWidth, parentHeight, pressWidth, pressHeight);\n                // Calculate total pieces per parent sheet\n                const piecesPerParent = piecesPerPress * pressSheetsPerParent;\n                // Calculate efficiency (percentage of parent sheet utilized)\n                const efficiency = piecesPerParent * productWidth * productHeight / (parentWidth * parentHeight) * 100;\n                if (piecesPerPress > 0 && pressSheetsPerParent > 0) {\n                    pressOptions.push({\n                        width: pressWidth,\n                        height: pressHeight,\n                        label: \"\".concat(pressWidth, \"\\xd7\").concat(pressHeight, \" cm\"),\n                        efficiency: Math.round(efficiency * 100) / 100,\n                        piecesPerPress,\n                        piecesPerParent\n                    });\n                }\n            }\n        }\n    }\n    // Sort by efficiency (highest first)\n    pressOptions.sort((a, b)=>b.efficiency - a.efficiency);\n    console.log('üìä Generated press options:', pressOptions.slice(0, 5)); // Log top 5 options\n    return pressOptions;\n}\n/**\n * Calculate how many product pieces fit on a press sheet\n * Following Excel formula: ROUNDDOWN((Sheet Width) / (width + gap), 0) √ó ROUNDDOWN((Sheet Height) / (height + gap), 0)\n */ function calculatePiecesPerPress(pressWidth, pressHeight, productWidth, productHeight, gap) {\n    // Option 1: Normal orientation\n    const cols1 = Math.floor(pressWidth / (productWidth + gap));\n    const rows1 = Math.floor(pressHeight / (productHeight + gap));\n    const pieces1 = cols1 * rows1;\n    // Option 2: Rotated orientation\n    const cols2 = Math.floor(pressWidth / (productHeight + gap));\n    const rows2 = Math.floor(pressHeight / (productWidth + gap));\n    const pieces2 = cols2 * rows2;\n    // Return the better option (Excel logic: IF(Option 1 > Option 2, Option 1, Option 2))\n    return Math.max(pieces1, pieces2);\n}\n/**\n * Calculate how many press sheets fit in parent sheet\n * Following Excel logic for cutting operations\n */ function calculatePressSheetsPerParent(parentWidth, parentHeight, pressWidth, pressHeight) {\n    // Calculate how many press sheets fit horizontally and vertically\n    const horizontalFit = Math.floor(parentWidth / pressWidth);\n    const verticalFit = Math.floor(parentHeight / pressHeight);\n    return horizontalFit * verticalFit;\n}\n/**\n * Get the best press dimension for a given product\n * Returns the most efficient option\n */ function getBestPressDimension(productDimensions) {\n    let constraints = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_CUTTING_CONSTRAINTS;\n    const options = calculateOptimalPressDimensions(productDimensions, constraints);\n    return options.length > 0 ? options[0] : null;\n}\n/**\n * Validate press dimensions against Excel examples\n * Test function to ensure calculations match Excel logic\n */ function validatePressCalculations() {\n    console.log('üß™ Validating press calculations against Excel examples...');\n    // Test case: Business card (9√ó5.5) should result in press around 40√ó20\n    const businessCardTest = getBestPressDimension({\n        width: 9,\n        height: 5.5\n    });\n    console.log('üì± Business card test result:', businessCardTest);\n    // Expected: Should be around 40√ó20 with good efficiency\n    const isValid = businessCardTest && businessCardTest.width >= 35 && businessCardTest.width <= 45 && businessCardTest.height >= 15 && businessCardTest.height <= 25;\n    if (isValid) {\n        console.log('‚úÖ Press calculation validation: PASSED');\n    } else {\n        console.warn('‚ö†Ô∏è Press calculation validation: FAILED');\n    }\n    return isValid;\n}\n/**\n * Calculate press dimensions specifically for visualization\n * Returns dimensions that work well for the cutting visualization\n * Uses EXACT SAME logic as Excel calculation (pickCheapestTotal + calcRowTotal)\n */ function calculateVisualizationPressDimensions(productDimensions, formData) {\n    var _formData_products_, _formData_products, _formData_products_1, _formData_products1, _formData_products_2, _formData_products2;\n    // Use product dimensions from form data if available\n    const productWidth = productDimensions.width;\n    const productHeight = productDimensions.height;\n    if (!productWidth || !productHeight) {\n        console.warn('‚ö†Ô∏è Missing product dimensions for press calculation');\n        return null;\n    }\n    console.log('üîç Calculating visualization press dimensions for:', productDimensions);\n    // Use EXACT SAME CUT_SIZE_CANDIDATES as Excel calculation\n    const cutSizeCandidates = [\n        {\n            parentW: 20,\n            parentH: 14,\n            cutPcs: 25,\n            label: \"20√ó14 / Cp25\"\n        },\n        {\n            parentW: 20,\n            parentH: 17.5,\n            cutPcs: 20,\n            label: \"20√ó17.5 / Cp20\"\n        },\n        {\n            parentW: 23,\n            parentH: 14,\n            cutPcs: 21,\n            label: \"23√ó14 / Cp21\"\n        },\n        {\n            parentW: 23,\n            parentH: 16.5,\n            cutPcs: 18,\n            label: \"23√ó16.5 / Cp18\"\n        },\n        {\n            parentW: 23,\n            parentH: 20,\n            cutPcs: 15,\n            label: \"23√ó20 / Cp15\"\n        },\n        {\n            parentW: 25,\n            parentH: 14,\n            cutPcs: 20,\n            label: \"25√ó14 / Cp20\"\n        },\n        {\n            parentW: 25,\n            parentH: 17.5,\n            cutPcs: 16,\n            label: \"25√ó17.5 / Cp16\"\n        },\n        {\n            parentW: 25,\n            parentH: 20,\n            cutPcs: 14,\n            label: \"25√ó20 / Cp14\"\n        },\n        {\n            parentW: 25,\n            parentH: 23,\n            cutPcs: 12,\n            label: \"25√ó23 / Cp12\"\n        },\n        {\n            parentW: 28,\n            parentH: 14,\n            cutPcs: 17,\n            label: \"28√ó14 / Cp17\"\n        },\n        {\n            parentW: 30,\n            parentH: 14,\n            cutPcs: 16,\n            label: \"30√ó14 / Cp16\"\n        },\n        {\n            parentW: 30,\n            parentH: 17.5,\n            cutPcs: 13,\n            label: \"30√ó17.5 / Cp13\"\n        },\n        {\n            parentW: 30,\n            parentH: 20,\n            cutPcs: 11,\n            label: \"30√ó20 / Cp11\"\n        },\n        {\n            parentW: 30,\n            parentH: 23,\n            cutPcs: 9,\n            label: \"30√ó23 / Cp9\"\n        },\n        {\n            parentW: 35,\n            parentH: 14,\n            cutPcs: 14,\n            label: \"35√ó14 / Cp14\"\n        },\n        {\n            parentW: 35,\n            parentH: 17.5,\n            cutPcs: 11,\n            label: \"35√ó17.5 / Cp11\"\n        },\n        {\n            parentW: 35,\n            parentH: 20,\n            cutPcs: 10,\n            label: \"35√ó20 / Cp10\"\n        },\n        {\n            parentW: 35,\n            parentH: 23,\n            cutPcs: 8,\n            label: \"35√ó23 / Cp8\"\n        },\n        {\n            parentW: 35,\n            parentH: 25,\n            cutPcs: 7,\n            label: \"35√ó25 / Cp7\"\n        },\n        {\n            parentW: 40,\n            parentH: 14,\n            cutPcs: 12,\n            label: \"40√ó14 / Cp12\"\n        },\n        {\n            parentW: 40,\n            parentH: 17.5,\n            cutPcs: 10,\n            label: \"40√ó17.5 / Cp10\"\n        },\n        {\n            parentW: 40,\n            parentH: 20,\n            cutPcs: 8,\n            label: \"40√ó20 / Cp8\"\n        },\n        {\n            parentW: 40,\n            parentH: 23,\n            cutPcs: 7,\n            label: \"40√ó23 / Cp7\"\n        },\n        {\n            parentW: 40,\n            parentH: 25,\n            cutPcs: 6,\n            label: \"40√ó25 / Cp6\"\n        },\n        {\n            parentW: 40,\n            parentH: 30,\n            cutPcs: 5,\n            label: \"40√ó30 / Cp5\"\n        },\n        {\n            parentW: 40,\n            parentH: 35,\n            cutPcs: 4,\n            label: \"40√ó35 / Cp4\"\n        },\n        {\n            parentW: 45,\n            parentH: 20,\n            cutPcs: 7,\n            label: \"45√ó20 / Cp7\"\n        },\n        {\n            parentW: 45,\n            parentH: 25,\n            cutPcs: 5,\n            label: \"45√ó25 / Cp5\"\n        },\n        {\n            parentW: 45,\n            parentH: 30,\n            cutPcs: 4,\n            label: \"45√ó30 / Cp4\"\n        },\n        {\n            parentW: 45,\n            parentH: 35,\n            cutPcs: 3,\n            label: \"45√ó35 / Cp3\"\n        },\n        {\n            parentW: 50,\n            parentH: 20,\n            cutPcs: 6,\n            label: \"50√ó20 / Cp6\"\n        },\n        {\n            parentW: 50,\n            parentH: 25,\n            cutPcs: 5,\n            label: \"50√ó25 / Cp5\"\n        },\n        {\n            parentW: 50,\n            parentH: 30,\n            cutPcs: 4,\n            label: \"50√ó30 / Cp4\"\n        },\n        {\n            parentW: 50,\n            parentH: 35,\n            cutPcs: 4,\n            label: \"50√ó35 / Cp4\"\n        }\n    ];\n    // Use EXACT SAME logic as Excel calculation\n    // Get form data values for accurate calculation\n    const sides = (formData === null || formData === void 0 ? void 0 : (_formData_products = formData.products) === null || _formData_products === void 0 ? void 0 : (_formData_products_ = _formData_products[0]) === null || _formData_products_ === void 0 ? void 0 : _formData_products_.sides) === \"1\" ? 1 : 2;\n    const colours = (formData === null || formData === void 0 ? void 0 : (_formData_products1 = formData.products) === null || _formData_products1 === void 0 ? void 0 : (_formData_products_1 = _formData_products1[0]) === null || _formData_products_1 === void 0 ? void 0 : _formData_products_1.colours) || 4;\n    const qty = (formData === null || formData === void 0 ? void 0 : (_formData_products2 = formData.products) === null || _formData_products2 === void 0 ? void 0 : (_formData_products_2 = _formData_products2[0]) === null || _formData_products_2 === void 0 ? void 0 : _formData_products_2.quantity) || 1000;\n    const paperCostPerSheet = 1; // Standard paper cost for visualization\n    // Create base object for calcRowTotal\n    const base = {\n        pieceW: productWidth,\n        pieceH: productHeight,\n        qty: qty,\n        sides: sides,\n        colours: colours,\n        paperCostPerSheet: paperCostPerSheet\n    };\n    // Use EXACT SAME pickCheapestTotal logic\n    const rows = cutSizeCandidates.map((candidate)=>calcRowTotal(base, candidate));\n    rows.sort((a, b)=>a.total - b.total);\n    const cheapestRow = rows[0]; // cheapest row\n    if (cheapestRow) {\n        console.log('üéØ Best cutting size found (Excel logic):', cheapestRow);\n        // Calculate efficiency percentage\n        const efficiency = cheapestRow.upsPerSht * productWidth * productHeight / (cheapestRow.parentW * cheapestRow.parentH) * 100;\n        return {\n            width: cheapestRow.parentW,\n            height: cheapestRow.parentH,\n            label: cheapestRow.label || \"\".concat(cheapestRow.parentW, \"\\xd7\").concat(cheapestRow.parentH, \" cm\"),\n            efficiency: Math.round(efficiency * 100) / 100,\n            piecesPerPress: cheapestRow.noOfUps,\n            piecesPerParent: cheapestRow.cutPcs\n        };\n    }\n    // Fallback: use parent sheet size for very large products\n    console.log('‚ö†Ô∏è No optimal cutting size found, using parent sheet size');\n    return {\n        width: 100,\n        height: 70,\n        label: \"100√ó70 cm (Parent Sheet)\",\n        efficiency: 100,\n        piecesPerPress: 1,\n        piecesPerParent: 1\n    };\n}\n/**\n * EXACT COPY of calcRowTotal from Step4Operational.tsx\n * This ensures the visualization uses the same calculation logic\n */ function calcRowTotal(base, row) {\n    const { pieceW, pieceH, qty, sides, colours, paperCostPerSheet } = base;\n    const { parentW, parentH, cutPcs } = row;\n    // 1) Imposition (Option1/2)\n    const opt1 = Math.floor(parentW / (pieceH + 1)) * Math.floor(parentH / (pieceW + 1));\n    const opt2 = Math.floor(parentW / (pieceW + 1)) * Math.floor(parentH / (pieceH + 1));\n    const noOfUps = Math.max(opt1, opt2);\n    // 2) Odd/even rule (IF(Sides=1, TRUE, ISEVEN(No. of ups)))\n    const oddEven = sides === 1 ? true : noOfUps % 2 === 0;\n    // 3) Ups/sheet; 4) Waste; 5) Sheets\n    const upsPerSht = noOfUps * cutPcs;\n    const wasteSheets = Math.ceil((parentW > 50 ? 120 : 100) / cutPcs);\n    const sheets = upsPerSht === 0 ? 0 : Math.ceil(qty / upsPerSht + wasteSheets);\n    // 6) Paper cost\n    const paperCost = sheets * paperCostPerSheet;\n    // 7) Units ‚Üí 8) unit price\n    const coreUnits = Math.ceil(sheets * cutPcs * colours * sides / 1000);\n    const baseUnits = Math.max(colours, coreUnits);\n    const units = oddEven ? baseUnits : baseUnits * 2;\n    const unit_price = unitPrice(units);\n    // 9) Plate\n    const platePerSide = (parentW > 54 ? 50 : 20) * colours;\n    const plateTotal = platePerSide * sides;\n    // 10) Total\n    const total = sheets === 0 ? 0 : unit_price + paperCost + plateTotal;\n    return {\n        ...row,\n        noOfUps,\n        upsPerSht,\n        wasteSheets,\n        sheets,\n        paperCost,\n        units,\n        unit_price,\n        platePerSide,\n        plateTotal,\n        total\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9keW5hbWljLXByZXNzLWNhbGN1bGF0b3IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxtRUFBbUU7QUFHbkUsNkNBQTZDO0FBQzdDLHdFQUF3RTtBQUN4RSx5REFBeUQ7QUFFekQsa0VBQWtFO0FBQ2xFLE1BQU1BLFlBQVksQ0FBQ0M7SUFDakIsTUFBTUMsSUFBSUMsS0FBS0MsR0FBRyxDQUFDLEdBQUdELEtBQUtFLEtBQUssQ0FBQ0o7SUFDakMsSUFBSUMsS0FBSyxJQUFJLE9BQU8sS0FBS0E7SUFDekIsSUFBSUEsS0FBSyxJQUFJLE9BQU8sS0FBS0EsSUFBSUEsSUFBSUEsR0FBRyxZQUFZO0lBQ2hELE9BQU8sS0FBS0E7QUFDZDtBQTJCQSxzREFBc0Q7QUFDL0MsTUFBTUksOEJBQWtEO0lBQzdEQyxhQUFhO0lBQ2JDLGNBQWM7SUFDZEMsZUFBZTtJQUNmQyxnQkFBZ0I7SUFDaEJDLGVBQWU7SUFDZkMsZ0JBQWdCO0lBQ2hCQyxlQUFlO0lBQ2ZDLGtCQUFrQixJQUFJLDJCQUEyQjtBQUNuRCxFQUFFO0FBRUY7OztDQUdDLEdBQ00sU0FBU0MsZ0NBQ2RDLGlCQUFvQztRQUNwQ0MsY0FBQUEsaUVBQWtDWDtJQUVsQyxNQUFNLEVBQUVZLE9BQU9DLFlBQVksRUFBRUMsUUFBUUMsYUFBYSxFQUFFLEdBQUdMO0lBQ3ZELE1BQU0sRUFDSlQsV0FBVyxFQUNYQyxZQUFZLEVBQ1pDLGFBQWEsRUFDYkMsY0FBYyxFQUNkQyxhQUFhLEVBQ2JDLGNBQWMsRUFDZEMsYUFBYSxFQUNiQyxnQkFBZ0IsRUFDakIsR0FBR0c7SUFFSkssUUFBUUMsR0FBRyxDQUFDLHdEQUF3RFA7SUFDcEVNLFFBQVFDLEdBQUcsQ0FBQyx5QkFBeUJOO0lBRXJDLE1BQU1PLGVBQWlDLEVBQUU7SUFFekMsdUVBQXVFO0lBQ3ZFLGtDQUFrQztJQUNsQyxNQUFNQyxXQUFXLEdBQUcsc0NBQXNDO0lBRTFELElBQUssSUFBSUMsYUFBYWpCLGVBQWVpQixj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U0FBVXZCLFNBQVNHLFVBQVVGLFFBQVM7SUFDbEUsTUFBTTBCLFlBQVl0RixLQUFLQyxHQUFHLENBQUM2RCxTQUFTdUI7SUFDcEMsTUFBTXZGLFFBQVlrRixVQUFVTSxZQUFZQSxZQUFZO0lBQ3BELE1BQU1DLGFBQWExRixVQUFVQztJQUU3QixXQUFXO0lBQ1gsTUFBTTBGLGVBQWUsQ0FBQy9CLFVBQVUsS0FBSyxLQUFLLEVBQUMsSUFBS0s7SUFDaEQsTUFBTTJCLGFBQWVELGVBQWU1QjtJQUVwQyxZQUFZO0lBQ1osTUFBTWEsUUFBUVUsV0FBVyxJQUFJLElBQUlJLGFBQWFILFlBQVlLO0lBRTFELE9BQU87UUFBRSxHQUFHWixHQUFHO1FBQUVEO1FBQVNEO1FBQVdNO1FBQWFFO1FBQVFDO1FBQVd0RjtRQUFPeUY7UUFBWUM7UUFBY0M7UUFBWWhCO0lBQU07QUFDMUgiLCJzb3VyY2VzIjpbIi9Vc2Vycy9BbGlma2FfUm9vc3Nlby9EZXNrdG9wL1Byb2plY3QvU21hcnQtcHJpbnRpbmctdXBkYXRlL2xpYi9keW5hbWljLXByZXNzLWNhbGN1bGF0b3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRGVmaW5lIENtIHR5cGUgbG9jYWxseSBzaW5jZSB0eXBlcyBtb2R1bGUgbWlnaHQgbm90IGJlIGF2YWlsYWJsZVxudHlwZSBDbSA9IG51bWJlcjtcblxuLy8gPT09IER5bmFtaWMgUHJlc3MgRGltZW5zaW9uIENhbGN1bGF0b3IgPT09XG4vLyBUaGlzIG1vZHVsZSBjYWxjdWxhdGVzIG9wdGltYWwgcHJlc3MgZGltZW5zaW9ucyBiYXNlZCBvbiBwcm9kdWN0IHNpemVcbi8vIEZvbGxvd2luZyB0aGUgRXhjZWwgc2hlZXQgbG9naWMgZm9yIGN1dHRpbmcgb3BlcmF0aW9uc1xuXG4vLyBVbml0cy10YWJsZSBWTE9PS1VQIChjdW11bGF0aXZlKSBpbiBjbG9zZWQgZm9ybSAtIHNhbWUgYXMgRXhjZWxcbmNvbnN0IHVuaXRQcmljZSA9ICh1bml0czogbnVtYmVyKSA9PiB7XG4gIGNvbnN0IHUgPSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKHVuaXRzKSk7XG4gIGlmICh1IDw9IDEwKSByZXR1cm4gNTAgKiB1O1xuICBpZiAodSA8PSAyMCkgcmV0dXJuIDYwICogdSAtIHUgKiB1OyAvLyA2MHUgLSB1XjJcbiAgcmV0dXJuIDQwICogdTtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJlc3NEaW1lbnNpb24ge1xuICB3aWR0aDogQ207XG4gIGhlaWdodDogQ207XG4gIGxhYmVsOiBzdHJpbmc7XG4gIGVmZmljaWVuY3k6IG51bWJlcjsgLy8gUGVyY2VudGFnZSBvZiBwYXJlbnQgc2hlZXQgdXRpbGl6ZWRcbiAgcGllY2VzUGVyUHJlc3M6IG51bWJlcjtcbiAgcGllY2VzUGVyUGFyZW50OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvZHVjdERpbWVuc2lvbnMge1xuICB3aWR0aDogQ207XG4gIGhlaWdodDogQ207XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3V0dGluZ0NvbnN0cmFpbnRzIHtcbiAgcGFyZW50V2lkdGg6IENtO1xuICBwYXJlbnRIZWlnaHQ6IENtO1xuICBtaW5QcmVzc1dpZHRoOiBDbTtcbiAgbWluUHJlc3NIZWlnaHQ6IENtO1xuICBtYXhQcmVzc1dpZHRoOiBDbTtcbiAgbWF4UHJlc3NIZWlnaHQ6IENtO1xuICBjdXR0aW5nTWFyZ2luOiBDbTsgLy8gTWFyZ2luIGZvciBjdXR0aW5nIG9wZXJhdGlvbnNcbiAgZ2FwQmV0d2VlblBpZWNlczogQ207IC8vIEdhcCBiZXR3ZWVuIHByb2R1Y3QgcGllY2VzXG59XG5cbi8vIERlZmF1bHQgY3V0dGluZyBjb25zdHJhaW50cyBiYXNlZCBvbiBFeGNlbCBhbmFseXNpc1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfQ1VUVElOR19DT05TVFJBSU5UUzogQ3V0dGluZ0NvbnN0cmFpbnRzID0ge1xuICBwYXJlbnRXaWR0aDogMTAwLFxuICBwYXJlbnRIZWlnaHQ6IDcwLFxuICBtaW5QcmVzc1dpZHRoOiAyMCxcbiAgbWluUHJlc3NIZWlnaHQ6IDE1LFxuICBtYXhQcmVzc1dpZHRoOiAxMDAsXG4gIG1heFByZXNzSGVpZ2h0OiA3MCxcbiAgY3V0dGluZ01hcmdpbjogMS4wLCAvLyAxY20gbWFyZ2luIGZvciBjdXR0aW5nIG9wZXJhdGlvbnNcbiAgZ2FwQmV0d2VlblBpZWNlczogMC41IC8vIDAuNWNtIGdhcCBiZXR3ZWVuIHBpZWNlc1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgb3B0aW1hbCBwcmVzcyBkaW1lbnNpb25zIGJhc2VkIG9uIHByb2R1Y3Qgc2l6ZVxuICogRm9sbG93aW5nIEV4Y2VsIHNoZWV0IGxvZ2ljOiBwcmVzcyBkaW1lbnNpb25zIHNob3VsZCBtYXhpbWl6ZSBjdXR0aW5nIGVmZmljaWVuY3lcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZU9wdGltYWxQcmVzc0RpbWVuc2lvbnMoXG4gIHByb2R1Y3REaW1lbnNpb25zOiBQcm9kdWN0RGltZW5zaW9ucyxcbiAgY29uc3RyYWludHM6IEN1dHRpbmdDb25zdHJhaW50cyA9IERFRkFVTFRfQ1VUVElOR19DT05TVFJBSU5UU1xuKTogUHJlc3NEaW1lbnNpb25bXSB7XG4gIGNvbnN0IHsgd2lkdGg6IHByb2R1Y3RXaWR0aCwgaGVpZ2h0OiBwcm9kdWN0SGVpZ2h0IH0gPSBwcm9kdWN0RGltZW5zaW9ucztcbiAgY29uc3QgeyBcbiAgICBwYXJlbnRXaWR0aCwgXG4gICAgcGFyZW50SGVpZ2h0LCBcbiAgICBtaW5QcmVzc1dpZHRoLCBcbiAgICBtaW5QcmVzc0hlaWdodCwgXG4gICAgbWF4UHJlc3NXaWR0aCwgXG4gICAgbWF4UHJlc3NIZWlnaHQsXG4gICAgY3V0dGluZ01hcmdpbixcbiAgICBnYXBCZXR3ZWVuUGllY2VzXG4gIH0gPSBjb25zdHJhaW50cztcblxuICBjb25zb2xlLmxvZygn8J+UjSBDYWxjdWxhdGluZyBvcHRpbWFsIHByZXNzIGRpbWVuc2lvbnMgZm9yIHByb2R1Y3Q6JywgcHJvZHVjdERpbWVuc2lvbnMpO1xuICBjb25zb2xlLmxvZygn8J+TjyBVc2luZyBjb25zdHJhaW50czonLCBjb25zdHJhaW50cyk7XG5cbiAgY29uc3QgcHJlc3NPcHRpb25zOiBQcmVzc0RpbWVuc2lvbltdID0gW107XG5cbiAgLy8gQ2FsY3VsYXRlIGFsbCBwb3NzaWJsZSBwcmVzcyBkaW1lbnNpb25zIHRoYXQgZml0IHdpdGhpbiBwYXJlbnQgc2hlZXRcbiAgLy8gd2l0aCByZWFzb25hYmxlIGN1dHRpbmcgbWFyZ2luc1xuICBjb25zdCBzdGVwU2l6ZSA9IDU7IC8vIDVjbSBpbmNyZW1lbnRzIGZvciBwcmVzcyBkaW1lbnNpb25zXG4gIFxuICBmb3IgKGxldCBwcmVzc1dpZHRoID0gbWluUHJlc3NXaWR0aDsgcHJlc3NXaWR0aCA8PSBtYXhQcmVzc1dpZHRoOyBwcmVzc1dpZHRoICs9IHN0ZXBTaXplKSB7XG4gICAgZm9yIChsZXQgcHJlc3NIZWlnaHQgPSBtaW5QcmVzc0hlaWdodDsgcHJlc3NIZWlnaHQgPD0gbWF4UHJlc3NIZWlnaHQ7IHByZXNzSGVpZ2h0ICs9IHN0ZXBTaXplKSB7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHByZXNzIGZpdHMgd2l0aGluIHBhcmVudCBzaGVldCB3aXRoIG1hcmdpbnNcbiAgICAgIGlmIChwcmVzc1dpZHRoICsgY3V0dGluZ01hcmdpbiA8PSBwYXJlbnRXaWR0aCAmJiBcbiAgICAgICAgICBwcmVzc0hlaWdodCArIGN1dHRpbmdNYXJnaW4gPD0gcGFyZW50SGVpZ2h0KSB7XG4gICAgICAgIFxuICAgICAgICAvLyBDYWxjdWxhdGUgaG93IG1hbnkgcGllY2VzIGZpdCBvbiB0aGlzIHByZXNzIHNoZWV0XG4gICAgICAgIGNvbnN0IHBpZWNlc1BlclByZXNzID0gY2FsY3VsYXRlUGllY2VzUGVyUHJlc3MoXG4gICAgICAgICAgcHJlc3NXaWR0aCwgXG4gICAgICAgICAgcHJlc3NIZWlnaHQsIFxuICAgICAgICAgIHByb2R1Y3RXaWR0aCwgXG4gICAgICAgICAgcHJvZHVjdEhlaWdodCwgXG4gICAgICAgICAgZ2FwQmV0d2VlblBpZWNlc1xuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGhvdyBtYW55IHByZXNzIHNoZWV0cyBmaXQgaW4gcGFyZW50IHNoZWV0XG4gICAgICAgIGNvbnN0IHByZXNzU2hlZXRzUGVyUGFyZW50ID0gY2FsY3VsYXRlUHJlc3NTaGVldHNQZXJQYXJlbnQoXG4gICAgICAgICAgcGFyZW50V2lkdGgsIFxuICAgICAgICAgIHBhcmVudEhlaWdodCwgXG4gICAgICAgICAgcHJlc3NXaWR0aCwgXG4gICAgICAgICAgcHJlc3NIZWlnaHRcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0b3RhbCBwaWVjZXMgcGVyIHBhcmVudCBzaGVldFxuICAgICAgICBjb25zdCBwaWVjZXNQZXJQYXJlbnQgPSBwaWVjZXNQZXJQcmVzcyAqIHByZXNzU2hlZXRzUGVyUGFyZW50O1xuICAgICAgICBcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGVmZmljaWVuY3kgKHBlcmNlbnRhZ2Ugb2YgcGFyZW50IHNoZWV0IHV0aWxpemVkKVxuICAgICAgICBjb25zdCBlZmZpY2llbmN5ID0gKHBpZWNlc1BlclBhcmVudCAqIHByb2R1Y3RXaWR0aCAqIHByb2R1Y3RIZWlnaHQpIC8gXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChwYXJlbnRXaWR0aCAqIHBhcmVudEhlaWdodCkgKiAxMDA7XG4gICAgICAgIFxuICAgICAgICBpZiAocGllY2VzUGVyUHJlc3MgPiAwICYmIHByZXNzU2hlZXRzUGVyUGFyZW50ID4gMCkge1xuICAgICAgICAgIHByZXNzT3B0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHdpZHRoOiBwcmVzc1dpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBwcmVzc0hlaWdodCxcbiAgICAgICAgICAgIGxhYmVsOiBgJHtwcmVzc1dpZHRofcOXJHtwcmVzc0hlaWdodH0gY21gLFxuICAgICAgICAgICAgZWZmaWNpZW5jeTogTWF0aC5yb3VuZChlZmZpY2llbmN5ICogMTAwKSAvIDEwMCxcbiAgICAgICAgICAgIHBpZWNlc1BlclByZXNzLFxuICAgICAgICAgICAgcGllY2VzUGVyUGFyZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBTb3J0IGJ5IGVmZmljaWVuY3kgKGhpZ2hlc3QgZmlyc3QpXG4gIHByZXNzT3B0aW9ucy5zb3J0KChhLCBiKSA9PiBiLmVmZmljaWVuY3kgLSBhLmVmZmljaWVuY3kpO1xuXG4gIGNvbnNvbGUubG9nKCfwn5OKIEdlbmVyYXRlZCBwcmVzcyBvcHRpb25zOicsIHByZXNzT3B0aW9ucy5zbGljZSgwLCA1KSk7IC8vIExvZyB0b3AgNSBvcHRpb25zXG5cbiAgcmV0dXJuIHByZXNzT3B0aW9ucztcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgaG93IG1hbnkgcHJvZHVjdCBwaWVjZXMgZml0IG9uIGEgcHJlc3Mgc2hlZXRcbiAqIEZvbGxvd2luZyBFeGNlbCBmb3JtdWxhOiBST1VORERPV04oKFNoZWV0IFdpZHRoKSAvICh3aWR0aCArIGdhcCksIDApIMOXIFJPVU5ERE9XTigoU2hlZXQgSGVpZ2h0KSAvIChoZWlnaHQgKyBnYXApLCAwKVxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVQaWVjZXNQZXJQcmVzcyhcbiAgcHJlc3NXaWR0aDogQ20sXG4gIHByZXNzSGVpZ2h0OiBDbSxcbiAgcHJvZHVjdFdpZHRoOiBDbSxcbiAgcHJvZHVjdEhlaWdodDogQ20sXG4gIGdhcDogQ21cbik6IG51bWJlciB7XG4gIC8vIE9wdGlvbiAxOiBOb3JtYWwgb3JpZW50YXRpb25cbiAgY29uc3QgY29sczEgPSBNYXRoLmZsb29yKHByZXNzV2lkdGggLyAocHJvZHVjdFdpZHRoICsgZ2FwKSk7XG4gIGNvbnN0IHJvd3MxID0gTWF0aC5mbG9vcihwcmVzc0hlaWdodCAvIChwcm9kdWN0SGVpZ2h0ICsgZ2FwKSk7XG4gIGNvbnN0IHBpZWNlczEgPSBjb2xzMSAqIHJvd3MxO1xuXG4gIC8vIE9wdGlvbiAyOiBSb3RhdGVkIG9yaWVudGF0aW9uXG4gIGNvbnN0IGNvbHMyID0gTWF0aC5mbG9vcihwcmVzc1dpZHRoIC8gKHByb2R1Y3RIZWlnaHQgKyBnYXApKTtcbiAgY29uc3Qgcm93czIgPSBNYXRoLmZsb29yKHByZXNzSGVpZ2h0IC8gKHByb2R1Y3RXaWR0aCArIGdhcCkpO1xuICBjb25zdCBwaWVjZXMyID0gY29sczIgKiByb3dzMjtcblxuICAvLyBSZXR1cm4gdGhlIGJldHRlciBvcHRpb24gKEV4Y2VsIGxvZ2ljOiBJRihPcHRpb24gMSA+IE9wdGlvbiAyLCBPcHRpb24gMSwgT3B0aW9uIDIpKVxuICByZXR1cm4gTWF0aC5tYXgocGllY2VzMSwgcGllY2VzMik7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGhvdyBtYW55IHByZXNzIHNoZWV0cyBmaXQgaW4gcGFyZW50IHNoZWV0XG4gKiBGb2xsb3dpbmcgRXhjZWwgbG9naWMgZm9yIGN1dHRpbmcgb3BlcmF0aW9uc1xuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVQcmVzc1NoZWV0c1BlclBhcmVudChcbiAgcGFyZW50V2lkdGg6IENtLFxuICBwYXJlbnRIZWlnaHQ6IENtLFxuICBwcmVzc1dpZHRoOiBDbSxcbiAgcHJlc3NIZWlnaHQ6IENtXG4pOiBudW1iZXIge1xuICAvLyBDYWxjdWxhdGUgaG93IG1hbnkgcHJlc3Mgc2hlZXRzIGZpdCBob3Jpem9udGFsbHkgYW5kIHZlcnRpY2FsbHlcbiAgY29uc3QgaG9yaXpvbnRhbEZpdCA9IE1hdGguZmxvb3IocGFyZW50V2lkdGggLyBwcmVzc1dpZHRoKTtcbiAgY29uc3QgdmVydGljYWxGaXQgPSBNYXRoLmZsb29yKHBhcmVudEhlaWdodCAvIHByZXNzSGVpZ2h0KTtcbiAgXG4gIHJldHVybiBob3Jpem9udGFsRml0ICogdmVydGljYWxGaXQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSBiZXN0IHByZXNzIGRpbWVuc2lvbiBmb3IgYSBnaXZlbiBwcm9kdWN0XG4gKiBSZXR1cm5zIHRoZSBtb3N0IGVmZmljaWVudCBvcHRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJlc3RQcmVzc0RpbWVuc2lvbihcbiAgcHJvZHVjdERpbWVuc2lvbnM6IFByb2R1Y3REaW1lbnNpb25zLFxuICBjb25zdHJhaW50czogQ3V0dGluZ0NvbnN0cmFpbnRzID0gREVGQVVMVF9DVVRUSU5HX0NPTlNUUkFJTlRTXG4pOiBQcmVzc0RpbWVuc2lvbiB8IG51bGwge1xuICBjb25zdCBvcHRpb25zID0gY2FsY3VsYXRlT3B0aW1hbFByZXNzRGltZW5zaW9ucyhwcm9kdWN0RGltZW5zaW9ucywgY29uc3RyYWludHMpO1xuICByZXR1cm4gb3B0aW9ucy5sZW5ndGggPiAwID8gb3B0aW9uc1swXSA6IG51bGw7XG59XG5cbi8qKlxuICogVmFsaWRhdGUgcHJlc3MgZGltZW5zaW9ucyBhZ2FpbnN0IEV4Y2VsIGV4YW1wbGVzXG4gKiBUZXN0IGZ1bmN0aW9uIHRvIGVuc3VyZSBjYWxjdWxhdGlvbnMgbWF0Y2ggRXhjZWwgbG9naWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUHJlc3NDYWxjdWxhdGlvbnMoKTogYm9vbGVhbiB7XG4gIGNvbnNvbGUubG9nKCfwn6eqIFZhbGlkYXRpbmcgcHJlc3MgY2FsY3VsYXRpb25zIGFnYWluc3QgRXhjZWwgZXhhbXBsZXMuLi4nKTtcbiAgXG4gIC8vIFRlc3QgY2FzZTogQnVzaW5lc3MgY2FyZCAoOcOXNS41KSBzaG91bGQgcmVzdWx0IGluIHByZXNzIGFyb3VuZCA0MMOXMjBcbiAgY29uc3QgYnVzaW5lc3NDYXJkVGVzdCA9IGdldEJlc3RQcmVzc0RpbWVuc2lvbih7IHdpZHRoOiA5LCBoZWlnaHQ6IDUuNSB9KTtcbiAgXG4gIGNvbnNvbGUubG9nKCfwn5OxIEJ1c2luZXNzIGNhcmQgdGVzdCByZXN1bHQ6JywgYnVzaW5lc3NDYXJkVGVzdCk7XG4gIFxuICAvLyBFeHBlY3RlZDogU2hvdWxkIGJlIGFyb3VuZCA0MMOXMjAgd2l0aCBnb29kIGVmZmljaWVuY3lcbiAgY29uc3QgaXNWYWxpZCA9IGJ1c2luZXNzQ2FyZFRlc3QgJiYgXG4gICAgICAgICAgICAgICAgIGJ1c2luZXNzQ2FyZFRlc3Qud2lkdGggPj0gMzUgJiYgXG4gICAgICAgICAgICAgICAgIGJ1c2luZXNzQ2FyZFRlc3Qud2lkdGggPD0gNDUgJiZcbiAgICAgICAgICAgICAgICAgYnVzaW5lc3NDYXJkVGVzdC5oZWlnaHQgPj0gMTUgJiYgXG4gICAgICAgICAgICAgICAgIGJ1c2luZXNzQ2FyZFRlc3QuaGVpZ2h0IDw9IDI1O1xuICBcbiAgaWYgKGlzVmFsaWQpIHtcbiAgICBjb25zb2xlLmxvZygn4pyFIFByZXNzIGNhbGN1bGF0aW9uIHZhbGlkYXRpb246IFBBU1NFRCcpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUud2Fybign4pqg77iPIFByZXNzIGNhbGN1bGF0aW9uIHZhbGlkYXRpb246IEZBSUxFRCcpO1xuICB9XG4gIFxuICByZXR1cm4gaXNWYWxpZDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgcHJlc3MgZGltZW5zaW9ucyBzcGVjaWZpY2FsbHkgZm9yIHZpc3VhbGl6YXRpb25cbiAqIFJldHVybnMgZGltZW5zaW9ucyB0aGF0IHdvcmsgd2VsbCBmb3IgdGhlIGN1dHRpbmcgdmlzdWFsaXphdGlvblxuICogVXNlcyBFWEFDVCBTQU1FIGxvZ2ljIGFzIEV4Y2VsIGNhbGN1bGF0aW9uIChwaWNrQ2hlYXBlc3RUb3RhbCArIGNhbGNSb3dUb3RhbClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVZpc3VhbGl6YXRpb25QcmVzc0RpbWVuc2lvbnMoXG4gIHByb2R1Y3REaW1lbnNpb25zOiBQcm9kdWN0RGltZW5zaW9ucyxcbiAgZm9ybURhdGE/OiBhbnlcbik6IFByZXNzRGltZW5zaW9uIHwgbnVsbCB7XG4gIC8vIFVzZSBwcm9kdWN0IGRpbWVuc2lvbnMgZnJvbSBmb3JtIGRhdGEgaWYgYXZhaWxhYmxlXG4gIGNvbnN0IHByb2R1Y3RXaWR0aCA9IHByb2R1Y3REaW1lbnNpb25zLndpZHRoO1xuICBjb25zdCBwcm9kdWN0SGVpZ2h0ID0gcHJvZHVjdERpbWVuc2lvbnMuaGVpZ2h0O1xuICBcbiAgaWYgKCFwcm9kdWN0V2lkdGggfHwgIXByb2R1Y3RIZWlnaHQpIHtcbiAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBNaXNzaW5nIHByb2R1Y3QgZGltZW5zaW9ucyBmb3IgcHJlc3MgY2FsY3VsYXRpb24nKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBcbiAgY29uc29sZS5sb2coJ/CflI0gQ2FsY3VsYXRpbmcgdmlzdWFsaXphdGlvbiBwcmVzcyBkaW1lbnNpb25zIGZvcjonLCBwcm9kdWN0RGltZW5zaW9ucyk7XG4gIFxuICAvLyBVc2UgRVhBQ1QgU0FNRSBDVVRfU0laRV9DQU5ESURBVEVTIGFzIEV4Y2VsIGNhbGN1bGF0aW9uXG4gIGNvbnN0IGN1dFNpemVDYW5kaWRhdGVzID0gW1xuICAgIHsgcGFyZW50VzogMjAsICAgcGFyZW50SDogMTQsICAgIGN1dFBjczogMjUsIGxhYmVsOiBcIjIww5cxNCAvIENwMjVcIiB9LFxuICAgIHsgcGFyZW50VzogMjAsICAgcGFyZW50SDogMTcuNSwgIGN1dFBjczogMjAsIGxhYmVsOiBcIjIww5cxNy41IC8gQ3AyMFwiIH0sXG4gICAgeyBwYXJlbnRXOiAyMywgICBwYXJlbnRIOiAxNCwgICAgY3V0UGNzOiAyMSwgbGFiZWw6IFwiMjPDlzE0IC8gQ3AyMVwiIH0sXG4gICAgeyBwYXJlbnRXOiAyMywgICBwYXJlbnRIOiAxNi41LCAgY3V0UGNzOiAxOCwgbGFiZWw6IFwiMjPDlzE2LjUgLyBDcDE4XCIgfSxcbiAgICB7IHBhcmVudFc6IDIzLCAgIHBhcmVudEg6IDIwLCAgICBjdXRQY3M6IDE1LCBsYWJlbDogXCIyM8OXMjAgLyBDcDE1XCIgfSxcbiAgICB7IHBhcmVudFc6IDI1LCAgIHBhcmVudEg6IDE0LCAgICBjdXRQY3M6IDIwLCBsYWJlbDogXCIyNcOXMTQgLyBDcDIwXCIgfSxcbiAgICB7IHBhcmVudFc6IDI1LCAgIHBhcmVudEg6IDE3LjUsICBjdXRQY3M6IDE2LCBsYWJlbDogXCIyNcOXMTcuNSAvIENwMTZcIiB9LFxuICAgIHsgcGFyZW50VzogMjUsICAgcGFyZW50SDogMjAsICAgIGN1dFBjczogMTQsIGxhYmVsOiBcIjI1w5cyMCAvIENwMTRcIiB9LFxuICAgIHsgcGFyZW50VzogMjUsICAgcGFyZW50SDogMjMsICAgIGN1dFBjczogMTIsIGxhYmVsOiBcIjI1w5cyMyAvIENwMTJcIiB9LFxuICAgIHsgcGFyZW50VzogMjgsICAgcGFyZW50SDogMTQsICAgIGN1dFBjczogMTcsIGxhYmVsOiBcIjI4w5cxNCAvIENwMTdcIiB9LFxuICAgIHsgcGFyZW50VzogMzAsICAgcGFyZW50SDogMTQsICAgIGN1dFBjczogMTYsIGxhYmVsOiBcIjMww5cxNCAvIENwMTZcIiB9LFxuICAgIHsgcGFyZW50VzogMzAsICAgcGFyZW50SDogMTcuNSwgIGN1dFBjczogMTMsIGxhYmVsOiBcIjMww5cxNy41IC8gQ3AxM1wiIH0sXG4gICAgeyBwYXJlbnRXOiAzMCwgICBwYXJlbnRIOiAyMCwgICAgY3V0UGNzOiAxMSwgbGFiZWw6IFwiMzDDlzIwIC8gQ3AxMVwiIH0sXG4gICAgeyBwYXJlbnRXOiAzMCwgICBwYXJlbnRIOiAyMywgICAgY3V0UGNzOiA5LCAgbGFiZWw6IFwiMzDDlzIzIC8gQ3A5XCIgIH0sXG4gICAgeyBwYXJlbnRXOiAzNSwgICBwYXJlbnRIOiAxNCwgICAgY3V0UGNzOiAxNCwgbGFiZWw6IFwiMzXDlzE0IC8gQ3AxNFwiIH0sXG4gICAgeyBwYXJlbnRXOiAzNSwgICBwYXJlbnRIOiAxNy41LCAgY3V0UGNzOiAxMSwgbGFiZWw6IFwiMzXDlzE3LjUgLyBDcDExXCIgfSxcbiAgICB7IHBhcmVudFc6IDM1LCAgIHBhcmVudEg6IDIwLCAgICBjdXRQY3M6IDEwLCBsYWJlbDogXCIzNcOXMjAgLyBDcDEwXCIgfSxcbiAgICB7IHBhcmVudFc6IDM1LCAgIHBhcmVudEg6IDIzLCAgICBjdXRQY3M6IDgsICBsYWJlbDogXCIzNcOXMjMgLyBDcDhcIiAgfSxcbiAgICB7IHBhcmVudFc6IDM1LCAgIHBhcmVudEg6IDI1LCAgICBjdXRQY3M6IDcsICBsYWJlbDogXCIzNcOXMjUgLyBDcDdcIiAgfSxcbiAgICB7IHBhcmVudFc6IDQwLCAgIHBhcmVudEg6IDE0LCAgICBjdXRQY3M6IDEyLCBsYWJlbDogXCI0MMOXMTQgLyBDcDEyXCIgfSxcbiAgICB7IHBhcmVudFc6IDQwLCAgIHBhcmVudEg6IDE3LjUsICBjdXRQY3M6IDEwLCBsYWJlbDogXCI0MMOXMTcuNSAvIENwMTBcIiB9LFxuICAgIHsgcGFyZW50VzogNDAsICAgcGFyZW50SDogMjAsICAgIGN1dFBjczogOCwgIGxhYmVsOiBcIjQww5cyMCAvIENwOFwiICB9LFxuICAgIHsgcGFyZW50VzogNDAsICAgcGFyZW50SDogMjMsICAgIGN1dFBjczogNywgIGxhYmVsOiBcIjQww5cyMyAvIENwN1wiICB9LFxuICAgIHsgcGFyZW50VzogNDAsICAgcGFyZW50SDogMjUsICAgIGN1dFBjczogNiwgIGxhYmVsOiBcIjQww5cyNSAvIENwNlwiICB9LFxuICAgIHsgcGFyZW50VzogNDAsICAgcGFyZW50SDogMzAsICAgIGN1dFBjczogNSwgIGxhYmVsOiBcIjQww5czMCAvIENwNVwiICB9LFxuICAgIHsgcGFyZW50VzogNDAsICAgcGFyZW50SDogMzUsICAgIGN1dFBjczogNCwgIGxhYmVsOiBcIjQww5czNSAvIENwNFwiICB9LFxuICAgIHsgcGFyZW50VzogNDUsICAgcGFyZW50SDogMjAsICAgIGN1dFBjczogNywgIGxhYmVsOiBcIjQ1w5cyMCAvIENwN1wiICB9LFxuICAgIHsgcGFyZW50VzogNDUsICAgcGFyZW50SDogMjUsICAgIGN1dFBjczogNSwgIGxhYmVsOiBcIjQ1w5cyNSAvIENwNVwiICB9LFxuICAgIHsgcGFyZW50VzogNDUsICAgcGFyZW50SDogMzAsICAgIGN1dFBjczogNCwgIGxhYmVsOiBcIjQ1w5czMCAvIENwNFwiICB9LFxuICAgIHsgcGFyZW50VzogNDUsICAgcGFyZW50SDogMzUsICAgIGN1dFBjczogMywgIGxhYmVsOiBcIjQ1w5czNSAvIENwM1wiICB9LFxuICAgIHsgcGFyZW50VzogNTAsICAgcGFyZW50SDogMjAsICAgIGN1dFBjczogNiwgIGxhYmVsOiBcIjUww5cyMCAvIENwNlwiICB9LFxuICAgIHsgcGFyZW50VzogNTAsICAgcGFyZW50SDogMjUsICAgIGN1dFBjczogNSwgIGxhYmVsOiBcIjUww5cyNSAvIENwNVwiICB9LFxuICAgIHsgcGFyZW50VzogNTAsICAgcGFyZW50SDogMzAsICAgIGN1dFBjczogNCwgIGxhYmVsOiBcIjUww5czMCAvIENwNFwiICB9LFxuICAgIHsgcGFyZW50VzogNTAsICAgcGFyZW50SDogMzUsICAgIGN1dFBjczogNCwgIGxhYmVsOiBcIjUww5czNSAvIENwNFwiICB9XG4gIF07XG4gIFxuICAvLyBVc2UgRVhBQ1QgU0FNRSBsb2dpYyBhcyBFeGNlbCBjYWxjdWxhdGlvblxuICAvLyBHZXQgZm9ybSBkYXRhIHZhbHVlcyBmb3IgYWNjdXJhdGUgY2FsY3VsYXRpb25cbiAgY29uc3Qgc2lkZXMgPSBmb3JtRGF0YT8ucHJvZHVjdHM/LlswXT8uc2lkZXMgPT09IFwiMVwiID8gMSA6IDI7XG4gIGNvbnN0IGNvbG91cnMgPSBmb3JtRGF0YT8ucHJvZHVjdHM/LlswXT8uY29sb3VycyB8fCA0O1xuICBjb25zdCBxdHkgPSBmb3JtRGF0YT8ucHJvZHVjdHM/LlswXT8ucXVhbnRpdHkgfHwgMTAwMDtcbiAgY29uc3QgcGFwZXJDb3N0UGVyU2hlZXQgPSAxOyAvLyBTdGFuZGFyZCBwYXBlciBjb3N0IGZvciB2aXN1YWxpemF0aW9uXG4gIFxuICAvLyBDcmVhdGUgYmFzZSBvYmplY3QgZm9yIGNhbGNSb3dUb3RhbFxuICBjb25zdCBiYXNlID0ge1xuICAgIHBpZWNlVzogcHJvZHVjdFdpZHRoLFxuICAgIHBpZWNlSDogcHJvZHVjdEhlaWdodCxcbiAgICBxdHk6IHF0eSxcbiAgICBzaWRlczogc2lkZXMsXG4gICAgY29sb3VyczogY29sb3VycyxcbiAgICBwYXBlckNvc3RQZXJTaGVldDogcGFwZXJDb3N0UGVyU2hlZXRcbiAgfTtcbiAgXG4gIC8vIFVzZSBFWEFDVCBTQU1FIHBpY2tDaGVhcGVzdFRvdGFsIGxvZ2ljXG4gIGNvbnN0IHJvd3MgPSBjdXRTaXplQ2FuZGlkYXRlcy5tYXAoY2FuZGlkYXRlID0+IGNhbGNSb3dUb3RhbChiYXNlLCBjYW5kaWRhdGUpKTtcbiAgcm93cy5zb3J0KChhLCBiKSA9PiBhLnRvdGFsIC0gYi50b3RhbCk7XG4gIGNvbnN0IGNoZWFwZXN0Um93ID0gcm93c1swXTsgLy8gY2hlYXBlc3Qgcm93XG4gIFxuICBpZiAoY2hlYXBlc3RSb3cpIHtcbiAgICBjb25zb2xlLmxvZygn8J+OryBCZXN0IGN1dHRpbmcgc2l6ZSBmb3VuZCAoRXhjZWwgbG9naWMpOicsIGNoZWFwZXN0Um93KTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgZWZmaWNpZW5jeSBwZXJjZW50YWdlXG4gICAgY29uc3QgZWZmaWNpZW5jeSA9IChjaGVhcGVzdFJvdy51cHNQZXJTaHQgKiBwcm9kdWN0V2lkdGggKiBwcm9kdWN0SGVpZ2h0KSAvIFxuICAgICAgICAgICAgICAgICAgICAgIChjaGVhcGVzdFJvdy5wYXJlbnRXICogY2hlYXBlc3RSb3cucGFyZW50SCkgKiAxMDA7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBjaGVhcGVzdFJvdy5wYXJlbnRXLFxuICAgICAgaGVpZ2h0OiBjaGVhcGVzdFJvdy5wYXJlbnRILFxuICAgICAgbGFiZWw6IGNoZWFwZXN0Um93LmxhYmVsIHx8IGAke2NoZWFwZXN0Um93LnBhcmVudFd9w5cke2NoZWFwZXN0Um93LnBhcmVudEh9IGNtYCxcbiAgICAgIGVmZmljaWVuY3k6IE1hdGgucm91bmQoZWZmaWNpZW5jeSAqIDEwMCkgLyAxMDAsXG4gICAgICBwaWVjZXNQZXJQcmVzczogY2hlYXBlc3RSb3cubm9PZlVwcyxcbiAgICAgIHBpZWNlc1BlclBhcmVudDogY2hlYXBlc3RSb3cuY3V0UGNzXG4gICAgfTtcbiAgfVxuICBcbiAgLy8gRmFsbGJhY2s6IHVzZSBwYXJlbnQgc2hlZXQgc2l6ZSBmb3IgdmVyeSBsYXJnZSBwcm9kdWN0c1xuICBjb25zb2xlLmxvZygn4pqg77iPIE5vIG9wdGltYWwgY3V0dGluZyBzaXplIGZvdW5kLCB1c2luZyBwYXJlbnQgc2hlZXQgc2l6ZScpO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiAxMDAsXG4gICAgaGVpZ2h0OiA3MCxcbiAgICBsYWJlbDogXCIxMDDDlzcwIGNtIChQYXJlbnQgU2hlZXQpXCIsXG4gICAgZWZmaWNpZW5jeTogMTAwLFxuICAgIHBpZWNlc1BlclByZXNzOiAxLFxuICAgIHBpZWNlc1BlclBhcmVudDogMVxuICB9O1xufVxuXG4vKipcbiAqIEVYQUNUIENPUFkgb2YgY2FsY1Jvd1RvdGFsIGZyb20gU3RlcDRPcGVyYXRpb25hbC50c3hcbiAqIFRoaXMgZW5zdXJlcyB0aGUgdmlzdWFsaXphdGlvbiB1c2VzIHRoZSBzYW1lIGNhbGN1bGF0aW9uIGxvZ2ljXG4gKi9cbmZ1bmN0aW9uIGNhbGNSb3dUb3RhbChcbiAgYmFzZTogeyBwaWVjZVc6IG51bWJlcjsgcGllY2VIOiBudW1iZXI7IHF0eTogbnVtYmVyOyBzaWRlczogbnVtYmVyOyBjb2xvdXJzOiBudW1iZXI7IHBhcGVyQ29zdFBlclNoZWV0OiBudW1iZXIgfSxcbiAgcm93OiB7IHBhcmVudFc6IG51bWJlcjsgcGFyZW50SDogbnVtYmVyOyBjdXRQY3M6IG51bWJlcjsgbGFiZWw/OiBzdHJpbmcgfVxuKSB7XG4gIGNvbnN0IHsgcGllY2VXLCBwaWVjZUgsIHF0eSwgc2lkZXMsIGNvbG91cnMsIHBhcGVyQ29zdFBlclNoZWV0IH0gPSBiYXNlO1xuICBjb25zdCB7IHBhcmVudFcsIHBhcmVudEgsIGN1dFBjcyB9ID0gcm93O1xuXG4gIC8vIDEpIEltcG9zaXRpb24gKE9wdGlvbjEvMilcbiAgY29uc3Qgb3B0MSA9IE1hdGguZmxvb3IocGFyZW50VyAvIChwaWVjZUggKyAxKSkgKiBNYXRoLmZsb29yKHBhcmVudEggLyAocGllY2VXICsgMSkpO1xuICBjb25zdCBvcHQyID0gTWF0aC5mbG9vcihwYXJlbnRXIC8gKHBpZWNlVyArIDEpKSAqIE1hdGguZmxvb3IocGFyZW50SCAvIChwaWVjZUggKyAxKSk7XG4gIGNvbnN0IG5vT2ZVcHMgPSBNYXRoLm1heChvcHQxLCBvcHQyKTtcblxuICAvLyAyKSBPZGQvZXZlbiBydWxlIChJRihTaWRlcz0xLCBUUlVFLCBJU0VWRU4oTm8uIG9mIHVwcykpKVxuICBjb25zdCBvZGRFdmVuID0gKHNpZGVzID09PSAxKSA/IHRydWUgOiAobm9PZlVwcyAlIDIgPT09IDApO1xuXG4gIC8vIDMpIFVwcy9zaGVldDsgNCkgV2FzdGU7IDUpIFNoZWV0c1xuICBjb25zdCB1cHNQZXJTaHQgICA9IG5vT2ZVcHMgKiBjdXRQY3M7XG4gIGNvbnN0IHdhc3RlU2hlZXRzID0gTWF0aC5jZWlsKChwYXJlbnRXID4gNTAgPyAxMjAgOiAxMDApIC8gY3V0UGNzKTtcbiAgY29uc3Qgc2hlZXRzICAgICAgPSB1cHNQZXJTaHQgPT09IDAgPyAwIDogTWF0aC5jZWlsKHF0eSAvIHVwc1BlclNodCArIHdhc3RlU2hlZXRzKTtcblxuICAvLyA2KSBQYXBlciBjb3N0XG4gIGNvbnN0IHBhcGVyQ29zdCA9IHNoZWV0cyAqIHBhcGVyQ29zdFBlclNoZWV0O1xuXG4gIC8vIDcpIFVuaXRzIOKGkiA4KSB1bml0IHByaWNlXG4gIGNvbnN0IGNvcmVVbml0cyA9IE1hdGguY2VpbCgoc2hlZXRzICogY3V0UGNzICogY29sb3VycyAqIHNpZGVzKSAvIDEwMDApO1xuICBjb25zdCBiYXNlVW5pdHMgPSBNYXRoLm1heChjb2xvdXJzLCBjb3JlVW5pdHMpO1xuICBjb25zdCB1bml0cyAgICAgPSBvZGRFdmVuID8gYmFzZVVuaXRzIDogYmFzZVVuaXRzICogMjtcbiAgY29uc3QgdW5pdF9wcmljZSA9IHVuaXRQcmljZSh1bml0cyk7XG5cbiAgLy8gOSkgUGxhdGVcbiAgY29uc3QgcGxhdGVQZXJTaWRlID0gKHBhcmVudFcgPiA1NCA/IDUwIDogMjApICogY29sb3VycztcbiAgY29uc3QgcGxhdGVUb3RhbCAgID0gcGxhdGVQZXJTaWRlICogc2lkZXM7XG5cbiAgLy8gMTApIFRvdGFsXG4gIGNvbnN0IHRvdGFsID0gc2hlZXRzID09PSAwID8gMCA6IHVuaXRfcHJpY2UgKyBwYXBlckNvc3QgKyBwbGF0ZVRvdGFsO1xuXG4gIHJldHVybiB7IC4uLnJvdywgbm9PZlVwcywgdXBzUGVyU2h0LCB3YXN0ZVNoZWV0cywgc2hlZXRzLCBwYXBlckNvc3QsIHVuaXRzLCB1bml0X3ByaWNlLCBwbGF0ZVBlclNpZGUsIHBsYXRlVG90YWwsIHRvdGFsIH07XG59XG4iXSwibmFtZXMiOlsidW5pdFByaWNlIiwidW5pdHMiLCJ1IiwiTWF0aCIsIm1heCIsImZsb29yIiwiREVGQVVMVF9DVVRUSU5HX0NPTlNUUkFJTlRTIiwicGFyZW50V2lkdGgiLCJwYXJlbnRIZWlnaHQiLCJtaW5QcmVzc1dpZHRoIiwibWluUHJlc3NIZWlnaHQiLCJtYXhQcmVzc1dpZHRoIiwibWF4UHJlc3NIZWlnaHQiLCJjdXR0aW5nTWFyZ2luIiwiZ2FwQmV0d2VlblBpZWNlcyIsImNhbGN1bGF0ZU9wdGltYWxQcmVzc0RpbWVuc2lvbnMiLCJwcm9kdWN0RGltZW5zaW9ucyIsImNvbnN0cmFpbnRzIiwid2lkdGgiLCJwcm9kdWN0V2lkdGgiLCJoZWlnaHQiLCJwcm9kdWN0SGVpZ2h0IiwiY29uc29sZSIsImxvZyIsInByZXNzT3B0aW9ucyIsInN0ZXBTaXplIiwicHJlc3NXaWR0aCIsInByZXNzSGVpZ2h0IiwicGllY2VzUGVyUHJlc3MiLCJjYWxjdWxhdGVQaWVjZXNQZXJQcmVzcyIsInByZXNzU2hlZXRzUGVyUGFyZW50IiwiY2FsY3VsYXRlUHJlc3NTaGVldHNQZXJQYXJlbnQiLCJwaWVjZXNQZXJQYXJlbnQiLCJlZmZpY2llbmN5IiwicHVzaCIsImxhYmVsIiwicm91bmQiLCJzb3J0IiwiYSIsImIiLCJzbGljZSIsImdhcCIsImNvbHMxIiwicm93czEiLCJwaWVjZXMxIiwiY29sczIiLCJyb3dzMiIsInBpZWNlczIiLCJob3Jpem9udGFsRml0IiwidmVydGljYWxGaXQiLCJnZXRCZXN0UHJlc3NEaW1lbnNpb24iLCJvcHRpb25zIiwibGVuZ3RoIiwidmFsaWRhdGVQcmVzc0NhbGN1bGF0aW9ucyIsImJ1c2luZXNzQ2FyZFRlc3QiLCJpc1ZhbGlkIiwid2FybiIsImNhbGN1bGF0ZVZpc3VhbGl6YXRpb25QcmVzc0RpbWVuc2lvbnMiLCJmb3JtRGF0YSIsImN1dFNpemVDYW5kaWRhdGVzIiwicGFyZW50VyIsInBhcmVudEgiLCJjdXRQY3MiLCJzaWRlcyIsInByb2R1Y3RzIiwiY29sb3VycyIsInF0eSIsInF1YW50aXR5IiwicGFwZXJDb3N0UGVyU2hlZXQiLCJiYXNlIiwicGllY2VXIiwicGllY2VIIiwicm93cyIsIm1hcCIsImNhbmRpZGF0ZSIsImNhbGNSb3dUb3RhbCIsInRvdGFsIiwiY2hlYXBlc3RSb3ciLCJ1cHNQZXJTaHQiLCJub09mVXBzIiwicm93Iiwib3B0MSIsIm9wdDIiLCJvZGRFdmVuIiwid2FzdGVTaGVldHMiLCJjZWlsIiwic2hlZXRzIiwicGFwZXJDb3N0IiwiY29yZVVuaXRzIiwiYmFzZVVuaXRzIiwidW5pdF9wcmljZSIsInBsYXRlUGVyU2lkZSIsInBsYXRlVG90YWwiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/dynamic-press-calculator.ts\n"));

/***/ })

});