"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(root)/create-quote/page",{

/***/ "(app-pages-browser)/./lib/dynamic-press-calculator.ts":
/*!*****************************************!*\
  !*** ./lib/dynamic-press-calculator.ts ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_CUTTING_CONSTRAINTS: () => (/* binding */ DEFAULT_CUTTING_CONSTRAINTS),\n/* harmony export */   calculateOptimalPressDimensions: () => (/* binding */ calculateOptimalPressDimensions),\n/* harmony export */   calculateVisualizationPressDimensions: () => (/* binding */ calculateVisualizationPressDimensions),\n/* harmony export */   getBestPressDimension: () => (/* binding */ getBestPressDimension),\n/* harmony export */   validatePressCalculations: () => (/* binding */ validatePressCalculations)\n/* harmony export */ });\n// Define Cm type locally since types module might not be available\n// === Dynamic Press Dimension Calculator ===\n// This module calculates optimal press dimensions based on product size\n// Following the Excel sheet logic for cutting operations\n// Units-table VLOOKUP (cumulative) in closed form - same as Excel\nconst unitPrice = (units)=>{\n    const u = Math.max(0, Math.floor(units));\n    if (u <= 10) return 50 * u;\n    if (u <= 20) return 60 * u - u * u; // 60u - u^2\n    return 40 * u;\n};\n// Default cutting constraints based on Excel analysis\nconst DEFAULT_CUTTING_CONSTRAINTS = {\n    parentWidth: 100,\n    parentHeight: 70,\n    minPressWidth: 20,\n    minPressHeight: 15,\n    maxPressWidth: 100,\n    maxPressHeight: 70,\n    cuttingMargin: 1.0,\n    gapBetweenPieces: 0.5 // 0.5cm gap between pieces\n};\n/**\n * Calculate optimal press dimensions based on product size\n * Following Excel sheet logic: press dimensions should maximize cutting efficiency\n */ function calculateOptimalPressDimensions(productDimensions) {\n    let constraints = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_CUTTING_CONSTRAINTS;\n    const { width: productWidth, height: productHeight } = productDimensions;\n    const { parentWidth, parentHeight, minPressWidth, minPressHeight, maxPressWidth, maxPressHeight, cuttingMargin, gapBetweenPieces } = constraints;\n    console.log('üîç Calculating optimal press dimensions for product:', productDimensions);\n    console.log('üìè Using constraints:', constraints);\n    const pressOptions = [];\n    // Calculate all possible press dimensions that fit within parent sheet\n    // with reasonable cutting margins\n    const stepSize = 5; // 5cm increments for press dimensions\n    for(let pressWidth = minPressWidth; pressWidth <= maxPressWidth; pressWidth += stepSize){\n        for(let pressHeight = minPressHeight; pressHeight <= maxPressHeight; pressHeight += stepSize){\n            // Check if press fits within parent sheet with margins\n            if (pressWidth + cuttingMargin <= parentWidth && pressHeight + cuttingMargin <= parentHeight) {\n                // Calculate how many pieces fit on this press sheet\n                const piecesPerPress = calculatePiecesPerPress(pressWidth, pressHeight, productWidth, productHeight, gapBetweenPieces);\n                // Calculate how many press sheets fit in parent sheet\n                const pressSheetsPerParent = calculatePressSheetsPerParent(parentWidth, parentHeight, pressWidth, pressHeight);\n                // Calculate total pieces per parent sheet\n                const piecesPerParent = piecesPerPress * pressSheetsPerParent;\n                // Calculate efficiency (percentage of parent sheet utilized)\n                const efficiency = piecesPerParent * productWidth * productHeight / (parentWidth * parentHeight) * 100;\n                if (piecesPerPress > 0 && pressSheetsPerParent > 0) {\n                    pressOptions.push({\n                        width: pressWidth,\n                        height: pressHeight,\n                        label: \"\".concat(pressWidth, \"\\xd7\").concat(pressHeight, \" cm\"),\n                        efficiency: Math.round(efficiency * 100) / 100,\n                        piecesPerPress,\n                        piecesPerParent\n                    });\n                }\n            }\n        }\n    }\n    // Sort by efficiency (highest first)\n    pressOptions.sort((a, b)=>b.efficiency - a.efficiency);\n    console.log('üìä Generated press options:', pressOptions.slice(0, 5)); // Log top 5 options\n    return pressOptions;\n}\n/**\n * Calculate how many product pieces fit on a press sheet\n * Following Excel formula: ROUNDDOWN((Sheet Width) / (width + gap), 0) √ó ROUNDDOWN((Sheet Height) / (height + gap), 0)\n */ function calculatePiecesPerPress(pressWidth, pressHeight, productWidth, productHeight, gap) {\n    // Option 1: Normal orientation\n    const cols1 = Math.floor(pressWidth / (productWidth + gap));\n    const rows1 = Math.floor(pressHeight / (productHeight + gap));\n    const pieces1 = cols1 * rows1;\n    // Option 2: Rotated orientation\n    const cols2 = Math.floor(pressWidth / (productHeight + gap));\n    const rows2 = Math.floor(pressHeight / (productWidth + gap));\n    const pieces2 = cols2 * rows2;\n    // Return the better option (Excel logic: IF(Option 1 > Option 2, Option 1, Option 2))\n    return Math.max(pieces1, pieces2);\n}\n/**\n * Calculate how many press sheets fit in parent sheet\n * Following Excel logic for cutting operations\n */ function calculatePressSheetsPerParent(parentWidth, parentHeight, pressWidth, pressHeight) {\n    // Calculate how many press sheets fit horizontally and vertically\n    const horizontalFit = Math.floor(parentWidth / pressWidth);\n    const verticalFit = Math.floor(parentHeight / pressHeight);\n    return horizontalFit * verticalFit;\n}\n/**\n * Get the best press dimension for a given product\n * Returns the most efficient option\n */ function getBestPressDimension(productDimensions) {\n    let constraints = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_CUTTING_CONSTRAINTS;\n    const options = calculateOptimalPressDimensions(productDimensions, constraints);\n    return options.length > 0 ? options[0] : null;\n}\n/**\n * Validate press dimensions against Excel examples\n * Test function to ensure calculations match Excel logic\n */ function validatePressCalculations() {\n    console.log('üß™ Validating press calculations against Excel examples...');\n    // Test case: Business card (9√ó5.5) should result in press around 40√ó20\n    const businessCardTest = getBestPressDimension({\n        width: 9,\n        height: 5.5\n    });\n    console.log('üì± Business card test result:', businessCardTest);\n    // Expected: Should be around 40√ó20 with good efficiency\n    const isValid = businessCardTest && businessCardTest.width >= 35 && businessCardTest.width <= 45 && businessCardTest.height >= 15 && businessCardTest.height <= 25;\n    if (isValid) {\n        console.log('‚úÖ Press calculation validation: PASSED');\n    } else {\n        console.warn('‚ö†Ô∏è Press calculation validation: FAILED');\n    }\n    return isValid || false;\n}\n/**\n * Calculate press dimensions specifically for visualization\n * Returns dimensions that work well for the cutting visualization\n * Uses EXACT SAME logic as Excel calculation (pickCheapestTotal + calcRowTotal)\n */ function calculateVisualizationPressDimensions(productDimensions, formData) {\n    var _formData_products_, _formData_products, _formData_products_1, _formData_products1, _formData_products_2, _formData_products2;\n    // Use product dimensions from form data if available\n    const productWidth = productDimensions.width;\n    const productHeight = productDimensions.height;\n    if (!productWidth || !productHeight) {\n        console.warn('‚ö†Ô∏è Missing product dimensions for press calculation');\n        return null;\n    }\n    console.log('üîç Calculating visualization press dimensions for:', productDimensions);\n    // Use EXACT SAME CUT_SIZE_CANDIDATES as Excel calculation\n    const cutSizeCandidates = [\n        {\n            parentW: 20,\n            parentH: 14,\n            cutPcs: 25,\n            label: \"20√ó14 / Cp25\"\n        },\n        {\n            parentW: 20,\n            parentH: 17.5,\n            cutPcs: 20,\n            label: \"20√ó17.5 / Cp20\"\n        },\n        {\n            parentW: 23,\n            parentH: 14,\n            cutPcs: 21,\n            label: \"23√ó14 / Cp21\"\n        },\n        {\n            parentW: 23,\n            parentH: 16.5,\n            cutPcs: 18,\n            label: \"23√ó16.5 / Cp18\"\n        },\n        {\n            parentW: 23,\n            parentH: 20,\n            cutPcs: 15,\n            label: \"23√ó20 / Cp15\"\n        },\n        {\n            parentW: 23,\n            parentH: 52,\n            cutPcs: 5,\n            label: \"23√ó52 / Cp5\"\n        },\n        {\n            parentW: 25,\n            parentH: 14,\n            cutPcs: 20,\n            label: \"25√ó14 / Cp20\"\n        },\n        {\n            parentW: 25,\n            parentH: 17.5,\n            cutPcs: 16,\n            label: \"25√ó17.5 / Cp16\"\n        },\n        {\n            parentW: 25,\n            parentH: 20,\n            cutPcs: 14,\n            label: \"25√ó20 / Cp14\"\n        },\n        {\n            parentW: 25,\n            parentH: 23,\n            cutPcs: 12,\n            label: \"25√ó23 / Cp12\"\n        },\n        {\n            parentW: 28,\n            parentH: 14,\n            cutPcs: 17,\n            label: \"28√ó14 / Cp17\"\n        },\n        {\n            parentW: 30,\n            parentH: 14,\n            cutPcs: 16,\n            label: \"30√ó14 / Cp16\"\n        },\n        {\n            parentW: 30,\n            parentH: 17.5,\n            cutPcs: 13,\n            label: \"30√ó17.5 / Cp13\"\n        },\n        {\n            parentW: 30,\n            parentH: 20,\n            cutPcs: 11,\n            label: \"30√ó20 / Cp11\"\n        },\n        {\n            parentW: 30,\n            parentH: 23,\n            cutPcs: 9,\n            label: \"30√ó23 / Cp9\"\n        },\n        {\n            parentW: 35,\n            parentH: 14,\n            cutPcs: 14,\n            label: \"35√ó14 / Cp14\"\n        },\n        {\n            parentW: 35,\n            parentH: 17.5,\n            cutPcs: 11,\n            label: \"35√ó17.5 / Cp11\"\n        },\n        {\n            parentW: 35,\n            parentH: 20,\n            cutPcs: 10,\n            label: \"35√ó20 / Cp10\"\n        },\n        {\n            parentW: 35,\n            parentH: 23,\n            cutPcs: 8,\n            label: \"35√ó23 / Cp8\"\n        },\n        {\n            parentW: 35,\n            parentH: 25,\n            cutPcs: 7,\n            label: \"35√ó25 / Cp7\"\n        },\n        {\n            parentW: 40,\n            parentH: 14,\n            cutPcs: 12,\n            label: \"40√ó14 / Cp12\"\n        },\n        {\n            parentW: 40,\n            parentH: 17.5,\n            cutPcs: 10,\n            label: \"40√ó17.5 / Cp10\"\n        },\n        {\n            parentW: 40,\n            parentH: 20,\n            cutPcs: 8,\n            label: \"40√ó20 / Cp8\"\n        },\n        {\n            parentW: 40,\n            parentH: 23,\n            cutPcs: 7,\n            label: \"40√ó23 / Cp7\"\n        },\n        {\n            parentW: 40,\n            parentH: 25,\n            cutPcs: 6,\n            label: \"40√ó25 / Cp6\"\n        },\n        {\n            parentW: 40,\n            parentH: 30,\n            cutPcs: 5,\n            label: \"40√ó30 / Cp5\"\n        },\n        {\n            parentW: 40,\n            parentH: 35,\n            cutPcs: 4,\n            label: \"40√ó35 / Cp4\"\n        },\n        {\n            parentW: 45,\n            parentH: 20,\n            cutPcs: 7,\n            label: \"45√ó20 / Cp7\"\n        },\n        {\n            parentW: 45,\n            parentH: 25,\n            cutPcs: 5,\n            label: \"45√ó25 / Cp5\"\n        },\n        {\n            parentW: 45,\n            parentH: 30,\n            cutPcs: 4,\n            label: \"45√ó30 / Cp4\"\n        },\n        {\n            parentW: 45,\n            parentH: 35,\n            cutPcs: 3,\n            label: \"45√ó35 / Cp3\"\n        },\n        {\n            parentW: 50,\n            parentH: 20,\n            cutPcs: 6,\n            label: \"50√ó20 / Cp6\"\n        },\n        {\n            parentW: 50,\n            parentH: 25,\n            cutPcs: 5,\n            label: \"50√ó25 / Cp5\"\n        },\n        {\n            parentW: 50,\n            parentH: 30,\n            cutPcs: 4,\n            label: \"50√ó30 / Cp4\"\n        },\n        {\n            parentW: 50,\n            parentH: 35,\n            cutPcs: 4,\n            label: \"50√ó35 / Cp4\"\n        }\n    ];\n    // Use EXACT SAME logic as Excel calculation\n    // Get form data values for accurate calculation\n    const sides = (formData === null || formData === void 0 ? void 0 : (_formData_products = formData.products) === null || _formData_products === void 0 ? void 0 : (_formData_products_ = _formData_products[0]) === null || _formData_products_ === void 0 ? void 0 : _formData_products_.sides) === \"1\" ? 1 : 2;\n    const colours = (formData === null || formData === void 0 ? void 0 : (_formData_products1 = formData.products) === null || _formData_products1 === void 0 ? void 0 : (_formData_products_1 = _formData_products1[0]) === null || _formData_products_1 === void 0 ? void 0 : _formData_products_1.colours) || 4;\n    const qty = (formData === null || formData === void 0 ? void 0 : (_formData_products2 = formData.products) === null || _formData_products2 === void 0 ? void 0 : (_formData_products_2 = _formData_products2[0]) === null || _formData_products_2 === void 0 ? void 0 : _formData_products_2.quantity) || 1000;\n    const paperCostPerSheet = 1; // Standard paper cost for visualization\n    // Create base object for calcRowTotal\n    const base = {\n        pieceW: productWidth,\n        pieceH: productHeight,\n        qty: qty,\n        sides: sides,\n        colours: colours,\n        paperCostPerSheet: paperCostPerSheet\n    };\n    // Use EXACT SAME pickCheapestTotal logic\n    const rows = cutSizeCandidates.map((candidate)=>calcRowTotal(base, candidate));\n    // Filter out candidates with noOfUps = 0 (invalid candidates)\n    const validRows = rows.filter((row)=>row.noOfUps > 0);\n    if (validRows.length === 0) {\n        console.warn('‚ö†Ô∏è No valid candidates found (all have noOfUps = 0)');\n        return null;\n    }\n    validRows.sort((a, b)=>a.total - b.total);\n    const cheapestRow = validRows[0]; // cheapest valid row\n    if (cheapestRow) {\n        console.log('üéØ Best cutting size found (Excel logic):', cheapestRow);\n        // Calculate efficiency percentage\n        const efficiency = cheapestRow.upsPerSht * productWidth * productHeight / (cheapestRow.parentW * cheapestRow.parentH) * 100;\n        return {\n            width: cheapestRow.parentW,\n            height: cheapestRow.parentH,\n            label: cheapestRow.label || \"\".concat(cheapestRow.parentW, \"\\xd7\").concat(cheapestRow.parentH, \" cm\"),\n            efficiency: Math.round(efficiency * 100) / 100,\n            piecesPerPress: cheapestRow.noOfUps,\n            piecesPerParent: cheapestRow.cutPcs\n        };\n    }\n    // Fallback: use parent sheet size for very large products\n    console.log('‚ö†Ô∏è No optimal cutting size found, using parent sheet size');\n    return {\n        width: 100,\n        height: 70,\n        label: \"100√ó70 cm (Parent Sheet)\",\n        efficiency: 100,\n        piecesPerPress: 1,\n        piecesPerParent: 1\n    };\n}\n/**\n * EXACT COPY of calcRowTotal from Step4Operational.tsx\n * This ensures the visualization uses the same calculation logic\n */ function calcRowTotal(base, row) {\n    const { pieceW, pieceH, qty, sides, colours, paperCostPerSheet } = base;\n    const { parentW, parentH, cutPcs } = row;\n    // 1) Imposition (Option1/2)\n    const opt1 = Math.floor(parentW / (pieceH + 1)) * Math.floor(parentH / (pieceW + 1));\n    const opt2 = Math.floor(parentW / (pieceW + 1)) * Math.floor(parentH / (pieceH + 1));\n    const noOfUps = Math.max(opt1, opt2);\n    // 2) Odd/even rule (IF(Sides=1, TRUE, ISEVEN(No. of ups)))\n    const oddEven = sides === 1 ? true : noOfUps % 2 === 0;\n    // 3) Ups/sheet; 4) Waste; 5) Sheets\n    const upsPerSht = noOfUps * cutPcs;\n    const wasteSheets = Math.ceil((parentW > 50 ? 120 : 100) / cutPcs);\n    const sheets = upsPerSht === 0 ? 0 : Math.ceil(qty / upsPerSht + wasteSheets);\n    // 6) Paper cost\n    const paperCost = sheets * paperCostPerSheet;\n    // 7) Units ‚Üí 8) unit price\n    const coreUnits = Math.ceil(sheets * cutPcs * colours * sides / 1000);\n    const baseUnits = Math.max(colours, coreUnits);\n    const units = oddEven ? baseUnits : baseUnits * 2;\n    const unit_price = unitPrice(units);\n    // 9) Plate\n    const platePerSide = (parentW > 54 ? 50 : 20) * colours;\n    const plateTotal = platePerSide * sides;\n    // 10) Total\n    const total = sheets === 0 ? 0 : unit_price + paperCost + plateTotal;\n    return {\n        ...row,\n        noOfUps,\n        upsPerSht,\n        wasteSheets,\n        sheets,\n        paperCost,\n        units,\n        unit_price,\n        platePerSide,\n        plateTotal,\n        total\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9keW5hbWljLXByZXNzLWNhbGN1bGF0b3IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxtRUFBbUU7QUFHbkUsNkNBQTZDO0FBQzdDLHdFQUF3RTtBQUN4RSx5REFBeUQ7QUFFekQsa0VBQWtFO0FBQ2xFLE1BQU1BLFlBQVksQ0FBQ0M7SUFDakIsTUFBTUMsSUFBSUMsS0FBS0MsR0FBRyxDQUFDLEdBQUdELEtBQUtFLEtBQUssQ0FBQ0o7SUFDakMsSUFBSUMsS0FBSyxJQUFJLE9BQU8sS0FBS0E7SUFDekIsSUFBSUEsS0FBSyxJQUFJLE9BQU8sS0FBS0EsSUFBSUEsSUFBSUEsR0FBRyxZQUFZO0lBQ2hELE9BQU8sS0FBS0E7QUFDZDtBQTJCQSxzREFBc0Q7QUFDL0MsTUFBTUksOEJBQWtEO0lBQzdEQyxhQUFhO0lBQ2JDLGNBQWM7SUFDZEMsZUFBZTtJQUNmQyxnQkFBZ0I7SUFDaEJDLGVBQWU7SUFDZkMsZ0JBQWdCO0lBQ2hCQyxlQUFlO0lBQ2ZDLGtCQUFrQixJQUFJLDJCQUEyQjtBQUNuRCxFQUFFO0FBRUY7OztDQUdDLEdBQ00sU0FBU0MsZ0NBQ2RDLGlCQUFvQztRQUNwQ0MsY0FBQUEsaUVBQWtDWDtJQUVsQyxNQUFNLEVBQUVZLE9BQU9DLFlBQVksRUFBRUMsUUFBUUMsYUFBYSxFQUFFLEdBQUdMO0lBQ3ZELE1BQU0sRUFDSlQsV0FBVyxFQUNYQyxZQUFZLEVBQ1pDLGFBQWEsRUFDYkMsY0FBYyxFQUNkQyxhQUFhLEVBQ2JDLGNBQWMsRUFDZEMsYUFBYSxFQUNiQyxnQkFBZ0IsRUFDakIsR0FBR0c7SUFFSkssUUFBUUMsR0FBRyxDQUFDLHdEQUF3RFA7SUFDcEVNLFFBQVFDLEdBQUcsQ0FBQyx5QkFBeUJOO0lBRXJDLE1BQU1PLGVBQWlDLEVBQUU7SUFFekMsdUVBQXVFO0lBQ3ZFLGtDQUFrQztJQUNsQyxNQUFNQyxXQUFXLEdBQUcsc0NBQXNDO0lBRTFELElBQUssSUFBSUMsYUFBYWpCLGVBQWVpQixj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TXdCLGNBQWNuRixLQUFLb0YsSUFBSSxDQUFDLENBQUMzQixVQUFVLEtBQUssTUFBTSxHQUFFLElBQUtFO0lBQzNELE1BQU0wQixTQUFjTixjQUFjLElBQUksSUFBSS9FLEtBQUtvRixJQUFJLENBQUNyQixNQUFNZ0IsWUFBWUk7SUFFdEUsZ0JBQWdCO0lBQ2hCLE1BQU1HLFlBQVlELFNBQVNwQjtJQUUzQiwyQkFBMkI7SUFDM0IsTUFBTXNCLFlBQVl2RixLQUFLb0YsSUFBSSxDQUFDLFNBQVV6QixTQUFTRyxVQUFVRixRQUFTO0lBQ2xFLE1BQU00QixZQUFZeEYsS0FBS0MsR0FBRyxDQUFDNkQsU0FBU3lCO0lBQ3BDLE1BQU16RixRQUFZb0YsVUFBVU0sWUFBWUEsWUFBWTtJQUNwRCxNQUFNQyxhQUFhNUYsVUFBVUM7SUFFN0IsV0FBVztJQUNYLE1BQU00RixlQUFlLENBQUNqQyxVQUFVLEtBQUssS0FBSyxFQUFDLElBQUtLO0lBQ2hELE1BQU02QixhQUFlRCxlQUFlOUI7SUFFcEMsWUFBWTtJQUNaLE1BQU1pQixRQUFRUSxXQUFXLElBQUksSUFBSUksYUFBYUgsWUFBWUs7SUFFMUQsT0FBTztRQUFFLEdBQUdoQixHQUFHO1FBQUVDO1FBQVNHO1FBQVdJO1FBQWFFO1FBQVFDO1FBQVd4RjtRQUFPMkY7UUFBWUM7UUFBY0M7UUFBWWQ7SUFBTTtBQUMxSCIsInNvdXJjZXMiOlsiL1VzZXJzL0FsaWZrYV9Sb29zc2VvL0Rlc2t0b3AvUHJvamVjdC9TbWFydC1wcmludGluZy11cGRhdGUvbGliL2R5bmFtaWMtcHJlc3MtY2FsY3VsYXRvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBEZWZpbmUgQ20gdHlwZSBsb2NhbGx5IHNpbmNlIHR5cGVzIG1vZHVsZSBtaWdodCBub3QgYmUgYXZhaWxhYmxlXG50eXBlIENtID0gbnVtYmVyO1xuXG4vLyA9PT0gRHluYW1pYyBQcmVzcyBEaW1lbnNpb24gQ2FsY3VsYXRvciA9PT1cbi8vIFRoaXMgbW9kdWxlIGNhbGN1bGF0ZXMgb3B0aW1hbCBwcmVzcyBkaW1lbnNpb25zIGJhc2VkIG9uIHByb2R1Y3Qgc2l6ZVxuLy8gRm9sbG93aW5nIHRoZSBFeGNlbCBzaGVldCBsb2dpYyBmb3IgY3V0dGluZyBvcGVyYXRpb25zXG5cbi8vIFVuaXRzLXRhYmxlIFZMT09LVVAgKGN1bXVsYXRpdmUpIGluIGNsb3NlZCBmb3JtIC0gc2FtZSBhcyBFeGNlbFxuY29uc3QgdW5pdFByaWNlID0gKHVuaXRzOiBudW1iZXIpID0+IHtcbiAgY29uc3QgdSA9IE1hdGgubWF4KDAsIE1hdGguZmxvb3IodW5pdHMpKTtcbiAgaWYgKHUgPD0gMTApIHJldHVybiA1MCAqIHU7XG4gIGlmICh1IDw9IDIwKSByZXR1cm4gNjAgKiB1IC0gdSAqIHU7IC8vIDYwdSAtIHVeMlxuICByZXR1cm4gNDAgKiB1O1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBQcmVzc0RpbWVuc2lvbiB7XG4gIHdpZHRoOiBDbTtcbiAgaGVpZ2h0OiBDbTtcbiAgbGFiZWw6IHN0cmluZztcbiAgZWZmaWNpZW5jeTogbnVtYmVyOyAvLyBQZXJjZW50YWdlIG9mIHBhcmVudCBzaGVldCB1dGlsaXplZFxuICBwaWVjZXNQZXJQcmVzczogbnVtYmVyO1xuICBwaWVjZXNQZXJQYXJlbnQ6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9kdWN0RGltZW5zaW9ucyB7XG4gIHdpZHRoOiBDbTtcbiAgaGVpZ2h0OiBDbTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDdXR0aW5nQ29uc3RyYWludHMge1xuICBwYXJlbnRXaWR0aDogQ207XG4gIHBhcmVudEhlaWdodDogQ207XG4gIG1pblByZXNzV2lkdGg6IENtO1xuICBtaW5QcmVzc0hlaWdodDogQ207XG4gIG1heFByZXNzV2lkdGg6IENtO1xuICBtYXhQcmVzc0hlaWdodDogQ207XG4gIGN1dHRpbmdNYXJnaW46IENtOyAvLyBNYXJnaW4gZm9yIGN1dHRpbmcgb3BlcmF0aW9uc1xuICBnYXBCZXR3ZWVuUGllY2VzOiBDbTsgLy8gR2FwIGJldHdlZW4gcHJvZHVjdCBwaWVjZXNcbn1cblxuLy8gRGVmYXVsdCBjdXR0aW5nIGNvbnN0cmFpbnRzIGJhc2VkIG9uIEV4Y2VsIGFuYWx5c2lzXG5leHBvcnQgY29uc3QgREVGQVVMVF9DVVRUSU5HX0NPTlNUUkFJTlRTOiBDdXR0aW5nQ29uc3RyYWludHMgPSB7XG4gIHBhcmVudFdpZHRoOiAxMDAsXG4gIHBhcmVudEhlaWdodDogNzAsXG4gIG1pblByZXNzV2lkdGg6IDIwLFxuICBtaW5QcmVzc0hlaWdodDogMTUsXG4gIG1heFByZXNzV2lkdGg6IDEwMCxcbiAgbWF4UHJlc3NIZWlnaHQ6IDcwLFxuICBjdXR0aW5nTWFyZ2luOiAxLjAsIC8vIDFjbSBtYXJnaW4gZm9yIGN1dHRpbmcgb3BlcmF0aW9uc1xuICBnYXBCZXR3ZWVuUGllY2VzOiAwLjUgLy8gMC41Y20gZ2FwIGJldHdlZW4gcGllY2VzXG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSBvcHRpbWFsIHByZXNzIGRpbWVuc2lvbnMgYmFzZWQgb24gcHJvZHVjdCBzaXplXG4gKiBGb2xsb3dpbmcgRXhjZWwgc2hlZXQgbG9naWM6IHByZXNzIGRpbWVuc2lvbnMgc2hvdWxkIG1heGltaXplIGN1dHRpbmcgZWZmaWNpZW5jeVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlT3B0aW1hbFByZXNzRGltZW5zaW9ucyhcbiAgcHJvZHVjdERpbWVuc2lvbnM6IFByb2R1Y3REaW1lbnNpb25zLFxuICBjb25zdHJhaW50czogQ3V0dGluZ0NvbnN0cmFpbnRzID0gREVGQVVMVF9DVVRUSU5HX0NPTlNUUkFJTlRTXG4pOiBQcmVzc0RpbWVuc2lvbltdIHtcbiAgY29uc3QgeyB3aWR0aDogcHJvZHVjdFdpZHRoLCBoZWlnaHQ6IHByb2R1Y3RIZWlnaHQgfSA9IHByb2R1Y3REaW1lbnNpb25zO1xuICBjb25zdCB7IFxuICAgIHBhcmVudFdpZHRoLCBcbiAgICBwYXJlbnRIZWlnaHQsIFxuICAgIG1pblByZXNzV2lkdGgsIFxuICAgIG1pblByZXNzSGVpZ2h0LCBcbiAgICBtYXhQcmVzc1dpZHRoLCBcbiAgICBtYXhQcmVzc0hlaWdodCxcbiAgICBjdXR0aW5nTWFyZ2luLFxuICAgIGdhcEJldHdlZW5QaWVjZXNcbiAgfSA9IGNvbnN0cmFpbnRzO1xuXG4gIGNvbnNvbGUubG9nKCfwn5SNIENhbGN1bGF0aW5nIG9wdGltYWwgcHJlc3MgZGltZW5zaW9ucyBmb3IgcHJvZHVjdDonLCBwcm9kdWN0RGltZW5zaW9ucyk7XG4gIGNvbnNvbGUubG9nKCfwn5OPIFVzaW5nIGNvbnN0cmFpbnRzOicsIGNvbnN0cmFpbnRzKTtcblxuICBjb25zdCBwcmVzc09wdGlvbnM6IFByZXNzRGltZW5zaW9uW10gPSBbXTtcblxuICAvLyBDYWxjdWxhdGUgYWxsIHBvc3NpYmxlIHByZXNzIGRpbWVuc2lvbnMgdGhhdCBmaXQgd2l0aGluIHBhcmVudCBzaGVldFxuICAvLyB3aXRoIHJlYXNvbmFibGUgY3V0dGluZyBtYXJnaW5zXG4gIGNvbnN0IHN0ZXBTaXplID0gNTsgLy8gNWNtIGluY3JlbWVudHMgZm9yIHByZXNzIGRpbWVuc2lvbnNcbiAgXG4gIGZvciAobGV0IHByZXNzV2lkdGggPSBtaW5QcmVzc1dpZHRoOyBwcmVzc1dpZHRoIDw9IG1heFByZXNzV2lkdGg7IHByZXNzV2lkdGggKz0gc3RlcFNpemUpIHtcbiAgICBmb3IgKGxldCBwcmVzc0hlaWdodCA9IG1pblByZXNzSGVpZ2h0OyBwcmVzc0hlaWdodCA8PSBtYXhQcmVzc0hlaWdodDsgcHJlc3NIZWlnaHQgKz0gc3RlcFNpemUpIHtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgcHJlc3MgZml0cyB3aXRoaW4gcGFyZW50IHNoZWV0IHdpdGggbWFyZ2luc1xuICAgICAgaWYgKHByZXNzV2lkdGggKyBjdXR0aW5nTWFyZ2luIDw9IHBhcmVudFdpZHRoICYmIFxuICAgICAgICAgIHByZXNzSGVpZ2h0ICsgY3V0dGluZ01hcmdpbiA8PSBwYXJlbnRIZWlnaHQpIHtcbiAgICAgICAgXG4gICAgICAgIC8vIENhbGN1bGF0ZSBob3cgbWFueSBwaWVjZXMgZml0IG9uIHRoaXMgcHJlc3Mgc2hlZXRcbiAgICAgICAgY29uc3QgcGllY2VzUGVyUHJlc3MgPSBjYWxjdWxhdGVQaWVjZXNQZXJQcmVzcyhcbiAgICAgICAgICBwcmVzc1dpZHRoLCBcbiAgICAgICAgICBwcmVzc0hlaWdodCwgXG4gICAgICAgICAgcHJvZHVjdFdpZHRoLCBcbiAgICAgICAgICBwcm9kdWN0SGVpZ2h0LCBcbiAgICAgICAgICBnYXBCZXR3ZWVuUGllY2VzXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICAvLyBDYWxjdWxhdGUgaG93IG1hbnkgcHJlc3Mgc2hlZXRzIGZpdCBpbiBwYXJlbnQgc2hlZXRcbiAgICAgICAgY29uc3QgcHJlc3NTaGVldHNQZXJQYXJlbnQgPSBjYWxjdWxhdGVQcmVzc1NoZWV0c1BlclBhcmVudChcbiAgICAgICAgICBwYXJlbnRXaWR0aCwgXG4gICAgICAgICAgcGFyZW50SGVpZ2h0LCBcbiAgICAgICAgICBwcmVzc1dpZHRoLCBcbiAgICAgICAgICBwcmVzc0hlaWdodFxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRvdGFsIHBpZWNlcyBwZXIgcGFyZW50IHNoZWV0XG4gICAgICAgIGNvbnN0IHBpZWNlc1BlclBhcmVudCA9IHBpZWNlc1BlclByZXNzICogcHJlc3NTaGVldHNQZXJQYXJlbnQ7XG4gICAgICAgIFxuICAgICAgICAvLyBDYWxjdWxhdGUgZWZmaWNpZW5jeSAocGVyY2VudGFnZSBvZiBwYXJlbnQgc2hlZXQgdXRpbGl6ZWQpXG4gICAgICAgIGNvbnN0IGVmZmljaWVuY3kgPSAocGllY2VzUGVyUGFyZW50ICogcHJvZHVjdFdpZHRoICogcHJvZHVjdEhlaWdodCkgLyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKHBhcmVudFdpZHRoICogcGFyZW50SGVpZ2h0KSAqIDEwMDtcbiAgICAgICAgXG4gICAgICAgIGlmIChwaWVjZXNQZXJQcmVzcyA+IDAgJiYgcHJlc3NTaGVldHNQZXJQYXJlbnQgPiAwKSB7XG4gICAgICAgICAgcHJlc3NPcHRpb25zLnB1c2goe1xuICAgICAgICAgICAgd2lkdGg6IHByZXNzV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHByZXNzSGVpZ2h0LFxuICAgICAgICAgICAgbGFiZWw6IGAke3ByZXNzV2lkdGh9w5cke3ByZXNzSGVpZ2h0fSBjbWAsXG4gICAgICAgICAgICBlZmZpY2llbmN5OiBNYXRoLnJvdW5kKGVmZmljaWVuY3kgKiAxMDApIC8gMTAwLFxuICAgICAgICAgICAgcGllY2VzUGVyUHJlc3MsXG4gICAgICAgICAgICBwaWVjZXNQZXJQYXJlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFNvcnQgYnkgZWZmaWNpZW5jeSAoaGlnaGVzdCBmaXJzdClcbiAgcHJlc3NPcHRpb25zLnNvcnQoKGEsIGIpID0+IGIuZWZmaWNpZW5jeSAtIGEuZWZmaWNpZW5jeSk7XG5cbiAgY29uc29sZS5sb2coJ/Cfk4ogR2VuZXJhdGVkIHByZXNzIG9wdGlvbnM6JywgcHJlc3NPcHRpb25zLnNsaWNlKDAsIDUpKTsgLy8gTG9nIHRvcCA1IG9wdGlvbnNcblxuICByZXR1cm4gcHJlc3NPcHRpb25zO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBob3cgbWFueSBwcm9kdWN0IHBpZWNlcyBmaXQgb24gYSBwcmVzcyBzaGVldFxuICogRm9sbG93aW5nIEV4Y2VsIGZvcm11bGE6IFJPVU5ERE9XTigoU2hlZXQgV2lkdGgpIC8gKHdpZHRoICsgZ2FwKSwgMCkgw5cgUk9VTkRET1dOKChTaGVldCBIZWlnaHQpIC8gKGhlaWdodCArIGdhcCksIDApXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZVBpZWNlc1BlclByZXNzKFxuICBwcmVzc1dpZHRoOiBDbSxcbiAgcHJlc3NIZWlnaHQ6IENtLFxuICBwcm9kdWN0V2lkdGg6IENtLFxuICBwcm9kdWN0SGVpZ2h0OiBDbSxcbiAgZ2FwOiBDbVxuKTogbnVtYmVyIHtcbiAgLy8gT3B0aW9uIDE6IE5vcm1hbCBvcmllbnRhdGlvblxuICBjb25zdCBjb2xzMSA9IE1hdGguZmxvb3IocHJlc3NXaWR0aCAvIChwcm9kdWN0V2lkdGggKyBnYXApKTtcbiAgY29uc3Qgcm93czEgPSBNYXRoLmZsb29yKHByZXNzSGVpZ2h0IC8gKHByb2R1Y3RIZWlnaHQgKyBnYXApKTtcbiAgY29uc3QgcGllY2VzMSA9IGNvbHMxICogcm93czE7XG5cbiAgLy8gT3B0aW9uIDI6IFJvdGF0ZWQgb3JpZW50YXRpb25cbiAgY29uc3QgY29sczIgPSBNYXRoLmZsb29yKHByZXNzV2lkdGggLyAocHJvZHVjdEhlaWdodCArIGdhcCkpO1xuICBjb25zdCByb3dzMiA9IE1hdGguZmxvb3IocHJlc3NIZWlnaHQgLyAocHJvZHVjdFdpZHRoICsgZ2FwKSk7XG4gIGNvbnN0IHBpZWNlczIgPSBjb2xzMiAqIHJvd3MyO1xuXG4gIC8vIFJldHVybiB0aGUgYmV0dGVyIG9wdGlvbiAoRXhjZWwgbG9naWM6IElGKE9wdGlvbiAxID4gT3B0aW9uIDIsIE9wdGlvbiAxLCBPcHRpb24gMikpXG4gIHJldHVybiBNYXRoLm1heChwaWVjZXMxLCBwaWVjZXMyKTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgaG93IG1hbnkgcHJlc3Mgc2hlZXRzIGZpdCBpbiBwYXJlbnQgc2hlZXRcbiAqIEZvbGxvd2luZyBFeGNlbCBsb2dpYyBmb3IgY3V0dGluZyBvcGVyYXRpb25zXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZVByZXNzU2hlZXRzUGVyUGFyZW50KFxuICBwYXJlbnRXaWR0aDogQ20sXG4gIHBhcmVudEhlaWdodDogQ20sXG4gIHByZXNzV2lkdGg6IENtLFxuICBwcmVzc0hlaWdodDogQ21cbik6IG51bWJlciB7XG4gIC8vIENhbGN1bGF0ZSBob3cgbWFueSBwcmVzcyBzaGVldHMgZml0IGhvcml6b250YWxseSBhbmQgdmVydGljYWxseVxuICBjb25zdCBob3Jpem9udGFsRml0ID0gTWF0aC5mbG9vcihwYXJlbnRXaWR0aCAvIHByZXNzV2lkdGgpO1xuICBjb25zdCB2ZXJ0aWNhbEZpdCA9IE1hdGguZmxvb3IocGFyZW50SGVpZ2h0IC8gcHJlc3NIZWlnaHQpO1xuICBcbiAgcmV0dXJuIGhvcml6b250YWxGaXQgKiB2ZXJ0aWNhbEZpdDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGJlc3QgcHJlc3MgZGltZW5zaW9uIGZvciBhIGdpdmVuIHByb2R1Y3RcbiAqIFJldHVybnMgdGhlIG1vc3QgZWZmaWNpZW50IG9wdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QmVzdFByZXNzRGltZW5zaW9uKFxuICBwcm9kdWN0RGltZW5zaW9uczogUHJvZHVjdERpbWVuc2lvbnMsXG4gIGNvbnN0cmFpbnRzOiBDdXR0aW5nQ29uc3RyYWludHMgPSBERUZBVUxUX0NVVFRJTkdfQ09OU1RSQUlOVFNcbik6IFByZXNzRGltZW5zaW9uIHwgbnVsbCB7XG4gIGNvbnN0IG9wdGlvbnMgPSBjYWxjdWxhdGVPcHRpbWFsUHJlc3NEaW1lbnNpb25zKHByb2R1Y3REaW1lbnNpb25zLCBjb25zdHJhaW50cyk7XG4gIHJldHVybiBvcHRpb25zLmxlbmd0aCA+IDAgPyBvcHRpb25zWzBdIDogbnVsbDtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBwcmVzcyBkaW1lbnNpb25zIGFnYWluc3QgRXhjZWwgZXhhbXBsZXNcbiAqIFRlc3QgZnVuY3Rpb24gdG8gZW5zdXJlIGNhbGN1bGF0aW9ucyBtYXRjaCBFeGNlbCBsb2dpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVQcmVzc0NhbGN1bGF0aW9ucygpOiBib29sZWFuIHtcbiAgY29uc29sZS5sb2coJ/Cfp6ogVmFsaWRhdGluZyBwcmVzcyBjYWxjdWxhdGlvbnMgYWdhaW5zdCBFeGNlbCBleGFtcGxlcy4uLicpO1xuICBcbiAgLy8gVGVzdCBjYXNlOiBCdXNpbmVzcyBjYXJkICg5w5c1LjUpIHNob3VsZCByZXN1bHQgaW4gcHJlc3MgYXJvdW5kIDQww5cyMFxuICBjb25zdCBidXNpbmVzc0NhcmRUZXN0ID0gZ2V0QmVzdFByZXNzRGltZW5zaW9uKHsgd2lkdGg6IDksIGhlaWdodDogNS41IH0pO1xuICBcbiAgY29uc29sZS5sb2coJ/Cfk7EgQnVzaW5lc3MgY2FyZCB0ZXN0IHJlc3VsdDonLCBidXNpbmVzc0NhcmRUZXN0KTtcbiAgXG4gIC8vIEV4cGVjdGVkOiBTaG91bGQgYmUgYXJvdW5kIDQww5cyMCB3aXRoIGdvb2QgZWZmaWNpZW5jeVxuICBjb25zdCBpc1ZhbGlkID0gYnVzaW5lc3NDYXJkVGVzdCAmJiBcbiAgICAgICAgICAgICAgICAgYnVzaW5lc3NDYXJkVGVzdC53aWR0aCA+PSAzNSAmJiBcbiAgICAgICAgICAgICAgICAgYnVzaW5lc3NDYXJkVGVzdC53aWR0aCA8PSA0NSAmJlxuICAgICAgICAgICAgICAgICBidXNpbmVzc0NhcmRUZXN0LmhlaWdodCA+PSAxNSAmJiBcbiAgICAgICAgICAgICAgICAgYnVzaW5lc3NDYXJkVGVzdC5oZWlnaHQgPD0gMjU7XG4gIFxuICBpZiAoaXNWYWxpZCkge1xuICAgIGNvbnNvbGUubG9nKCfinIUgUHJlc3MgY2FsY3VsYXRpb24gdmFsaWRhdGlvbjogUEFTU0VEJyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS53YXJuKCfimqDvuI8gUHJlc3MgY2FsY3VsYXRpb24gdmFsaWRhdGlvbjogRkFJTEVEJyk7XG4gIH1cbiAgXG4gIHJldHVybiBpc1ZhbGlkIHx8IGZhbHNlO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBwcmVzcyBkaW1lbnNpb25zIHNwZWNpZmljYWxseSBmb3IgdmlzdWFsaXphdGlvblxuICogUmV0dXJucyBkaW1lbnNpb25zIHRoYXQgd29yayB3ZWxsIGZvciB0aGUgY3V0dGluZyB2aXN1YWxpemF0aW9uXG4gKiBVc2VzIEVYQUNUIFNBTUUgbG9naWMgYXMgRXhjZWwgY2FsY3VsYXRpb24gKHBpY2tDaGVhcGVzdFRvdGFsICsgY2FsY1Jvd1RvdGFsKVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlVmlzdWFsaXphdGlvblByZXNzRGltZW5zaW9ucyhcbiAgcHJvZHVjdERpbWVuc2lvbnM6IFByb2R1Y3REaW1lbnNpb25zLFxuICBmb3JtRGF0YT86IGFueVxuKTogUHJlc3NEaW1lbnNpb24gfCBudWxsIHtcbiAgLy8gVXNlIHByb2R1Y3QgZGltZW5zaW9ucyBmcm9tIGZvcm0gZGF0YSBpZiBhdmFpbGFibGVcbiAgY29uc3QgcHJvZHVjdFdpZHRoID0gcHJvZHVjdERpbWVuc2lvbnMud2lkdGg7XG4gIGNvbnN0IHByb2R1Y3RIZWlnaHQgPSBwcm9kdWN0RGltZW5zaW9ucy5oZWlnaHQ7XG4gIFxuICBpZiAoIXByb2R1Y3RXaWR0aCB8fCAhcHJvZHVjdEhlaWdodCkge1xuICAgIGNvbnNvbGUud2Fybign4pqg77iPIE1pc3NpbmcgcHJvZHVjdCBkaW1lbnNpb25zIGZvciBwcmVzcyBjYWxjdWxhdGlvbicpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIFxuICBjb25zb2xlLmxvZygn8J+UjSBDYWxjdWxhdGluZyB2aXN1YWxpemF0aW9uIHByZXNzIGRpbWVuc2lvbnMgZm9yOicsIHByb2R1Y3REaW1lbnNpb25zKTtcbiAgXG4gIC8vIFVzZSBFWEFDVCBTQU1FIENVVF9TSVpFX0NBTkRJREFURVMgYXMgRXhjZWwgY2FsY3VsYXRpb25cbiAgY29uc3QgY3V0U2l6ZUNhbmRpZGF0ZXMgPSBbXG4gICAgeyBwYXJlbnRXOiAyMCwgICBwYXJlbnRIOiAxNCwgICAgY3V0UGNzOiAyNSwgbGFiZWw6IFwiMjDDlzE0IC8gQ3AyNVwiIH0sXG4gICAgeyBwYXJlbnRXOiAyMCwgICBwYXJlbnRIOiAxNy41LCAgY3V0UGNzOiAyMCwgbGFiZWw6IFwiMjDDlzE3LjUgLyBDcDIwXCIgfSxcbiAgICB7IHBhcmVudFc6IDIzLCAgIHBhcmVudEg6IDE0LCAgICBjdXRQY3M6IDIxLCBsYWJlbDogXCIyM8OXMTQgLyBDcDIxXCIgfSxcbiAgICB7IHBhcmVudFc6IDIzLCAgIHBhcmVudEg6IDE2LjUsICBjdXRQY3M6IDE4LCBsYWJlbDogXCIyM8OXMTYuNSAvIENwMThcIiB9LFxuICAgIHsgcGFyZW50VzogMjMsICAgcGFyZW50SDogMjAsICAgIGN1dFBjczogMTUsIGxhYmVsOiBcIjIzw5cyMCAvIENwMTVcIiB9LFxuICAgIHsgcGFyZW50VzogMjMsICAgcGFyZW50SDogNTIsICAgIGN1dFBjczogNSwgIGxhYmVsOiBcIjIzw5c1MiAvIENwNVwiICB9LFxuICAgIHsgcGFyZW50VzogMjUsICAgcGFyZW50SDogMTQsICAgIGN1dFBjczogMjAsIGxhYmVsOiBcIjI1w5cxNCAvIENwMjBcIiB9LFxuICAgIHsgcGFyZW50VzogMjUsICAgcGFyZW50SDogMTcuNSwgIGN1dFBjczogMTYsIGxhYmVsOiBcIjI1w5cxNy41IC8gQ3AxNlwiIH0sXG4gICAgeyBwYXJlbnRXOiAyNSwgICBwYXJlbnRIOiAyMCwgICAgY3V0UGNzOiAxNCwgbGFiZWw6IFwiMjXDlzIwIC8gQ3AxNFwiIH0sXG4gICAgeyBwYXJlbnRXOiAyNSwgICBwYXJlbnRIOiAyMywgICAgY3V0UGNzOiAxMiwgbGFiZWw6IFwiMjXDlzIzIC8gQ3AxMlwiIH0sXG4gICAgeyBwYXJlbnRXOiAyOCwgICBwYXJlbnRIOiAxNCwgICAgY3V0UGNzOiAxNywgbGFiZWw6IFwiMjjDlzE0IC8gQ3AxN1wiIH0sXG4gICAgeyBwYXJlbnRXOiAzMCwgICBwYXJlbnRIOiAxNCwgICAgY3V0UGNzOiAxNiwgbGFiZWw6IFwiMzDDlzE0IC8gQ3AxNlwiIH0sXG4gICAgeyBwYXJlbnRXOiAzMCwgICBwYXJlbnRIOiAxNy41LCAgY3V0UGNzOiAxMywgbGFiZWw6IFwiMzDDlzE3LjUgLyBDcDEzXCIgfSxcbiAgICB7IHBhcmVudFc6IDMwLCAgIHBhcmVudEg6IDIwLCAgICBjdXRQY3M6IDExLCBsYWJlbDogXCIzMMOXMjAgLyBDcDExXCIgfSxcbiAgICB7IHBhcmVudFc6IDMwLCAgIHBhcmVudEg6IDIzLCAgICBjdXRQY3M6IDksICBsYWJlbDogXCIzMMOXMjMgLyBDcDlcIiAgfSxcbiAgICB7IHBhcmVudFc6IDM1LCAgIHBhcmVudEg6IDE0LCAgICBjdXRQY3M6IDE0LCBsYWJlbDogXCIzNcOXMTQgLyBDcDE0XCIgfSxcbiAgICB7IHBhcmVudFc6IDM1LCAgIHBhcmVudEg6IDE3LjUsICBjdXRQY3M6IDExLCBsYWJlbDogXCIzNcOXMTcuNSAvIENwMTFcIiB9LFxuICAgIHsgcGFyZW50VzogMzUsICAgcGFyZW50SDogMjAsICAgIGN1dFBjczogMTAsIGxhYmVsOiBcIjM1w5cyMCAvIENwMTBcIiB9LFxuICAgIHsgcGFyZW50VzogMzUsICAgcGFyZW50SDogMjMsICAgIGN1dFBjczogOCwgIGxhYmVsOiBcIjM1w5cyMyAvIENwOFwiICB9LFxuICAgIHsgcGFyZW50VzogMzUsICAgcGFyZW50SDogMjUsICAgIGN1dFBjczogNywgIGxhYmVsOiBcIjM1w5cyNSAvIENwN1wiICB9LFxuICAgIHsgcGFyZW50VzogNDAsICAgcGFyZW50SDogMTQsICAgIGN1dFBjczogMTIsIGxhYmVsOiBcIjQww5cxNCAvIENwMTJcIiB9LFxuICAgIHsgcGFyZW50VzogNDAsICAgcGFyZW50SDogMTcuNSwgIGN1dFBjczogMTAsIGxhYmVsOiBcIjQww5cxNy41IC8gQ3AxMFwiIH0sXG4gICAgeyBwYXJlbnRXOiA0MCwgICBwYXJlbnRIOiAyMCwgICAgY3V0UGNzOiA4LCAgbGFiZWw6IFwiNDDDlzIwIC8gQ3A4XCIgIH0sXG4gICAgeyBwYXJlbnRXOiA0MCwgICBwYXJlbnRIOiAyMywgICAgY3V0UGNzOiA3LCAgbGFiZWw6IFwiNDDDlzIzIC8gQ3A3XCIgIH0sXG4gICAgeyBwYXJlbnRXOiA0MCwgICBwYXJlbnRIOiAyNSwgICAgY3V0UGNzOiA2LCAgbGFiZWw6IFwiNDDDlzI1IC8gQ3A2XCIgIH0sXG4gICAgeyBwYXJlbnRXOiA0MCwgICBwYXJlbnRIOiAzMCwgICAgY3V0UGNzOiA1LCAgbGFiZWw6IFwiNDDDlzMwIC8gQ3A1XCIgIH0sXG4gICAgeyBwYXJlbnRXOiA0MCwgICBwYXJlbnRIOiAzNSwgICAgY3V0UGNzOiA0LCAgbGFiZWw6IFwiNDDDlzM1IC8gQ3A0XCIgIH0sXG4gICAgeyBwYXJlbnRXOiA0NSwgICBwYXJlbnRIOiAyMCwgICAgY3V0UGNzOiA3LCAgbGFiZWw6IFwiNDXDlzIwIC8gQ3A3XCIgIH0sXG4gICAgeyBwYXJlbnRXOiA0NSwgICBwYXJlbnRIOiAyNSwgICAgY3V0UGNzOiA1LCAgbGFiZWw6IFwiNDXDlzI1IC8gQ3A1XCIgIH0sXG4gICAgeyBwYXJlbnRXOiA0NSwgICBwYXJlbnRIOiAzMCwgICAgY3V0UGNzOiA0LCAgbGFiZWw6IFwiNDXDlzMwIC8gQ3A0XCIgIH0sXG4gICAgeyBwYXJlbnRXOiA0NSwgICBwYXJlbnRIOiAzNSwgICAgY3V0UGNzOiAzLCAgbGFiZWw6IFwiNDXDlzM1IC8gQ3AzXCIgIH0sXG4gICAgeyBwYXJlbnRXOiA1MCwgICBwYXJlbnRIOiAyMCwgICAgY3V0UGNzOiA2LCAgbGFiZWw6IFwiNTDDlzIwIC8gQ3A2XCIgIH0sXG4gICAgeyBwYXJlbnRXOiA1MCwgICBwYXJlbnRIOiAyNSwgICAgY3V0UGNzOiA1LCAgbGFiZWw6IFwiNTDDlzI1IC8gQ3A1XCIgIH0sXG4gICAgeyBwYXJlbnRXOiA1MCwgICBwYXJlbnRIOiAzMCwgICAgY3V0UGNzOiA0LCAgbGFiZWw6IFwiNTDDlzMwIC8gQ3A0XCIgIH0sXG4gICAgeyBwYXJlbnRXOiA1MCwgICBwYXJlbnRIOiAzNSwgICAgY3V0UGNzOiA0LCAgbGFiZWw6IFwiNTDDlzM1IC8gQ3A0XCIgIH1cbiAgXTtcbiAgXG4gIC8vIFVzZSBFWEFDVCBTQU1FIGxvZ2ljIGFzIEV4Y2VsIGNhbGN1bGF0aW9uXG4gIC8vIEdldCBmb3JtIGRhdGEgdmFsdWVzIGZvciBhY2N1cmF0ZSBjYWxjdWxhdGlvblxuICBjb25zdCBzaWRlcyA9IGZvcm1EYXRhPy5wcm9kdWN0cz8uWzBdPy5zaWRlcyA9PT0gXCIxXCIgPyAxIDogMjtcbiAgY29uc3QgY29sb3VycyA9IGZvcm1EYXRhPy5wcm9kdWN0cz8uWzBdPy5jb2xvdXJzIHx8IDQ7XG4gIGNvbnN0IHF0eSA9IGZvcm1EYXRhPy5wcm9kdWN0cz8uWzBdPy5xdWFudGl0eSB8fCAxMDAwO1xuICBjb25zdCBwYXBlckNvc3RQZXJTaGVldCA9IDE7IC8vIFN0YW5kYXJkIHBhcGVyIGNvc3QgZm9yIHZpc3VhbGl6YXRpb25cbiAgXG4gIC8vIENyZWF0ZSBiYXNlIG9iamVjdCBmb3IgY2FsY1Jvd1RvdGFsXG4gIGNvbnN0IGJhc2UgPSB7XG4gICAgcGllY2VXOiBwcm9kdWN0V2lkdGgsXG4gICAgcGllY2VIOiBwcm9kdWN0SGVpZ2h0LFxuICAgIHF0eTogcXR5LFxuICAgIHNpZGVzOiBzaWRlcyxcbiAgICBjb2xvdXJzOiBjb2xvdXJzLFxuICAgIHBhcGVyQ29zdFBlclNoZWV0OiBwYXBlckNvc3RQZXJTaGVldFxuICB9O1xuICBcbiAgLy8gVXNlIEVYQUNUIFNBTUUgcGlja0NoZWFwZXN0VG90YWwgbG9naWNcbiAgY29uc3Qgcm93cyA9IGN1dFNpemVDYW5kaWRhdGVzLm1hcChjYW5kaWRhdGUgPT4gY2FsY1Jvd1RvdGFsKGJhc2UsIGNhbmRpZGF0ZSkpO1xuICBcbiAgLy8gRmlsdGVyIG91dCBjYW5kaWRhdGVzIHdpdGggbm9PZlVwcyA9IDAgKGludmFsaWQgY2FuZGlkYXRlcylcbiAgY29uc3QgdmFsaWRSb3dzID0gcm93cy5maWx0ZXIocm93ID0+IHJvdy5ub09mVXBzID4gMCk7XG4gIFxuICBpZiAodmFsaWRSb3dzLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnNvbGUud2Fybign4pqg77iPIE5vIHZhbGlkIGNhbmRpZGF0ZXMgZm91bmQgKGFsbCBoYXZlIG5vT2ZVcHMgPSAwKScpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIFxuICB2YWxpZFJvd3Muc29ydCgoYSwgYikgPT4gYS50b3RhbCAtIGIudG90YWwpO1xuICBjb25zdCBjaGVhcGVzdFJvdyA9IHZhbGlkUm93c1swXTsgLy8gY2hlYXBlc3QgdmFsaWQgcm93XG4gIFxuICBpZiAoY2hlYXBlc3RSb3cpIHtcbiAgICBjb25zb2xlLmxvZygn8J+OryBCZXN0IGN1dHRpbmcgc2l6ZSBmb3VuZCAoRXhjZWwgbG9naWMpOicsIGNoZWFwZXN0Um93KTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgZWZmaWNpZW5jeSBwZXJjZW50YWdlXG4gICAgY29uc3QgZWZmaWNpZW5jeSA9IChjaGVhcGVzdFJvdy51cHNQZXJTaHQgKiBwcm9kdWN0V2lkdGggKiBwcm9kdWN0SGVpZ2h0KSAvIFxuICAgICAgICAgICAgICAgICAgICAgIChjaGVhcGVzdFJvdy5wYXJlbnRXICogY2hlYXBlc3RSb3cucGFyZW50SCkgKiAxMDA7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBjaGVhcGVzdFJvdy5wYXJlbnRXLFxuICAgICAgaGVpZ2h0OiBjaGVhcGVzdFJvdy5wYXJlbnRILFxuICAgICAgbGFiZWw6IGNoZWFwZXN0Um93LmxhYmVsIHx8IGAke2NoZWFwZXN0Um93LnBhcmVudFd9w5cke2NoZWFwZXN0Um93LnBhcmVudEh9IGNtYCxcbiAgICAgIGVmZmljaWVuY3k6IE1hdGgucm91bmQoZWZmaWNpZW5jeSAqIDEwMCkgLyAxMDAsXG4gICAgICBwaWVjZXNQZXJQcmVzczogY2hlYXBlc3RSb3cubm9PZlVwcyxcbiAgICAgIHBpZWNlc1BlclBhcmVudDogY2hlYXBlc3RSb3cuY3V0UGNzXG4gICAgfTtcbiAgfVxuICBcbiAgLy8gRmFsbGJhY2s6IHVzZSBwYXJlbnQgc2hlZXQgc2l6ZSBmb3IgdmVyeSBsYXJnZSBwcm9kdWN0c1xuICBjb25zb2xlLmxvZygn4pqg77iPIE5vIG9wdGltYWwgY3V0dGluZyBzaXplIGZvdW5kLCB1c2luZyBwYXJlbnQgc2hlZXQgc2l6ZScpO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiAxMDAsXG4gICAgaGVpZ2h0OiA3MCxcbiAgICBsYWJlbDogXCIxMDDDlzcwIGNtIChQYXJlbnQgU2hlZXQpXCIsXG4gICAgZWZmaWNpZW5jeTogMTAwLFxuICAgIHBpZWNlc1BlclByZXNzOiAxLFxuICAgIHBpZWNlc1BlclBhcmVudDogMVxuICB9O1xufVxuXG4vKipcbiAqIEVYQUNUIENPUFkgb2YgY2FsY1Jvd1RvdGFsIGZyb20gU3RlcDRPcGVyYXRpb25hbC50c3hcbiAqIFRoaXMgZW5zdXJlcyB0aGUgdmlzdWFsaXphdGlvbiB1c2VzIHRoZSBzYW1lIGNhbGN1bGF0aW9uIGxvZ2ljXG4gKi9cbmZ1bmN0aW9uIGNhbGNSb3dUb3RhbChcbiAgYmFzZTogeyBwaWVjZVc6IG51bWJlcjsgcGllY2VIOiBudW1iZXI7IHF0eTogbnVtYmVyOyBzaWRlczogbnVtYmVyOyBjb2xvdXJzOiBudW1iZXI7IHBhcGVyQ29zdFBlclNoZWV0OiBudW1iZXIgfSxcbiAgcm93OiB7IHBhcmVudFc6IG51bWJlcjsgcGFyZW50SDogbnVtYmVyOyBjdXRQY3M6IG51bWJlcjsgbGFiZWw/OiBzdHJpbmcgfVxuKSB7XG4gIGNvbnN0IHsgcGllY2VXLCBwaWVjZUgsIHF0eSwgc2lkZXMsIGNvbG91cnMsIHBhcGVyQ29zdFBlclNoZWV0IH0gPSBiYXNlO1xuICBjb25zdCB7IHBhcmVudFcsIHBhcmVudEgsIGN1dFBjcyB9ID0gcm93O1xuXG4gIC8vIDEpIEltcG9zaXRpb24gKE9wdGlvbjEvMilcbiAgY29uc3Qgb3B0MSA9IE1hdGguZmxvb3IocGFyZW50VyAvIChwaWVjZUggKyAxKSkgKiBNYXRoLmZsb29yKHBhcmVudEggLyAocGllY2VXICsgMSkpO1xuICBjb25zdCBvcHQyID0gTWF0aC5mbG9vcihwYXJlbnRXIC8gKHBpZWNlVyArIDEpKSAqIE1hdGguZmxvb3IocGFyZW50SCAvIChwaWVjZUggKyAxKSk7XG4gIGNvbnN0IG5vT2ZVcHMgPSBNYXRoLm1heChvcHQxLCBvcHQyKTtcblxuICAvLyAyKSBPZGQvZXZlbiBydWxlIChJRihTaWRlcz0xLCBUUlVFLCBJU0VWRU4oTm8uIG9mIHVwcykpKVxuICBjb25zdCBvZGRFdmVuID0gKHNpZGVzID09PSAxKSA/IHRydWUgOiAobm9PZlVwcyAlIDIgPT09IDApO1xuXG4gIC8vIDMpIFVwcy9zaGVldDsgNCkgV2FzdGU7IDUpIFNoZWV0c1xuICBjb25zdCB1cHNQZXJTaHQgICA9IG5vT2ZVcHMgKiBjdXRQY3M7XG4gIGNvbnN0IHdhc3RlU2hlZXRzID0gTWF0aC5jZWlsKChwYXJlbnRXID4gNTAgPyAxMjAgOiAxMDApIC8gY3V0UGNzKTtcbiAgY29uc3Qgc2hlZXRzICAgICAgPSB1cHNQZXJTaHQgPT09IDAgPyAwIDogTWF0aC5jZWlsKHF0eSAvIHVwc1BlclNodCArIHdhc3RlU2hlZXRzKTtcblxuICAvLyA2KSBQYXBlciBjb3N0XG4gIGNvbnN0IHBhcGVyQ29zdCA9IHNoZWV0cyAqIHBhcGVyQ29zdFBlclNoZWV0O1xuXG4gIC8vIDcpIFVuaXRzIOKGkiA4KSB1bml0IHByaWNlXG4gIGNvbnN0IGNvcmVVbml0cyA9IE1hdGguY2VpbCgoc2hlZXRzICogY3V0UGNzICogY29sb3VycyAqIHNpZGVzKSAvIDEwMDApO1xuICBjb25zdCBiYXNlVW5pdHMgPSBNYXRoLm1heChjb2xvdXJzLCBjb3JlVW5pdHMpO1xuICBjb25zdCB1bml0cyAgICAgPSBvZGRFdmVuID8gYmFzZVVuaXRzIDogYmFzZVVuaXRzICogMjtcbiAgY29uc3QgdW5pdF9wcmljZSA9IHVuaXRQcmljZSh1bml0cyk7XG5cbiAgLy8gOSkgUGxhdGVcbiAgY29uc3QgcGxhdGVQZXJTaWRlID0gKHBhcmVudFcgPiA1NCA/IDUwIDogMjApICogY29sb3VycztcbiAgY29uc3QgcGxhdGVUb3RhbCAgID0gcGxhdGVQZXJTaWRlICogc2lkZXM7XG5cbiAgLy8gMTApIFRvdGFsXG4gIGNvbnN0IHRvdGFsID0gc2hlZXRzID09PSAwID8gMCA6IHVuaXRfcHJpY2UgKyBwYXBlckNvc3QgKyBwbGF0ZVRvdGFsO1xuXG4gIHJldHVybiB7IC4uLnJvdywgbm9PZlVwcywgdXBzUGVyU2h0LCB3YXN0ZVNoZWV0cywgc2hlZXRzLCBwYXBlckNvc3QsIHVuaXRzLCB1bml0X3ByaWNlLCBwbGF0ZVBlclNpZGUsIHBsYXRlVG90YWwsIHRvdGFsIH07XG59XG4iXSwibmFtZXMiOlsidW5pdFByaWNlIiwidW5pdHMiLCJ1IiwiTWF0aCIsIm1heCIsImZsb29yIiwiREVGQVVMVF9DVVRUSU5HX0NPTlNUUkFJTlRTIiwicGFyZW50V2lkdGgiLCJwYXJlbnRIZWlnaHQiLCJtaW5QcmVzc1dpZHRoIiwibWluUHJlc3NIZWlnaHQiLCJtYXhQcmVzc1dpZHRoIiwibWF4UHJlc3NIZWlnaHQiLCJjdXR0aW5nTWFyZ2luIiwiZ2FwQmV0d2VlblBpZWNlcyIsImNhbGN1bGF0ZU9wdGltYWxQcmVzc0RpbWVuc2lvbnMiLCJwcm9kdWN0RGltZW5zaW9ucyIsImNvbnN0cmFpbnRzIiwid2lkdGgiLCJwcm9kdWN0V2lkdGgiLCJoZWlnaHQiLCJwcm9kdWN0SGVpZ2h0IiwiY29uc29sZSIsImxvZyIsInByZXNzT3B0aW9ucyIsInN0ZXBTaXplIiwicHJlc3NXaWR0aCIsInByZXNzSGVpZ2h0IiwicGllY2VzUGVyUHJlc3MiLCJjYWxjdWxhdGVQaWVjZXNQZXJQcmVzcyIsInByZXNzU2hlZXRzUGVyUGFyZW50IiwiY2FsY3VsYXRlUHJlc3NTaGVldHNQZXJQYXJlbnQiLCJwaWVjZXNQZXJQYXJlbnQiLCJlZmZpY2llbmN5IiwicHVzaCIsImxhYmVsIiwicm91bmQiLCJzb3J0IiwiYSIsImIiLCJzbGljZSIsImdhcCIsImNvbHMxIiwicm93czEiLCJwaWVjZXMxIiwiY29sczIiLCJyb3dzMiIsInBpZWNlczIiLCJob3Jpem9udGFsRml0IiwidmVydGljYWxGaXQiLCJnZXRCZXN0UHJlc3NEaW1lbnNpb24iLCJvcHRpb25zIiwibGVuZ3RoIiwidmFsaWRhdGVQcmVzc0NhbGN1bGF0aW9ucyIsImJ1c2luZXNzQ2FyZFRlc3QiLCJpc1ZhbGlkIiwid2FybiIsImNhbGN1bGF0ZVZpc3VhbGl6YXRpb25QcmVzc0RpbWVuc2lvbnMiLCJmb3JtRGF0YSIsImN1dFNpemVDYW5kaWRhdGVzIiwicGFyZW50VyIsInBhcmVudEgiLCJjdXRQY3MiLCJzaWRlcyIsInByb2R1Y3RzIiwiY29sb3VycyIsInF0eSIsInF1YW50aXR5IiwicGFwZXJDb3N0UGVyU2hlZXQiLCJiYXNlIiwicGllY2VXIiwicGllY2VIIiwicm93cyIsIm1hcCIsImNhbmRpZGF0ZSIsImNhbGNSb3dUb3RhbCIsInZhbGlkUm93cyIsImZpbHRlciIsInJvdyIsIm5vT2ZVcHMiLCJ0b3RhbCIsImNoZWFwZXN0Um93IiwidXBzUGVyU2h0Iiwib3B0MSIsIm9wdDIiLCJvZGRFdmVuIiwid2FzdGVTaGVldHMiLCJjZWlsIiwic2hlZXRzIiwicGFwZXJDb3N0IiwiY29yZVVuaXRzIiwiYmFzZVVuaXRzIiwidW5pdF9wcmljZSIsInBsYXRlUGVyU2lkZSIsInBsYXRlVG90YWwiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/dynamic-press-calculator.ts\n"));

/***/ })

});